<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月16日</title>
    <link href="/2020/07/17/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8816%E6%97%A5/"/>
    <url>/2020/07/17/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8816%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><p>今日新增手游关键词：<strong>咔叽探险队，放开那三国3，古剑奇谭网络版</strong>。</p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>我的世界+minecraft ↑1</td><td>78503</td></tr><tr><td>2</td><td>英雄联盟+lol ↓1</td><td>77352</td></tr><tr><td>3</td><td>坦克世界</td><td>52836</td></tr><tr><td>4</td><td>地下城与勇士+dnf ↑1</td><td>33546</td></tr><tr><td>5</td><td>穿越火线+cf ↑1</td><td>30446</td></tr><tr><td>6</td><td>炉石传说 ↓2</td><td>18027</td></tr><tr><td>7</td><td>刀塔2+DOTA2 ↑3</td><td>16798</td></tr><tr><td>8</td><td>古剑奇谭ol+古剑奇谭网络版 ↑new</td><td>15978</td></tr><tr><td>9</td><td>绝地求生+pubg</td><td>15241</td></tr><tr><td>10</td><td>梦幻西游 ↓3</td><td>14976</td></tr><tr><td>11</td><td>龙之谷 ↑2</td><td>14462</td></tr><tr><td>12</td><td>最终幻想14+ff14 ↓4</td><td>13868</td></tr><tr><td>13</td><td>魔兽世界+wow ↓1</td><td>11569</td></tr><tr><td>14</td><td>剑灵 ↑15</td><td>10472</td></tr><tr><td>15</td><td>csgo ↓1</td><td>10001</td></tr><tr><td>16</td><td>天龙八部 ↓1</td><td>8607</td></tr><tr><td>17</td><td>激战2 ↓6</td><td>8560</td></tr><tr><td>18</td><td>冒险岛 ↓2</td><td>8460</td></tr><tr><td>19</td><td>方舟生存进化 ↓2</td><td>7463</td></tr><tr><td>20</td><td>300英雄 ↑2</td><td>7421</td></tr><tr><td>21</td><td>守望先锋 ↓3</td><td>7258</td></tr><tr><td>22</td><td>逆水寒 ↓1</td><td>7149</td></tr><tr><td>23</td><td>天涯明月刀 ↓4</td><td>5696</td></tr><tr><td>24</td><td>星际战甲+warframe ↓4</td><td>5650</td></tr><tr><td>25</td><td>变形金刚 ↓1</td><td>5464</td></tr><tr><td>26</td><td>QQ飞车 ↓1</td><td>5408</td></tr><tr><td>27</td><td>诛仙 ↓4</td><td>5357</td></tr><tr><td>28</td><td>战舰世界 ↓2</td><td>5144</td></tr><tr><td>29</td><td>大话西游 ↓1</td><td>4840</td></tr><tr><td>30</td><td>传奇</td><td>4721</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>110989</td></tr><tr><td>2</td><td>我的世界+mc ↑2</td><td>78191</td></tr><tr><td>3</td><td>迷你世界 ↓1</td><td>76431</td></tr><tr><td>4</td><td>和平精英 ↓1</td><td>75310</td></tr><tr><td>5</td><td>江南百景图</td><td>57218</td></tr><tr><td>6</td><td>光遇 ↑1</td><td>32436</td></tr><tr><td>7</td><td>香肠派对 ↑1</td><td>32055</td></tr><tr><td>8</td><td>第五人格 ↑1</td><td>21671</td></tr><tr><td>9</td><td>咔叽探险队 ↑new</td><td>19463</td></tr><tr><td>10</td><td>炉石传说 ↓4</td><td>18027</td></tr><tr><td>11</td><td>恋与制作人 ↑9</td><td>17053</td></tr><tr><td>12</td><td>阴阳师 ↓2</td><td>14346</td></tr><tr><td>13</td><td>荒野乱斗</td><td>14225</td></tr><tr><td>14</td><td>最强蜗牛 ↓3</td><td>14141</td></tr><tr><td>15</td><td>球球大作战</td><td>13994</td></tr><tr><td>16</td><td>妖神记 ↓4</td><td>13941</td></tr><tr><td>17</td><td>明日之后 ↓1</td><td>9598</td></tr><tr><td>18</td><td>崩坏3</td><td>9180</td></tr><tr><td>19</td><td>部落冲突 ↓2</td><td>8681</td></tr><tr><td>20</td><td>欢乐斗地主 ↓1</td><td>8254</td></tr><tr><td>21</td><td>梦幻西游三维版 ↓7</td><td>7143</td></tr><tr><td>22</td><td>碧蓝航线 ↑6</td><td>6476</td></tr><tr><td>23</td><td>狼人杀 ↑1</td><td>6447</td></tr><tr><td>24</td><td>饥荒 ↓1</td><td>6194</td></tr><tr><td>25</td><td>灌篮高手 ↓4</td><td>6031</td></tr><tr><td>26</td><td>剑与远征 ↓4</td><td>5921</td></tr><tr><td>27</td><td>忍者必须死3 ↑new</td><td>5852</td></tr><tr><td>28</td><td>率土之滨 ↓2</td><td>5423</td></tr><tr><td>29</td><td>火影忍者手游 ↑1</td><td>5264</td></tr><tr><td>30</td><td>大话西游 ↓1</td><td>4840</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月15日</title>
    <link href="/2020/07/16/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8815%E6%97%A5/"/>
    <url>/2020/07/16/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8815%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>76759</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>68112</td></tr><tr><td>3</td><td>坦克世界 ↑3</td><td>57635</td></tr><tr><td>4</td><td>炉石传说 ↑6</td><td>36800</td></tr><tr><td>5</td><td>地下城与勇士+dnf ↑2</td><td>24345</td></tr><tr><td>6</td><td>穿越火线+cf ↓2</td><td>24161</td></tr><tr><td>7</td><td>梦幻西游 ↓2</td><td>18629</td></tr><tr><td>8</td><td>最终幻想14+ff14 ↑1</td><td>17657</td></tr><tr><td>9</td><td>绝地求生+pubg ↓1</td><td>15634</td></tr><tr><td>10</td><td>刀塔2+DOTA2 ↑1</td><td>14425</td></tr><tr><td>11</td><td>激战2 ↑8</td><td>11758</td></tr><tr><td>12</td><td>魔兽世界+wow</td><td>11107</td></tr><tr><td>13</td><td>龙之谷 ↑1</td><td>10936</td></tr><tr><td>14</td><td>csgo ↓1</td><td>10487</td></tr><tr><td>15</td><td>天龙八部</td><td>8146</td></tr><tr><td>16</td><td>冒险岛</td><td>8072</td></tr><tr><td>17</td><td>方舟生存进化 ↑1</td><td>7781</td></tr><tr><td>18</td><td>守望先锋 ↑2</td><td>7650</td></tr><tr><td>19</td><td>天涯明月刀 ↓2</td><td>6884</td></tr><tr><td>20</td><td>星际战甲+warframe ↑4</td><td>6622</td></tr><tr><td>21</td><td>逆水寒 ↑1</td><td>6397</td></tr><tr><td>22</td><td>300英雄 ↑new</td><td>6339</td></tr><tr><td>23</td><td>诛仙 ↓2</td><td>5726</td></tr><tr><td>24</td><td>变形金刚 ↓1</td><td>5488</td></tr><tr><td>25</td><td>QQ飞车 ↓22</td><td>5170</td></tr><tr><td>26</td><td>战舰世界 ↑4</td><td>5134</td></tr><tr><td>27</td><td>EVE ↓2</td><td>4878</td></tr><tr><td>28</td><td>大话西游 ↓2</td><td>4741</td></tr><tr><td>29</td><td>剑灵</td><td>4596</td></tr><tr><td>30</td><td>传奇 ↓2</td><td>4546</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>115365</td></tr><tr><td>2</td><td>迷你世界</td><td>79717</td></tr><tr><td>3</td><td>和平精英</td><td>70183</td></tr><tr><td>4</td><td>我的世界+mc</td><td>67822</td></tr><tr><td>5</td><td>江南百景图</td><td>47403</td></tr><tr><td>6</td><td>炉石传说 ↑9</td><td>36800</td></tr><tr><td>7</td><td>光遇 ↓1</td><td>34175</td></tr><tr><td>8</td><td>香肠派对 ↓1</td><td>32734</td></tr><tr><td>9</td><td>第五人格</td><td>17677</td></tr><tr><td>10</td><td>阴阳师 ↑2</td><td>17038</td></tr><tr><td>11</td><td>最强蜗牛 ↓1</td><td>14927</td></tr><tr><td>12</td><td>妖神记 ↑2</td><td>14517</td></tr><tr><td>13</td><td>荒野乱斗 ↓2</td><td>14319</td></tr><tr><td>14</td><td>梦幻西游三维版 ↑new</td><td>14022</td></tr><tr><td>15</td><td>球球大作战 ↓2</td><td>13332</td></tr><tr><td>16</td><td>明日之后 ↑1</td><td>8909</td></tr><tr><td>17</td><td>部落冲突 ↑1</td><td>8574</td></tr><tr><td>18</td><td>崩坏3 ↓2</td><td>8303</td></tr><tr><td>19</td><td>欢乐斗地主</td><td>8180</td></tr><tr><td>20</td><td>恋与制作人 ↑new</td><td>7142</td></tr><tr><td>21</td><td>灌篮高手</td><td>6555</td></tr><tr><td>22</td><td>剑与远征 ↓2</td><td>6372</td></tr><tr><td>23</td><td>饥荒 ↑2</td><td>5847</td></tr><tr><td>24</td><td>狼人杀 ↓1</td><td>5833</td></tr><tr><td>25</td><td>梦幻西游手游 ↑3</td><td>5702</td></tr><tr><td>26</td><td>率土之滨</td><td>5527</td></tr><tr><td>27</td><td>龙之谷2 ↓3</td><td>5478</td></tr><tr><td>28</td><td>碧蓝航线 ↓1</td><td>5261</td></tr><tr><td>29</td><td>大话西游 ↑1</td><td>4741</td></tr><tr><td>30</td><td>火影忍者手游 ↑new</td><td>4546</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月14日</title>
    <link href="/2020/07/15/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8814%E6%97%A5/"/>
    <url>/2020/07/15/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8814%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>72906</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>65000</td></tr><tr><td>3</td><td>QQ飞车 ↑3</td><td>24149</td></tr><tr><td>4</td><td>穿越火线+cf ↓1</td><td>23903</td></tr><tr><td>5</td><td>梦幻西游 ↓1</td><td>20144</td></tr><tr><td>6</td><td>坦克世界 ↑2</td><td>18226</td></tr><tr><td>7</td><td>地下城与勇士+dnf ↓2</td><td>17827</td></tr><tr><td>8</td><td>绝地求生+pubg ↓1</td><td>15091</td></tr><tr><td>9</td><td>最终幻想14+ff14 ↑1</td><td>13794</td></tr><tr><td>10</td><td>炉石传说 ↑6</td><td>12246</td></tr><tr><td>11</td><td>刀塔2+DOTA2 ↑2</td><td>10898</td></tr><tr><td>12</td><td>魔兽世界+wow ↓1</td><td>10869</td></tr><tr><td>13</td><td>csgo ↓1</td><td>10512</td></tr><tr><td>14</td><td>龙之谷 ↑3</td><td>9516</td></tr><tr><td>15</td><td>天龙八部</td><td>9256</td></tr><tr><td>16</td><td>冒险岛 ↓2</td><td>8425</td></tr><tr><td>17</td><td>天涯明月刀 ↓8</td><td>7722</td></tr><tr><td>18</td><td>方舟生存进化</td><td>7477</td></tr><tr><td>19</td><td>激战2</td><td>7439</td></tr><tr><td>20</td><td>守望先锋</td><td>7184</td></tr><tr><td>21</td><td>诛仙</td><td>6556</td></tr><tr><td>22</td><td>逆水寒</td><td>6346</td></tr><tr><td>23</td><td>变形金刚</td><td>5723</td></tr><tr><td>24</td><td>星际战甲+warframe</td><td>5689</td></tr><tr><td>25</td><td>EVE</td><td>4770</td></tr><tr><td>26</td><td>大话西游</td><td>4542</td></tr><tr><td>27</td><td>龙族 ↑2</td><td>4434</td></tr><tr><td>28</td><td>传奇 ↓1</td><td>4390</td></tr><tr><td>29</td><td>剑灵 ↑1</td><td>4217</td></tr><tr><td>30</td><td>战舰世界 ↓2</td><td>4188</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>124775</td></tr><tr><td>2</td><td>迷你世界 ↑2</td><td>80983</td></tr><tr><td>3</td><td>和平精英 ↓1</td><td>67766</td></tr><tr><td>4</td><td>我的世界+mc ↓1</td><td>64743</td></tr><tr><td>5</td><td>江南百景图 ↑1</td><td>41149</td></tr><tr><td>6</td><td>光遇 ↓1</td><td>39650</td></tr><tr><td>7</td><td>香肠派对</td><td>33082</td></tr><tr><td>8</td><td>QQ飞车手游 ↑6</td><td>24746</td></tr><tr><td>9</td><td>第五人格</td><td>17287</td></tr><tr><td>10</td><td>最强蜗牛 ↓2</td><td>15600</td></tr><tr><td>11</td><td>荒野乱斗 ↓1</td><td>14147</td></tr><tr><td>12</td><td>阴阳师</td><td>14146</td></tr><tr><td>13</td><td>球球大作战</td><td>13022</td></tr><tr><td>14</td><td>妖神记 ↓3</td><td>12458</td></tr><tr><td>15</td><td>炉石传说 ↑1</td><td>12246</td></tr><tr><td>16</td><td>崩坏3 ↓1</td><td>8899</td></tr><tr><td>17</td><td>明日之后</td><td>8768</td></tr><tr><td>18</td><td>部落冲突</td><td>8679</td></tr><tr><td>19</td><td>欢乐斗地主</td><td>8290</td></tr><tr><td>20</td><td>剑与远征 ↑2</td><td>6867</td></tr><tr><td>21</td><td>灌篮高手 ↓1</td><td>6220</td></tr><tr><td>22</td><td>天龙八部手游 ↑new</td><td>6126</td></tr><tr><td>23</td><td>狼人杀 ↑1</td><td>5747</td></tr><tr><td>24</td><td>龙之谷2 ↓3</td><td>5681</td></tr><tr><td>25</td><td>饥荒 ↓2</td><td>5410</td></tr><tr><td>26</td><td>率土之滨 ↓1</td><td>5345</td></tr><tr><td>27</td><td>碧蓝航线 ↓1</td><td>5214</td></tr><tr><td>28</td><td>梦幻西游手游 ↑new</td><td>4687</td></tr><tr><td>29</td><td>开心消消乐 ↑new</td><td>4554</td></tr><tr><td>30</td><td>大话西游 ↓1</td><td>4542</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月13日</title>
    <link href="/2020/07/14/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8813%E6%97%A5/"/>
    <url>/2020/07/14/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8813%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>79276</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>64453</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>23855</td></tr><tr><td>4</td><td>梦幻西游 ↑4</td><td>19499</td></tr><tr><td>5</td><td>地下城与勇士+dnf ↓1</td><td>18009</td></tr><tr><td>6</td><td>QQ飞车</td><td>15306</td></tr><tr><td>7</td><td>绝地求生+pubg ↓2</td><td>14901</td></tr><tr><td>8</td><td>坦克世界 ↓1</td><td>14306</td></tr><tr><td>9</td><td>天涯明月刀 ↑15</td><td>14021</td></tr><tr><td>10</td><td>最终幻想14+ff14 ↓1</td><td>13104</td></tr><tr><td>11</td><td>魔兽世界+wow ↑1</td><td>10914</td></tr><tr><td>12</td><td>csgo ↓2</td><td>10530</td></tr><tr><td>13</td><td>刀塔2+DOTA2 ↑3</td><td>10514</td></tr><tr><td>14</td><td>冒险岛 ↑3</td><td>9803</td></tr><tr><td>15</td><td>天龙八部 ↓4</td><td>9454</td></tr><tr><td>16</td><td>炉石传说 ↓2</td><td>9400</td></tr><tr><td>17</td><td>龙之谷 ↓4</td><td>8864</td></tr><tr><td>18</td><td>方舟生存进化 ↓3</td><td>7542</td></tr><tr><td>19</td><td>激战2 ↑1</td><td>7049</td></tr><tr><td>20</td><td>守望先锋 ↓1</td><td>6962</td></tr><tr><td>21</td><td>诛仙 ↑4</td><td>6627</td></tr><tr><td>22</td><td>逆水寒 ↓1</td><td>6253</td></tr><tr><td>23</td><td>变形金刚 ↓5</td><td>5805</td></tr><tr><td>24</td><td>星际战甲+warframe ↓2</td><td>5630</td></tr><tr><td>25</td><td>EVE ↑4</td><td>4933</td></tr><tr><td>26</td><td>大话西游 ↓3</td><td>4654</td></tr><tr><td>27</td><td>传奇 ↓1</td><td>4595</td></tr><tr><td>28</td><td>战舰世界</td><td>4422</td></tr><tr><td>29</td><td>龙族 ↓2</td><td>4333</td></tr><tr><td>30</td><td>剑灵 ↑new</td><td>4211</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>104592</td></tr><tr><td>2</td><td>和平精英</td><td>65481</td></tr><tr><td>3</td><td>我的世界+mc</td><td>64179</td></tr><tr><td>4</td><td>迷你世界</td><td>58418</td></tr><tr><td>5</td><td>光遇</td><td>38731</td></tr><tr><td>6</td><td>江南百景图 ↑1</td><td>37099</td></tr><tr><td>7</td><td>香肠派对 ↓1</td><td>31002</td></tr><tr><td>8</td><td>最强蜗牛 ↑1</td><td>17120</td></tr><tr><td>9</td><td>第五人格 ↓1</td><td>16859</td></tr><tr><td>10</td><td>荒野乱斗</td><td>14704</td></tr><tr><td>11</td><td>妖神记</td><td>12946</td></tr><tr><td>12</td><td>阴阳师 ↑1</td><td>12387</td></tr><tr><td>13</td><td>球球大作战 ↓1</td><td>12271</td></tr><tr><td>14</td><td>QQ飞车手游 ↑3</td><td>11719</td></tr><tr><td>15</td><td>崩坏3 ↓1</td><td>9949</td></tr><tr><td>16</td><td>炉石传说 ↑2</td><td>9400</td></tr><tr><td>17</td><td>明日之后 ↓2</td><td>8904</td></tr><tr><td>18</td><td>部落冲突 ↓2</td><td>8287</td></tr><tr><td>19</td><td>欢乐斗地主</td><td>8262</td></tr><tr><td>20</td><td>灌篮高手 ↑1</td><td>6407</td></tr><tr><td>21</td><td>龙之谷2 ↓1</td><td>6392</td></tr><tr><td>22</td><td>剑与远征 ↑3</td><td>6231</td></tr><tr><td>23</td><td>饥荒 ↓1</td><td>5919</td></tr><tr><td>24</td><td>狼人杀 ↓1</td><td>5723</td></tr><tr><td>25</td><td>率土之滨 ↑5</td><td>5345</td></tr><tr><td>26</td><td>碧蓝航线 ↑3</td><td>4997</td></tr><tr><td>27</td><td>奇迹暖暖 ↑new</td><td>4823</td></tr><tr><td>28</td><td>火影忍者手游 ↓2</td><td>4661</td></tr><tr><td>29</td><td>大话西游 ↓5</td><td>4654</td></tr><tr><td>30</td><td>新神魔大陆 ↓3</td><td>4619</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月12日</title>
    <link href="/2020/07/13/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8812%E6%97%A5/"/>
    <url>/2020/07/13/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8812%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>83431</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>76544</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>29552</td></tr><tr><td>4</td><td>地下城与勇士+dnf ↑3</td><td>17665</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>16816</td></tr><tr><td>6</td><td>QQ飞车 ↓2</td><td>15014</td></tr><tr><td>7</td><td>坦克世界 ↓1</td><td>14173</td></tr><tr><td>8</td><td>梦幻西游 ↑1</td><td>13741</td></tr><tr><td>9</td><td>最终幻想14+ff14 ↑1</td><td>12676</td></tr><tr><td>10</td><td>csgo ↑2</td><td>11093</td></tr><tr><td>11</td><td>天龙八部 ↑3</td><td>10689</td></tr><tr><td>12</td><td>魔兽世界+wow ↑1</td><td>10469</td></tr><tr><td>13</td><td>龙之谷 ↓5</td><td>9753</td></tr><tr><td>14</td><td>炉石传说 ↑1</td><td>9712</td></tr><tr><td>15</td><td>方舟生存进化 ↑2</td><td>9390</td></tr><tr><td>16</td><td>刀塔2+DOTA2 ↓5</td><td>9228</td></tr><tr><td>17</td><td>冒险岛 ↓1</td><td>7810</td></tr><tr><td>18</td><td>变形金刚 ↑4</td><td>7270</td></tr><tr><td>19</td><td>守望先锋</td><td>7178</td></tr><tr><td>20</td><td>激战2 ↓2</td><td>6548</td></tr><tr><td>21</td><td>逆水寒</td><td>6334</td></tr><tr><td>22</td><td>星际战甲+warframe ↓2</td><td>6002</td></tr><tr><td>23</td><td>大话西游 ↑1</td><td>5895</td></tr><tr><td>24</td><td>天涯明月刀 ↑3</td><td>5751</td></tr><tr><td>25</td><td>诛仙 ↓2</td><td>5668</td></tr><tr><td>26</td><td>传奇</td><td>5323</td></tr><tr><td>27</td><td>龙族 ↑1</td><td>4743</td></tr><tr><td>28</td><td>战舰世界 ↓3</td><td>4619</td></tr><tr><td>29</td><td>EVE</td><td>4177</td></tr><tr><td>30</td><td>流放之路 ↑new</td><td>4121</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>117075</td></tr><tr><td>2</td><td>和平精英</td><td>79489</td></tr><tr><td>3</td><td>我的世界+mc</td><td>75847</td></tr><tr><td>4</td><td>迷你世界</td><td>75060</td></tr><tr><td>5</td><td>光遇</td><td>45838</td></tr><tr><td>6</td><td>香肠派对</td><td>39668</td></tr><tr><td>7</td><td>江南百景图</td><td>35238</td></tr><tr><td>8</td><td>第五人格</td><td>19314</td></tr><tr><td>9</td><td>最强蜗牛 ↑2</td><td>18019</td></tr><tr><td>10</td><td>荒野乱斗</td><td>16456</td></tr><tr><td>11</td><td>妖神记 ↑2</td><td>15036</td></tr><tr><td>12</td><td>球球大作战</td><td>14971</td></tr><tr><td>13</td><td>阴阳师 ↑2</td><td>12284</td></tr><tr><td>14</td><td>崩坏3 ↑2</td><td>11369</td></tr><tr><td>15</td><td>明日之后 ↑3</td><td>10781</td></tr><tr><td>16</td><td>部落冲突 ↑1</td><td>10499</td></tr><tr><td>17</td><td>QQ飞车手游 ↓8</td><td>10400</td></tr><tr><td>18</td><td>炉石传说 ↑1</td><td>9712</td></tr><tr><td>19</td><td>欢乐斗地主 ↑1</td><td>9239</td></tr><tr><td>20</td><td>龙之谷2 ↓6</td><td>9000</td></tr><tr><td>21</td><td>灌篮高手</td><td>7620</td></tr><tr><td>22</td><td>饥荒 ↑3</td><td>7049</td></tr><tr><td>23</td><td>狼人杀</td><td>6516</td></tr><tr><td>24</td><td>大话西游 ↑new</td><td>5895</td></tr><tr><td>25</td><td>剑与远征 ↑1</td><td>5693</td></tr><tr><td>26</td><td>火影忍者手游 ↓2</td><td>5528</td></tr><tr><td>27</td><td>新神魔大陆</td><td>5402</td></tr><tr><td>28</td><td>恋与制作人 ↓6</td><td>5274</td></tr><tr><td>29</td><td>碧蓝航线 ↓1</td><td>5151</td></tr><tr><td>30</td><td>率土之滨</td><td>4830</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目或者文件管理神器-Git</title>
    <link href="/2020/07/12/%E9%A1%B9%E7%9B%AE%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-Git/"/>
    <url>/2020/07/12/%E9%A1%B9%E7%9B%AE%E6%88%96%E8%80%85%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8-Git/</url>
    
    <content type="html"><![CDATA[<p>现在网上Git的教程以及介绍非常的多，我一直觉得一个东西首先要会用，然后有时间再去了解原理，所以本篇文章就讲讲怎么使用Git，完全不谈其原理<del>其实是我自己也没有研究过</del>。</p><h1 id="1-思维导图"><a href="#1-思维导图" class="headerlink" title="1. 思维导图"></a>1. 思维导图</h1><p><img src="/image/Git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.png" srcset="/img/loading.gif" alt="Git命令"></p><p><strong>注：标红的为常用命令。</strong></p><h1 id="2-Git是什么"><a href="#2-Git是什么" class="headerlink" title="2. Git是什么"></a>2. Git是什么</h1><blockquote><p>git是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools不同。 git最初的开发动力来自于BitKeeper和Monotone。</p></blockquote><h1 id="3-安装Git"><a href="#3-安装Git" class="headerlink" title="3. 安装Git"></a>3. 安装Git</h1><p>到<a href="https://git-scm.com/" target="_blank" rel="noopener">Git官网</a>直接下载并且安装。</p><p>打开Git的方式非常简单，在需要使用Git的文件夹中点击右键-<code>Git Bash Here</code>。</p><p><img src="/image/%E6%89%93%E5%BC%80Git.gif" srcset="/img/loading.gif" alt="打开Git"></p><h1 id="4-配置Git"><a href="#4-配置Git" class="headerlink" title="4. 配置Git"></a>4. 配置Git</h1><p>如果要使用Git首先需要进行配置用户名和邮箱，目的是清楚谁进行了提交。</p><h2 id="4-1-全局配置"><a href="#4-1-全局配置" class="headerlink" title="4.1 全局配置"></a>4.1 全局配置</h2><p>在个人电脑上首次使用<code>Git</code>需要进行配置，公共电脑慎用。</p><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">"[name]"</span> <span class="hljs-comment">#你的用户名</span>git config --global user.email <span class="hljs-string">"[email]"</span> <span class="hljs-comment">#你的邮箱</span></code></pre><h2 id="4-2-当前仓库配置"><a href="#4-2-当前仓库配置" class="headerlink" title="4.2 当前仓库配置"></a>4.2 当前仓库配置</h2><p>对当前仓库的用户名和邮箱进行配置，公共电脑推荐使用。</p><pre><code class="hljs bash">git config user.name <span class="hljs-string">"[name]"</span>git config user.email <span class="hljs-string">"[email]"</span></code></pre><h1 id="5-Git使用步骤"><a href="#5-Git使用步骤" class="headerlink" title="5. Git使用步骤"></a>5. Git使用步骤</h1><p>说了那么多，其实Git常用的命令就那么几个，其它的等用到的时候再去翻翻。</p><h2 id="5-1-初始化Git"><a href="#5-1-初始化Git" class="headerlink" title="5.1 初始化Git"></a>5.1 初始化Git</h2><pre><code class="hljs bash">git init</code></pre><h2 id="5-2-添加文件"><a href="#5-2-添加文件" class="headerlink" title="5.2 添加文件"></a>5.2 添加文件</h2><h3 id="5-2-1-添加单个文件"><a href="#5-2-1-添加单个文件" class="headerlink" title="5.2.1 添加单个文件"></a>5.2.1 添加单个文件</h3><pre><code class="hljs bash">git add 文件名</code></pre><p>仅添加单个文件到暂存区。</p><h3 id="5-2-2-添加所有文件"><a href="#5-2-2-添加所有文件" class="headerlink" title="5.2.2 添加所有文件"></a>5.2.2 添加所有文件</h3><pre><code class="hljs bash">git add .</code></pre><p><strong>常用，添加所有文件到暂存区。</strong></p><h2 id="5-3-提交到本地仓库"><a href="#5-3-提交到本地仓库" class="headerlink" title="5.3 提交到本地仓库"></a>5.3 提交到本地仓库</h2><pre><code class="hljs bash">git commit -m <span class="hljs-string">'版本信息'</span></code></pre><p>建议遵守<code>git commit</code>规范，当然如果仅仅自己使用的仓库就随意了。</p><p><a href="https://juejin.im/post/5afc5242f265da0b7f44bee4" target="_blank" rel="noopener">规范参考文章</a></p><h2 id="5-4-推送"><a href="#5-4-推送" class="headerlink" title="5.4 推送"></a>5.4 推送</h2><p>我们往往会将Git仓库推送到远程仓库，例如<code>GitHub</code>，目的是方便换电脑时也能同步自己的代码，如果是放在本地仓库，可能存在硬盘损坏或者其它不可预料的情况。</p><p>首次推送会弹出登陆框，然后需要登陆<code>GitHub</code>。</p><pre><code class="hljs bash">git push 远程库地址/远程库别名 分支名</code></pre><p>强制推送命令（慎用）：</p><pre><code class="hljs bash">git push -u origin master -f</code></pre><p><strong>该命令一般来讲千万不要用于多人维护的项目中，因为它会强制推送你当前的版本，可能会引起版本丢失等一系列的不可预料的损失。</strong></p><p>不过如果是你个人的项目，这条命令还是很好用的，主要是用于版本回退后远程仓库的版本比你现在的版本高，而导致无法进行推送到远程仓库时使用。</p><h2 id="5-5-总结"><a href="#5-5-总结" class="headerlink" title="5.5 总结"></a>5.5 总结</h2><p>最简单的<code>Git</code>使用其实就是下面的5个步骤。</p><pre><code class="hljs bash">git init <span class="hljs-comment">#初始化Git仓库</span>git add . <span class="hljs-comment">#添加所有文件到暂存区</span>git commit -m <span class="hljs-string">"first commit"</span> <span class="hljs-comment">#提交到本地仓库</span>git remote add origin 远程仓库地址  <span class="hljs-comment">#设置远程仓库别名</span>git push origin master <span class="hljs-comment">#推送到远程仓库</span></code></pre><p>上面这是在仓库初始化的时候，如果是第二次或者以后的提交只需要进行下面的步骤就可以了：</p><pre><code class="hljs bash">git add . <span class="hljs-comment">#添加所有文件到暂存区</span>git commit -m <span class="hljs-string">"first commit"</span> <span class="hljs-comment">#提交到本地仓库</span>git remote add origin 远程仓库地址  <span class="hljs-comment">#设置远程仓库别名</span>git push origin master <span class="hljs-comment">#推送到远程仓库</span></code></pre><h1 id="6-更多命令"><a href="#6-更多命令" class="headerlink" title="6. 更多命令"></a>6. 更多命令</h1><p>看完了上面的4个步骤，那么你就可以愉快的使用<code>Git</code>了，是不是非常的简单。当然，<code>Git</code>所包含的内容可远远不止这些，它还能实现更为复杂的功能。</p><h2 id="6-1-克隆项目"><a href="#6-1-克隆项目" class="headerlink" title="6.1 克隆项目"></a>6.1 克隆项目</h2><p>如果你将项目托管到了<code>GitHub</code>或者其它代码托管平台上，或者你需要拉取别人项目，那么可以直接通过：</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> 仓库地址</code></pre><p>以<code>GitHub</code>为例：</p><p><img src="/image/image-20200712204226893.png" srcset="/img/loading.gif" alt="image-20200712204226893"></p><p>然后输入：</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/vuejs/vue.git</code></pre><h2 id="6-2-拉取更新"><a href="#6-2-拉取更新" class="headerlink" title="6.2 拉取更新"></a>6.2 拉取更新</h2><p>如果远程仓库有更新，可以直接在项目中通过</p><pre><code class="hljs bash">git pull</code></pre><p>进行更新，比如说你在一台电脑上更新了远程仓库，在另一台电脑上你就可以通过<code>git pull</code>将代码进行同步。当然，必须要是更新已经推送到远程仓库的情况下，如果仅仅是提交到了本地仓库，那是没有效果的。</p><h2 id="6-3-版本回退"><a href="#6-3-版本回退" class="headerlink" title="6.3 版本回退"></a>6.3 版本回退</h2><p>试想一下，如果你做了一个表格，发送给你的上司，你的上司觉得你做的表格不太满意，让你进行修改，你修改后又发给你的上司，你的上司看了后觉得还是刚才未修改的好，这个时候你是否很抓狂？</p><p>为了解决这个问题，你可以在每次修改的时候都进行一次备份，但如果不止一次呢，是很多次修改。每次都进行备份嘛？这样后面找起来也很麻烦。</p><p>这个时候<code>Git</code>的强大就得以体现。</p><p>我们先创建一个文件夹，在里面随便创建一个<code>Excel</code>，弄一些简单的数据：</p><p><img src="/image/image-20200712201839402.png" srcset="/img/loading.gif" alt="image-20200712201839402"></p><p>假设这就是第一个版本。</p><p>然后我们根据上面的<code>Git</code>使用步骤，</p><p>先初始化<code>Git</code>：<code>git init</code>。</p><p>再添加文件到暂存区：<code>git add .</code>。</p><p>最后提交到仓库：<code>git commit -m &#39;第一版&#39;</code>。</p><p>到这里，你就可以打开<code>Excel</code>继续进行修改了~</p><p><img src="/image/image-20200712202349897.png" srcset="/img/loading.gif" alt="image-20200712202349897"></p><p>上面这个进行了一次修改，这个时候如果你的上司觉得之前的那个版本好，怎么办。</p><p>这个时候我们再次进行一下上面的命令：</p><p>添加文件到暂存区：<code>git add .</code>。</p><p>提交到仓库：<code>git commit -m &#39;第二版&#39;</code>。</p><p>那么我们应该如何回退到第一版呢？</p><p>首先运行<code>git log</code>。</p><p><img src="/image/image-20200712202838633.png" srcset="/img/loading.gif" alt="image-20200712202838633"></p><p>可以看到，红框圈起来的就是<code>hash</code>值，比如要回退到第一版，那么就输入下面的命令：</p><pre><code class="hljs bash">git reset --hard <span class="hljs-built_in">hash</span></code></pre><p><img src="/image/image-20200712202935938.png" srcset="/img/loading.gif" alt="image-20200712202935938"></p><p><strong><code>hash</code>值不一定要全部复制，复制一部分就可以了。</strong></p><p>然后按一下回车，再打开<code>Excel</code>看一下，数据已经回到了第一版了。</p><p>那么这个时候如果觉得第二版更好，怎么回到刚才的第二版呢？</p><p>输入：</p><pre><code class="hljs bash">git reflog</code></pre><p><img src="/image/image-20200712203241440.png" srcset="/img/loading.gif" alt="image-20200712203241440"></p><p>因为我的窗口是没有关闭的，所以之前的命令还在，我们这一步的主要目的是为了找到第二版的<code>hash</code>值，</p><p><strong>注意：该记录有时限，且仅仅在本地。</strong></p><p>然后再使用上面的命令：</p><pre><code class="hljs bash">git reset --hard <span class="hljs-built_in">hash</span></code></pre><p><img src="/image/image-20200712203507968.png" srcset="/img/loading.gif" alt="image-20200712203507968"></p><p>这个时候再打开<code>Excel</code>看一下，又回到了第二版。</p><h1 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h1><p>看到这里，<code>Git</code>基础的用法你已经全部学会了，至于分支、标签、多人协作等进阶的功能，由于篇幅限制，就不在这里讲解了。学会上面这些，对于一个非程序员来讲，已经完全够用了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月11日</title>
    <link href="/2020/07/12/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8811%E6%97%A5/"/>
    <url>/2020/07/12/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8811%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>89074</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>77488</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>35184</td></tr><tr><td>4</td><td>QQ飞车 ↑20</td><td>19523</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>16997</td></tr><tr><td>6</td><td>坦克世界 ↓2</td><td>15925</td></tr><tr><td>7</td><td>地下城与勇士+dnf ↑2</td><td>15385</td></tr><tr><td>8</td><td>龙之谷 ↑2</td><td>15314</td></tr><tr><td>9</td><td>梦幻西游 ↓3</td><td>13315</td></tr><tr><td>10</td><td>最终幻想14+ff14 ↓3</td><td>13024</td></tr><tr><td>11</td><td>刀塔2+DOTA2</td><td>12538</td></tr><tr><td>12</td><td>csgo ↑1</td><td>11253</td></tr><tr><td>13</td><td>魔兽世界+wow ↓5</td><td>11032</td></tr><tr><td>14</td><td>天龙八部 ↑1</td><td>10664</td></tr><tr><td>15</td><td>炉石传说 ↓3</td><td>10399</td></tr><tr><td>16</td><td>冒险岛 ↑1</td><td>9397</td></tr><tr><td>17</td><td>方舟生存进化 ↓1</td><td>9276</td></tr><tr><td>18</td><td>激战2 ↓4</td><td>7715</td></tr><tr><td>19</td><td>守望先锋 ↓1</td><td>7375</td></tr><tr><td>20</td><td>星际战甲+warframe ↓1</td><td>7334</td></tr><tr><td>21</td><td>逆水寒</td><td>6648</td></tr><tr><td>22</td><td>变形金刚</td><td>6513</td></tr><tr><td>23</td><td>诛仙</td><td>5445</td></tr><tr><td>24</td><td>大话西游 ↑2</td><td>5064</td></tr><tr><td>25</td><td>战舰世界 ↓5</td><td>5007</td></tr><tr><td>26</td><td>传奇 ↓1</td><td>4996</td></tr><tr><td>27</td><td>天涯明月刀 ↑2</td><td>4564</td></tr><tr><td>28</td><td>龙族</td><td>4540</td></tr><tr><td>29</td><td>EVE ↓2</td><td>4412</td></tr><tr><td>30</td><td>逆战 ↑new</td><td>4200</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>129035</td></tr><tr><td>2</td><td>和平精英</td><td>80490</td></tr><tr><td>3</td><td>我的世界+mc</td><td>76832</td></tr><tr><td>4</td><td>迷你世界</td><td>76070</td></tr><tr><td>5</td><td>光遇</td><td>48813</td></tr><tr><td>6</td><td>香肠派对 ↑2</td><td>42701</td></tr><tr><td>7</td><td>江南百景图</td><td>32329</td></tr><tr><td>8</td><td>第五人格 ↑1</td><td>19739</td></tr><tr><td>9</td><td>QQ飞车手游 ↑new</td><td>18669</td></tr><tr><td>10</td><td>荒野乱斗 ↑2</td><td>17894</td></tr><tr><td>11</td><td>最强蜗牛 ↓1</td><td>16934</td></tr><tr><td>12</td><td>球球大作战 ↑2</td><td>14914</td></tr><tr><td>13</td><td>妖神记 ↑2</td><td>13587</td></tr><tr><td>14</td><td>龙之谷2 ↓8</td><td>12918</td></tr><tr><td>15</td><td>阴阳师 ↓2</td><td>12394</td></tr><tr><td>16</td><td>崩坏3 ↓5</td><td>12207</td></tr><tr><td>17</td><td>部落冲突 ↑1</td><td>11380</td></tr><tr><td>18</td><td>明日之后 ↑1</td><td>10915</td></tr><tr><td>19</td><td>炉石传说 ↓2</td><td>10399</td></tr><tr><td>20</td><td>欢乐斗地主</td><td>8944</td></tr><tr><td>21</td><td>灌篮高手</td><td>7459</td></tr><tr><td>22</td><td>恋与制作人 ↑new</td><td>7379</td></tr><tr><td>23</td><td>狼人杀</td><td>7016</td></tr><tr><td>24</td><td>火影忍者手游 ↓8</td><td>6400</td></tr><tr><td>25</td><td>饥荒 ↓1</td><td>6012</td></tr><tr><td>26</td><td>剑与远征 ↓4</td><td>5666</td></tr><tr><td>27</td><td>新神魔大陆 ↓1</td><td>5468</td></tr><tr><td>28</td><td>碧蓝航线 ↓3</td><td>5187</td></tr><tr><td>29</td><td>圣斗士星矢 ↑new</td><td>5174</td></tr><tr><td>30</td><td>率土之滨 ↓3</td><td>5073</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客快速搭建方案-VuePress</title>
    <link href="/2020/07/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E6%96%B9%E6%A1%88-VuePress/"/>
    <url>/2020/07/11/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E6%96%B9%E6%A1%88-VuePress/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>之前在<code>EJS</code>的文章中就提到过<code>VuePress</code>，特色是可以在<code>Markdown</code>中使用<code>Vue</code>组件，又可以使用<code>Vue</code>来开发自定义主题，对于一个前端玩家来说，<code>Vue</code>在当下可是必备的技能，所以使用<code>Vue</code>搭建博客也是一个非常常见的需求。</p><h2 id="1-1-如何工作"><a href="#1-1-如何工作" class="headerlink" title="1.1 如何工作"></a>1.1 如何工作</h2><p>一个 <code>VuePress</code> 网站是一个由 <code>Vue</code>、<code>Vue Router</code> 和 <code>webpack</code> 驱动的单页应用。</p><p>在构建时，我们会为应用创建一个服务端渲染（SSR）的版本，然后通过虚拟访问每一条路径来渲染对应的<code>HTML</code>。</p><p>关于服务端渲染（SSR）我在<a href="/2020/06/22/web%E5%BC%80%E5%8F%91/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%EF%BC%9ANuxt.js/" title="Vue服务器渲染优秀项目：Nuxt.js">Vue服务器渲染优秀项目：Nuxt.js</a>这篇文章中有详细的提到<code>Vue</code>项目如何实现<code>SSR</code>以及为什么要使用<code>SSR</code>。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h1><ol><li><p>创建并进入一个新目录</p><pre><code class="hljs bash">mkdir vuepress-starter &amp;&amp; <span class="hljs-built_in">cd</span> vuepress-starter</code></pre></li><li><p>使用你喜欢的包管理器进行初始化，运行下面的命令后会出现一些选项，<strong>通常一路回车过去就可以。</strong></p><pre><code class="hljs bash">npm init<span class="hljs-comment"># 如果使用了yarn就使用下面的命令</span>yarn init</code></pre></li><li><p>将 <code>VuePress</code> 安装为本地依赖</p><pre><code class="hljs bash">npm install -D vuepress<span class="hljs-comment"># 如果使用了yarn就使用下面的命令</span>yarn add -D vuepress</code></pre></li><li><p>创建你的第一篇文档</p><pre><code class="hljs bash">mkdir docs &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">'# Hello VuePress'</span> &gt; docs/README.md</code></pre></li><li><p>在 <code>package.json</code> 中添加一些 scripts。</p><p><strong>注意：如果没有进行添加，下面的一些命令将无法使用，比如<code>npm run docs:dev</code>。</strong></p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"scripts"</span>: &#123;    <span class="hljs-attr">"docs:dev"</span>: <span class="hljs-string">"vuepress dev docs"</span>,    <span class="hljs-attr">"docs:build"</span>: <span class="hljs-string">"vuepress build docs"</span>  &#125;&#125;</code></pre></li><li><p>在本地启动服务器</p><pre><code class="hljs bash">npm run docs:dev<span class="hljs-comment"># 如果使用了yarn就使用下面的命令</span>yarn docs:dev</code></pre></li></ol><p>最后访问<code>locolhost:8080</code>就可以看到已经部署完毕的博客界面了，然后就可以看到这个界面：</p><p><img src="/image/image-20200711143752811.png" srcset="/img/loading.gif" alt="image-20200711143752811"></p><p>是不是非常的简陋，如果要使你的博客看上去更丰富，那么就接着往下看。</p><h1 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3. 目录结构"></a>3. 目录结构</h1><p>根据官方文档的说明，<strong>推荐使用以下目录结构，尽量不要自行胡乱创建目录结构。</strong></p><pre><code class="hljs css">.├── <span class="hljs-selector-tag">docs</span>│   ├── <span class="hljs-selector-class">.vuepress</span> (可选的)│   │   ├── <span class="hljs-selector-tag">components</span> (可选的)│   │   ├── <span class="hljs-selector-tag">theme</span> (可选的)│   │   │   └── <span class="hljs-selector-tag">Layout</span><span class="hljs-selector-class">.vue</span>│   │   ├── <span class="hljs-selector-tag">public</span> (可选的)│   │   ├── <span class="hljs-selector-tag">styles</span> (可选的)│   │   │   ├── <span class="hljs-selector-tag">index</span><span class="hljs-selector-class">.styl</span>│   │   │   └── <span class="hljs-selector-tag">palette</span><span class="hljs-selector-class">.styl</span>│   │   ├── <span class="hljs-selector-tag">templates</span> (可选的, 谨慎配置)│   │   │   ├── <span class="hljs-selector-tag">dev</span><span class="hljs-selector-class">.html</span>│   │   │   └── <span class="hljs-selector-tag">ssr</span><span class="hljs-selector-class">.html</span>│   │   ├── <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.js</span> (可选的)│   │   └── <span class="hljs-selector-tag">enhanceApp</span><span class="hljs-selector-class">.js</span> (可选的)│   │ │   ├── <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>│   ├── <span class="hljs-selector-tag">guide</span>│   │   └── <span class="hljs-selector-tag">README</span><span class="hljs-selector-class">.md</span>│   └── <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.md</span>│ └── <span class="hljs-selector-tag">package</span><span class="hljs-selector-class">.json</span></code></pre><p><strong>注意：请留意目录名的大写。</strong></p><ul><li><code>docs/.vuepress</code>: 用于存放全局的配置、组件、静态资源等。</li><li><code>docs/.vuepress/components</code>: 该目录中的 Vue 组件将会被自动注册为全局组件。</li><li><code>docs/.vuepress/theme</code>: 用于存放本地主题。</li><li><code>docs/.vuepress/styles</code>: 用于存放样式相关的文件。</li><li><code>docs/.vuepress/styles/index.styl</code>: 将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级。</li><li><code>docs/.vuepress/styles/palette.styl</code>: 用于重写默认颜色常量，或者设置新的 stylus 颜色常量。</li><li><code>docs/.vuepress/public</code>: 静态资源目录。</li><li><code>docs/.vuepress/templates</code>: 存储 HTML 模板文件。</li><li><code>docs/.vuepress/templates/dev.html</code>: 用于开发环境的 HTML 模板文件。</li><li><code>docs/.vuepress/templates/ssr.html</code>: 构建时基于 Vue SSR 的 HTML 模板文件。</li><li><code>docs/.vuepress/config.js</code>: 配置文件的入口文件，也可以是 <code>YML</code> 或 <code>toml</code>。</li><li><code>docs/.vuepress/enhanceApp.js</code>: 客户端应用的增强。</li></ul><h2 id="3-1-路由"><a href="#3-1-路由" class="headerlink" title="3.1 路由"></a>3.1 路由</h2><p>所有的“文件的相对路径”都是相对于 <code>docs</code> 目录的，也就是<code>docs</code>目录就是根目录。</p><table><thead><tr><th>文件的相对路径</th><th>页面路由地址</th></tr></thead><tbody><tr><td><code>/README.md</code></td><td><code>/</code></td></tr><tr><td><code>/guide/README.md</code></td><td><code>/guide/</code></td></tr><tr><td><code>/config.md</code></td><td><code>/config.html</code></td></tr></tbody></table><h2 id="3-2-创建-vuepress"><a href="#3-2-创建-vuepress" class="headerlink" title="3.2 创建.vuepress"></a>3.2 创建<code>.vuepress</code></h2><p>根据上面的目录结构，我们需要在<code>docs</code>文件夹下创建一个<code>.vuepress</code>文件夹，好用来存放 <code>VuePress</code> 相关的文件。</p><p>然后在<code>.vuepress</code>文件夹下创建一个<code>config.js</code>文件，用来存放<code>vuepress</code>相关的配置，基础内容如下：</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  title: <span class="hljs-string">'Hello VuePress'</span>,  description: <span class="hljs-string">'Just playing around'</span>&#125;</code></pre><p>重新运行一下项目后，你就会看到页面上多出了一个标题。</p><p><img src="/image/image-20200711144433535.png" srcset="/img/loading.gif" alt="image-20200711144433535"></p><p>但是这样看起来还是很简陋，不用担心，<code>VuePress</code> 可以默认主题也可以使用人家已经发布的主题。</p><h2 id="3-3-创建public文件夹"><a href="#3-3-创建public文件夹" class="headerlink" title="3.3 创建public文件夹"></a>3.3 创建<code>public</code>文件夹</h2><p>在写作的过程中或者搭建界面的过程中经常会使用到一些图片或者其它的静态资源，这些静态资源都统一存放在<code>public</code>文件夹下面，例如：</p><p><img src="/image/image-20200711151142211.png" srcset="/img/loading.gif" alt="image-20200711151142211"></p><p>下面这张<code>hero.png</code>的图片，就可以通过<code>localhost:8080/hero.png</code>进行访问。</p><h1 id="4-默认主题配置"><a href="#4-默认主题配置" class="headerlink" title="4. 默认主题配置"></a>4. 默认主题配置</h1><h2 id="4-1-首页配置"><a href="#4-1-首页配置" class="headerlink" title="4.1 首页配置"></a>4.1 首页配置</h2><p>使用默认主题配置首页需要在根级<code>README.md</code>的<code>YAML front matter</code>指定<code>home: true</code>。如下所示：</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">home:</span> <span class="hljs-literal">true</span><span class="hljs-attr">heroImage:</span> <span class="hljs-string">/hero.png</span> <span class="hljs-comment"># 需要在public文件夹下存放该文件名的图片，否则不显示图片</span><span class="hljs-attr">heroText:</span> <span class="hljs-string">Hero</span> <span class="hljs-string">标题</span> <span class="hljs-comment"># 如果不需要可以设置为mull</span><span class="hljs-attr">tagline:</span> <span class="hljs-string">Hero</span> <span class="hljs-string">副标题</span> <span class="hljs-comment"># 如果不需要可以设置为mull</span><span class="hljs-attr">actionText:</span> <span class="hljs-string">快速上手</span> <span class="hljs-string">→</span><span class="hljs-attr">actionLink:</span> <span class="hljs-string">/zh/guide/</span><span class="hljs-attr">features:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">title:</span> <span class="hljs-string">简洁至上</span>  <span class="hljs-attr">details:</span> <span class="hljs-string">以</span> <span class="hljs-string">Markdown</span> <span class="hljs-string">为中心的项目结构，以最少的配置帮助你专注于写作。</span><span class="hljs-bullet">-</span> <span class="hljs-attr">title:</span> <span class="hljs-string">Vue驱动</span>  <span class="hljs-attr">details:</span> <span class="hljs-string">享受</span> <span class="hljs-string">Vue</span> <span class="hljs-string">+</span> <span class="hljs-string">webpack</span> <span class="hljs-string">的开发体验，在</span> <span class="hljs-string">Markdown</span> <span class="hljs-string">中使用</span> <span class="hljs-string">Vue</span> <span class="hljs-string">组件，同时可以使用</span> <span class="hljs-string">Vue</span> <span class="hljs-string">来开发自定义主题。</span><span class="hljs-bullet">-</span> <span class="hljs-attr">title:</span> <span class="hljs-string">高性能</span>  <span class="hljs-attr">details:</span> <span class="hljs-string">VuePress</span> <span class="hljs-string">为每个页面预渲染生成静态的</span> <span class="hljs-string">HTML，同时在页面被加载的时候，将作为</span> <span class="hljs-string">SPA</span> <span class="hljs-string">运行。</span><span class="hljs-attr">footer:</span> <span class="hljs-string">MIT</span> <span class="hljs-string">Licensed</span> <span class="hljs-string">|</span> <span class="hljs-string">Copyright</span> <span class="hljs-string">©</span> <span class="hljs-number">2018</span><span class="hljs-string">-present</span> <span class="hljs-string">Evan</span> <span class="hljs-string">You</span><span class="hljs-meta">---</span></code></pre><p>重新运行一下项目，可以看到下面的效果：</p><p><img src="/image/image-20200711151425246.png" srcset="/img/loading.gif" alt="image-20200711151425246"></p><p>这样看上去，是不是就有博客的样子了。</p><h2 id="4-2-导航栏"><a href="#4-2-导航栏" class="headerlink" title="4.2 导航栏"></a>4.2 导航栏</h2><p>导航栏的配置包括下面的几项，可以根据自己的需要进行配置，配置文件在<code>.vuepress/config.js</code>。</p><ul><li>页面标题</li><li>搜索框</li><li>导航栏链接</li><li>多语言切换</li><li>仓库链接</li></ul><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  themeConfig: &#123;    <span class="hljs-comment">// navbar: false, // 禁用导航栏</span>    logo: <span class="hljs-string">'/assets/img/logo.png'</span>, <span class="hljs-comment">// 配置导航Log</span>    nav: [ <span class="hljs-comment">//配置导航链接</span>      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'Home'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/'</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'Guide'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/guide/'</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'External'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'https://google.com'</span>&#125;,      <span class="hljs-comment">/* 外部链接可以配置target和rel */</span>      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'External'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'https://google.com'</span>, <span class="hljs-attr">target</span>: <span class="hljs-string">'_self'</span>, <span class="hljs-attr">rel</span>: <span class="hljs-string">''</span>&#125;,      &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'Guide'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/guide/'</span>, <span class="hljs-attr">target</span>: <span class="hljs-string">'_blank'</span>&#125;,      &#123;        text: <span class="hljs-string">'Languages'</span>,        ariaLabel: <span class="hljs-string">'Language Menu'</span>,        items: [ <span class="hljs-comment">// 如果提供了一个items，会用下拉框的形式显示</span>          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'Chinese'</span>, <span class="hljs-attr">link</span>: <span class="hljs-string">'/language/chinese/'</span>&#125;,          &#123;<span class="hljs-attr">text</span>: <span class="hljs-string">'Japanese'</span>, <span class="hljs-attr">items</span>: [<span class="hljs-comment">/*  */</span>]&#125; <span class="hljs-comment">//还可以进行嵌套items</span>        ]      &#125;    ]  &#125;&#125;;</code></pre><p>重新运行一下看效果：</p><p><img src="/image/image-20200711152834391.png" srcset="/img/loading.gif" alt="image-20200711152834391"></p><h2 id="4-3-侧边栏"><a href="#4-3-侧边栏" class="headerlink" title="4.3 侧边栏"></a>4.3 侧边栏</h2><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  themeConfig: &#123;    sidebar: <span class="hljs-string">'auto'</span> <span class="hljs-comment">// 自动生成侧边栏</span>  &#125;&#125;;</code></pre><p><img src="/image/image-20200711155130504.png" srcset="/img/loading.gif" alt="image-20200711155130504"></p><p>但是在这里我发现了一个问题，一篇文章中只能存在一个<strong>一级标题</strong>，因为自动生成的侧边栏貌似只会生成一个一级标题。</p><p>侧边栏的更多配置可以参考<a href="https://vuepress.vuejs.org/zh/theme/default-theme-config.html#%E4%BE%A7%E8%BE%B9%E6%A0%8F" target="_blank" rel="noopener">官方文档</a>，如果有需要的话根据文档进行配置。</p><h1 id="5-在Markdown中使用Vue"><a href="#5-在Markdown中使用Vue" class="headerlink" title="5. 在Markdown中使用Vue"></a>5. 在Markdown中使用Vue</h1><p>为什么要使用<code>VuePress</code>创建博客呢，因为它可以在<code>Markdown</code>中使用<code>Vue</code>，这就极大的提高了界面的自定义，但是它有着浏览器<code>API</code>访问限制，因为所有的页面在生成静态 HTML 时都需要通过<code>Node.js</code>服务端渲染，所以请确保只在<code>beforeMount</code>或者<code>mounted</code>访问<code>浏览器 / DOM</code> 的 <code>API</code>。</p><h2 id="5-1-插值"><a href="#5-1-插值" class="headerlink" title="5.1 插值"></a>5.1 插值</h2><p>每一个 <code>Markdown</code> 文件将首先被编译成 <code>HTML</code>，接着作为一个 <code>Vue</code> 组件传入 <code>vue-loader</code>，这意味着你可以在文本中使用 Vue 风格的插值：</p><p><strong>Input</strong></p><pre><code class="hljs md">&#123;&#123; 1 + 1 &#125;&#125;</code></pre><p><strong>Output</strong></p><pre><code class="hljs angelscript"><span class="hljs-number">2</span></code></pre><h2 id="5-2-指令"><a href="#5-2-指令" class="headerlink" title="5.2 指令"></a>5.2 指令</h2><p>同样地，也可以使用指令:</p><p><strong>Input</strong></p><pre><code class="hljs md"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"i in 3"</span>&gt;</span></span>&#123;&#123; i &#125;&#125; <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span></code></pre><p><strong>Output</strong></p><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span></code></pre><h2 id="5-3-访问网站以及页面的数据"><a href="#5-3-访问网站以及页面的数据" class="headerlink" title="5.3 访问网站以及页面的数据"></a>5.3 访问网站以及页面的数据</h2><p>编译后的组件没有私有数据，但可以访问 <a href="https://vuepress.vuejs.org/zh/theme/writing-a-theme.html#网站和页面的元数据" target="_blank" rel="noopener">网站的元数据</a>，举例来说：</p><p><strong>Input</strong></p><pre><code class="hljs md">&#123;&#123; $page &#125;&#125;</code></pre><p><strong>Output</strong></p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"path"</span>: <span class="hljs-string">"/using-vue.html"</span>,  <span class="hljs-attr">"title"</span>: <span class="hljs-string">"Using Vue in Markdown"</span>,  <span class="hljs-attr">"frontmatter"</span>: &#123;&#125;&#125;</code></pre><h2 id="5-4-转义"><a href="#5-4-转义" class="headerlink" title="5.4 转义"></a>5.4 转义</h2><p>默认情况下，块级 (block) 的代码块将会被自动包裹在 <code>v-pre</code> 中。如果你想要在内联 (inline) 的代码块或者普通文本中显示原始的大括号，或者一些 Vue 特定的语法，你需要使用自定义容器 <code>v-pre</code> 来包裹：</p><p><strong>Input</strong></p><pre><code class="hljs md">::: v-pre<span class="hljs-code">`&#123;&#123; This will be displayed as-is &#125;&#125;`</span>:::</code></pre><p><strong>Output</strong></p><pre><code class="hljs mizar">&#123;&#123; This will <span class="hljs-keyword">be</span> displayed <span class="hljs-keyword">as</span>-<span class="hljs-keyword">is</span> &#125;&#125;</code></pre><h2 id="5-5-使用组件"><a href="#5-5-使用组件" class="headerlink" title="5.5 使用组件"></a>5.5 使用组件</h2><p>所有在 <code>.vuepress/components</code> 中找到的 <code>*.vue</code> 文件将会自动地被注册为全局的异步组件。</p><p>你可以直接使用这些组件在任意的 Markdown 文件中（组件名是通过文件名取到的）：</p><pre><code class="hljs md"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">demo-1</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">OtherComponent</span>/&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Foo-Bar</span>/&gt;</span></span></code></pre><h2 id="5-6-使用预处理器"><a href="#5-6-使用预处理器" class="headerlink" title="5.6 使用预处理器"></a>5.6 使用预处理器</h2><p>vue中已经内置了 <code>stylus</code> 和 <code>stylus-loader</code>，所以不需要再安装它们，而<code>sass</code>、<code>scss</code>、<code>less</code>、<code>stylus</code> 和 <code>pug</code>。要使用它们你只需要在项目中安装对应的依赖即可。例如，要使用 <code>sass</code>，需要安装：</p><pre><code class="hljs bash">yarn add -D sass-loader node-sass</code></pre><p>然后你就可以在 Markdown 或是组件中使用如下代码：</p><pre><code class="hljs vue">&lt;style lang&#x3D;&quot;sass&quot;&gt;  .title    font-size: 20px&lt;&#x2F;style&gt;</code></pre><p>要在组件中使用 <code>&lt;template lang=&quot;pug&quot;&gt;</code>，则需要安装 <code>pug</code> 和 <code>pug-plain-loader</code>:</p><pre><code class="hljs bash">yarn add -D pug pug-plain-loader</code></pre><h1 id="6-其它配置"><a href="#6-其它配置" class="headerlink" title="6. 其它配置"></a>6. 其它配置</h1><h2 id="6-1-内部链接"><a href="#6-1-内部链接" class="headerlink" title="6.1 内部链接"></a>6.1 内部链接</h2><p>网站内部的链接，将会被转换成 <code>&lt;router-link&gt;</code> 用于 SPA 导航。同时，站内的每一个文件夹下的 <code>README.md</code> 或者 <code>index.md</code> 文件都会被自动编译为 <code>index.html</code>，对应的链接将被视为 <code>/</code>。</p><p>以如下的文件结构为例：</p><pre><code class="hljs text">.├─ README.md├─ foo│  ├─ README.md│  ├─ one.md│  └─ two.md└─ bar   ├─ README.md   ├─ three.md   └─ four.md</code></pre><p>假设你现在在 <code>foo/one.md</code> 中：</p><pre><code class="hljs md">[<span class="hljs-string">Home</span>](<span class="hljs-link">/</span>) <span class="xml"><span class="hljs-comment">&lt;!-- 跳转到根部的 README.md --&gt;</span></span>[<span class="hljs-string">foo</span>](<span class="hljs-link">/foo/</span>) <span class="xml"><span class="hljs-comment">&lt;!-- 跳转到 foo 文件夹的 index.html --&gt;</span></span>[<span class="hljs-string">foo heading</span>](<span class="hljs-link">./#heading</span>) <span class="xml"><span class="hljs-comment">&lt;!-- 跳转到 foo/index.html 的特定标题位置 --&gt;</span></span>[<span class="hljs-string">bar - three</span>](<span class="hljs-link">../bar/three.md</span>) <span class="xml"><span class="hljs-comment">&lt;!-- 具体文件可以使用 .md 结尾（推荐） --&gt;</span></span>[<span class="hljs-string">bar - four</span>](<span class="hljs-link">../bar/four.html</span>) <span class="xml"><span class="hljs-comment">&lt;!-- 也可以用 .html --&gt;</span></span></code></pre><h2 id="6-2-Emoji"><a href="#6-2-Emoji" class="headerlink" title="6.2 Emoji"></a>6.2 Emoji</h2><p><strong>输入</strong></p><pre><code class="hljs text">:tada: :100:</code></pre><p><strong>输出</strong></p><p>🎉 💯</p><p><a href="https://github.com/markdown-it/markdown-it-emoji/blob/master/lib/data/full.json" target="_blank" rel="noopener">所有可用的Emoji</a>。</p><h2 id="6-3-行号"><a href="#6-3-行号" class="headerlink" title="6.3 行号"></a>6.3 行号</h2><p>可以通过配置来为每个代码块显示行号：</p><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  markdown: &#123;    lineNumbers: <span class="hljs-literal">true</span>  &#125;&#125;</code></pre><h1 id="7-部署"><a href="#7-部署" class="headerlink" title="7. 部署"></a>7. 部署</h1><p>项目的部署是十分简单的，直接运行</p><pre><code class="hljs bash">npm run docs:build</code></pre><p>进入到<code>docs\.vuepress\dist</code>就可以看到打包后的静态文件，你可以将它们发布到<code>GitHub Pages</code>或者你自己的服务器上面。</p><h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p><code>VuePress</code>和<code>Hexo</code>各有各的优点，因为<code>Hexo</code>出来的时间很久了所以技术上也相对成熟，主题也相对较多，但是缺点是使用了<code>EJS</code>，虽然让使用者更加方便，但是对于<code>DIY</code>来讲要额外进行学习。</p><p><code>VuePress</code>就可以直接使用<code>Vue</code>这个前端几乎必修的框架，<code>DIY</code>就显得非常方便，但是因为出来的时间短，主题也相对较少。所以如果对于不了解前端技术的同学，还是推荐使用<code>Hexo</code>。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>开源项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月10日</title>
    <link href="/2020/07/11/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8810%E6%97%A5/"/>
    <url>/2020/07/11/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8810%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>89242</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>61329</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>25480</td></tr><tr><td>4</td><td>坦克世界 ↑8</td><td>21012</td></tr><tr><td>5</td><td>绝地求生+pubg ↑1</td><td>15042</td></tr><tr><td>6</td><td>梦幻西游 ↑1</td><td>14403</td></tr><tr><td>7</td><td>最终幻想14+ff14 ↑3</td><td>13914</td></tr><tr><td>8</td><td>魔兽世界+wow</td><td>13843</td></tr><tr><td>9</td><td>地下城与勇士+dnf ↓5</td><td>13553</td></tr><tr><td>10</td><td>龙之谷 ↓5</td><td>13016</td></tr><tr><td>11</td><td>刀塔2+DOTA2 ↓2</td><td>12899</td></tr><tr><td>12</td><td>炉石传说 ↑3</td><td>11710</td></tr><tr><td>13</td><td>csgo ↓2</td><td>11569</td></tr><tr><td>14</td><td>激战2 ↑2</td><td>10902</td></tr><tr><td>15</td><td>天龙八部 ↓1</td><td>10216</td></tr><tr><td>16</td><td>方舟生存进化 ↑1</td><td>7544</td></tr><tr><td>17</td><td>冒险岛 ↓4</td><td>7449</td></tr><tr><td>18</td><td>守望先锋</td><td>6632</td></tr><tr><td>19</td><td>星际战甲+warframe ↑1</td><td>6413</td></tr><tr><td>20</td><td>战舰世界 ↑new</td><td>6143</td></tr><tr><td>21</td><td>逆水寒 ↓2</td><td>5960</td></tr><tr><td>22</td><td>变形金刚</td><td>5413</td></tr><tr><td>23</td><td>诛仙 ↓2</td><td>5410</td></tr><tr><td>24</td><td>QQ飞车 ↓1</td><td>5268</td></tr><tr><td>25</td><td>传奇 ↑4</td><td>5009</td></tr><tr><td>26</td><td>大话西游 ↑2</td><td>5002</td></tr><tr><td>27</td><td>EVE ↓3</td><td>4717</td></tr><tr><td>28</td><td>龙族 ↓3</td><td>4474</td></tr><tr><td>29</td><td>天涯明月刀 ↓3</td><td>4103</td></tr><tr><td>30</td><td>流放之路</td><td>4017</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>125002</td></tr><tr><td>2</td><td>和平精英 ↑2</td><td>71500</td></tr><tr><td>3</td><td>我的世界+mc ↑2</td><td>61135</td></tr><tr><td>4</td><td>迷你世界 ↑2</td><td>59150</td></tr><tr><td>5</td><td>光遇 ↓3</td><td>58513</td></tr><tr><td>6</td><td>龙之谷2 ↓3</td><td>44546</td></tr><tr><td>7</td><td>江南百景图</td><td>33892</td></tr><tr><td>8</td><td>香肠派对</td><td>31858</td></tr><tr><td>9</td><td>第五人格 ↑3</td><td>17242</td></tr><tr><td>10</td><td>最强蜗牛</td><td>17182</td></tr><tr><td>11</td><td>崩坏3 ↓2</td><td>17033</td></tr><tr><td>12</td><td>荒野乱斗 ↓1</td><td>16883</td></tr><tr><td>13</td><td>阴阳师 ↑1</td><td>12555</td></tr><tr><td>14</td><td>球球大作战 ↑1</td><td>12301</td></tr><tr><td>15</td><td>妖神记 ↓2</td><td>12216</td></tr><tr><td>16</td><td>火影忍者手游</td><td>11726</td></tr><tr><td>17</td><td>炉石传说</td><td>11710</td></tr><tr><td>18</td><td>部落冲突 ↑1</td><td>9473</td></tr><tr><td>19</td><td>明日之后 ↓1</td><td>9446</td></tr><tr><td>20</td><td>欢乐斗地主</td><td>8116</td></tr><tr><td>21</td><td>灌篮高手 ↑3</td><td>6420</td></tr><tr><td>22</td><td>剑与远征 ↑1</td><td>6179</td></tr><tr><td>23</td><td>狼人杀 ↑3</td><td>6108</td></tr><tr><td>24</td><td>饥荒 ↑1</td><td>5696</td></tr><tr><td>25</td><td>碧蓝航线 ↓4</td><td>5548</td></tr><tr><td>26</td><td>新神魔大陆 ↓4</td><td>5526</td></tr><tr><td>27</td><td>率土之滨</td><td>5166</td></tr><tr><td>28</td><td>梦幻西游手游 ↑2</td><td>5075</td></tr><tr><td>29</td><td>大话西游 ↓1</td><td>5002</td></tr><tr><td>30</td><td>开心消消乐 ↓1</td><td>4192</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月09日</title>
    <link href="/2020/07/10/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8809%E6%97%A5/"/>
    <url>/2020/07/10/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8809%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>105550</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>58346</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>25245</td></tr><tr><td>4</td><td>地下城与勇士+dnf</td><td>23593</td></tr><tr><td>5</td><td>龙之谷 ↑9</td><td>22766</td></tr><tr><td>6</td><td>绝地求生+pubg ↓1</td><td>16104</td></tr><tr><td>7</td><td>梦幻西游 ↓1</td><td>13090</td></tr><tr><td>8</td><td>魔兽世界+wow ↑3</td><td>12602</td></tr><tr><td>9</td><td>刀塔2+DOTA2 ↓1</td><td>12163</td></tr><tr><td>10</td><td>最终幻想14+ff14 ↓3</td><td>12149</td></tr><tr><td>11</td><td>csgo ↑1</td><td>12144</td></tr><tr><td>12</td><td>坦克世界 ↓3</td><td>11832</td></tr><tr><td>13</td><td>冒险岛 ↑2</td><td>11599</td></tr><tr><td>14</td><td>天龙八部 ↓4</td><td>10807</td></tr><tr><td>15</td><td>炉石传说 ↓2</td><td>10212</td></tr><tr><td>16</td><td>激战2 ↑1</td><td>8620</td></tr><tr><td>17</td><td>方舟生存进化 ↓1</td><td>7713</td></tr><tr><td>18</td><td>守望先锋</td><td>7154</td></tr><tr><td>19</td><td>逆水寒</td><td>6917</td></tr><tr><td>20</td><td>星际战甲+warframe ↑3</td><td>6019</td></tr><tr><td>21</td><td>诛仙</td><td>5750</td></tr><tr><td>22</td><td>变形金刚</td><td>5174</td></tr><tr><td>23</td><td>QQ飞车 ↓3</td><td>5141</td></tr><tr><td>24</td><td>EVE</td><td>4938</td></tr><tr><td>25</td><td>龙族</td><td>4821</td></tr><tr><td>26</td><td>天涯明月刀 ↑4</td><td>4791</td></tr><tr><td>27</td><td>剑灵</td><td>4771</td></tr><tr><td>28</td><td>大话西游 ↓2</td><td>4509</td></tr><tr><td>29</td><td>传奇 ↓1</td><td>4508</td></tr><tr><td>30</td><td>流放之路 ↓1</td><td>4463</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>241443</td></tr><tr><td>2</td><td>光遇 ↑3</td><td>106982</td></tr><tr><td>3</td><td>龙之谷2 ↑5</td><td>73296</td></tr><tr><td>4</td><td>和平精英 ↓2</td><td>66469</td></tr><tr><td>5</td><td>我的世界+mc ↓2</td><td>58230</td></tr><tr><td>6</td><td>迷你世界 ↓2</td><td>54620</td></tr><tr><td>7</td><td>江南百景图 ↓1</td><td>39133</td></tr><tr><td>8</td><td>香肠派对 ↓1</td><td>28887</td></tr><tr><td>9</td><td>崩坏3 ↑9</td><td>24789</td></tr><tr><td>10</td><td>最强蜗牛 ↓1</td><td>17360</td></tr><tr><td>11</td><td>荒野乱斗 ↓1</td><td>16822</td></tr><tr><td>12</td><td>第五人格 ↓1</td><td>16468</td></tr><tr><td>13</td><td>妖神记</td><td>13501</td></tr><tr><td>14</td><td>阴阳师 ↓2</td><td>13123</td></tr><tr><td>15</td><td>球球大作战 ↓1</td><td>12165</td></tr><tr><td>16</td><td>火影忍者手游 ↑8</td><td>10762</td></tr><tr><td>17</td><td>炉石传说 ↓2</td><td>10212</td></tr><tr><td>18</td><td>明日之后 ↓2</td><td>9790</td></tr><tr><td>19</td><td>部落冲突 ↓2</td><td>9135</td></tr><tr><td>20</td><td>欢乐斗地主 ↑1</td><td>7898</td></tr><tr><td>21</td><td>碧蓝航线 ↑6</td><td>7040</td></tr><tr><td>22</td><td>新神魔大陆 ↓2</td><td>6715</td></tr><tr><td>23</td><td>剑与远征 ↓4</td><td>6683</td></tr><tr><td>24</td><td>灌篮高手 ↓2</td><td>6670</td></tr><tr><td>25</td><td>饥荒 ↓2</td><td>5901</td></tr><tr><td>26</td><td>狼人杀</td><td>5532</td></tr><tr><td>27</td><td>率土之滨 ↑1</td><td>5258</td></tr><tr><td>28</td><td>大话西游 ↑new</td><td>4509</td></tr><tr><td>29</td><td>开心消消乐 ↑1</td><td>4475</td></tr><tr><td>30</td><td>梦幻西游手游 ↓5</td><td>4474</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高效的嵌入式JavaScript模板引擎-EJS入门</title>
    <link href="/2020/07/09/%E9%AB%98%E6%95%88%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8FJavaScript%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-EJS%E5%85%A5%E9%97%A8/"/>
    <url>/2020/07/09/%E9%AB%98%E6%95%88%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8FJavaScript%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-EJS%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-EJS是什么？"><a href="#1-EJS是什么？" class="headerlink" title="1. EJS是什么？"></a>1. EJS是什么？</h1><blockquote><p>“E” 代表什么？可以表示 “可嵌入（Embedded）”，也可以是“高效（Effective）”、“优雅（Elegant）”或者是“简单（Easy）”。EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。</p></blockquote><p>因为最近我使用的<code>Hexo</code>博客框架使用到了<code>EJS</code>，所以如果想要实现一些自定义的功能，就需要了解一下<code>EJS</code>。</p><p><code>Hexo</code>的文章在这里：<a href="/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/" title="一个简单易用的制作博客的框架：Hexo">一个简单易用的制作博客的框架：Hexo</a></p><p>但是最近我发现还有一个使用<code>Vue</code>驱动的静态网站生成器，叫做<code>VuePress</code>，特色是可以在<code>Markdown</code>中使用<code>Vue</code>组件，又可以使用<code>Vue</code>来开发自定义主题，考虑什么时候研究一下。</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-npm安装"><a href="#2-1-npm安装" class="headerlink" title="2.1 npm安装"></a>2.1 npm安装</h2><p>利用 NPM 安装 EJS 很简单。</p><pre><code class="hljs powershell">npm install ejs</code></pre><h2 id="2-2-直接引入"><a href="#2-2-直接引入" class="headerlink" title="2.2 直接引入"></a>2.2 直接引入</h2><p>从这里下载 <a href="https://github.com/mde/ejs/releases/latest" target="_blank" rel="noopener">最新的浏览器版本</a>，然后引入页面即可。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"ejs.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><p>因为是学习的原因，我并没有考虑过用<code>EJS</code>搭建项目，所以我这里就选择<strong>直接引入</strong>。<code>html</code>文件样式如下：</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>测试ejs<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!-- ejs渲染的容器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 引入ejs --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./ejs.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">  <span class="hljs-comment">/* 书写ejs */</span></span><span class="javascript">  <span class="hljs-keyword">let</span> people = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>],</span><span class="actionscript">    html = ejs.render(<span class="hljs-string">'&lt;%= people.join(", "); %&gt;'</span>, &#123;people: people&#125;);</span><span class="actionscript">  <span class="hljs-comment">/* 将写好的ejs进行渲染 */</span></span><span class="javascript">  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'app'</span>).innerHTML = html;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>跟<code>Vue</code>、<code>React</code>一样，需要一个容器，好让<code>EJS</code>渲染到<code>html</code>上面。</p><h2 id="3-1-express"><a href="#3-1-express" class="headerlink" title="3.1 express"></a>3.1 express</h2><p>后面打脸的事情发生了，因为我发现如果是在浏览器上使用<code>EJS</code>，<code>ejs.renderFile</code>和<code>include</code>无法正常工作。</p><p>所以我们来搭建一个简单的基于<code>express</code>的后端。</p><p>首先我们创建一个<code>package.json</code>文件，创建方法为通过<code>CMD</code>运行：</p><pre><code class="hljs powershell">npm init</code></pre><p>然后一路回车，就可以看到文件夹中多出了一个文件<code>package.json</code>。</p><p>安装<code>ejs</code>和<code>express</code>。</p><pre><code class="hljs powershell">npm install ejs express nodemon <span class="hljs-literal">-D</span></code></pre><p>然后在<code>package.json</code>同级目录下创建<code>index.js</code>。</p><p>直接引入的代码可以改成下面的这个样子：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);<span class="hljs-keyword">const</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ejs'</span>);<span class="hljs-keyword">const</span> app = express();<span class="hljs-comment">/* 路由 */</span>app.get(<span class="hljs-string">'/'</span>, (req, res) =&gt; &#123;  <span class="hljs-keyword">let</span> people = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>],    html = ejs.render(<span class="hljs-string">'&lt;%= people.join(", "); %&gt;'</span>, &#123;<span class="hljs-attr">people</span>: people&#125;);  res.send(html);&#125;);<span class="hljs-comment">/* 监听端口 */</span>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'开启服务成功！'</span>);&#125;);</code></pre><p>最后使用<code>nodemon index.js</code>运行。</p><p>那么在浏览器上面输入<code>localhost:8080</code>就可以看到渲染后的界面了。</p><h1 id="4-方法"><a href="#4-方法" class="headerlink" title="4. 方法"></a>4. 方法</h1><p>下面的代码都在<code>express</code>搭建的后端环境上运行。</p><h2 id="4-1-template"><a href="#4-1-template" class="headerlink" title="4.1 template"></a>4.1 template</h2><p>编译字符串得到模板函数。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> template = ejs.compile(str, options);template(data); <span class="hljs-comment">// =&gt; 输出渲染后的 HTML 字符串</span></code></pre><ul><li><code>str</code>：需要解析的字符串模板</li><li><code>data</code>：数据</li><li><code>option</code>：配置选项</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-comment">/* 书写ejs */</span><span class="hljs-keyword">let</span> html = ejs.compile(<span class="hljs-string">'&lt;%=123 %&gt;'</span>)();<span class="hljs-comment">/* 将写好的ejs进行渲染 */</span>res.send(html);</code></pre><h2 id="4-2-render"><a href="#4-2-render" class="headerlink" title="4.2 render"></a>4.2 render</h2><p>直接渲染字符串并生成<code>HTML</code></p><pre><code class="hljs js">ejs.render(str, data, options); <span class="hljs-comment">// =&gt; 输出渲染后的 HTML 字符串</span></code></pre><ul><li><code>str</code>：需要解析的字符串模板</li><li><code>data</code>：数据</li><li><code>option</code>：配置选项</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-comment">/* 书写ejs */</span><span class="hljs-keyword">let</span> people = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>],  html = ejs.render(<span class="hljs-string">'&lt;%= people.join(", "); %&gt;'</span>, &#123;<span class="hljs-attr">people</span>: people&#125;);<span class="hljs-comment">/* 将写好的ejs进行渲染 */</span>res.send(html);</code></pre><h2 id="4-3-renderFile"><a href="#4-3-renderFile" class="headerlink" title="4.3 renderFile"></a>4.3 renderFile</h2><p>解析文件生成<code>HTML</code></p><pre><code class="hljs js">ejs.renderFile(filename, data, options, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err, str</span>)</span>&#123;    <span class="hljs-comment">// str =&gt; 输出渲染后的 HTML 字符串</span>&#125;);</code></pre><ul><li><code>str</code>：需要解析的字符串模板</li><li><code>data</code>：数据</li><li><code>option</code>：配置选项</li></ul><p>例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> people = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>],  html = ejs.renderFile(<span class="hljs-string">'./test.ejs'</span>, (err, str) =&gt; &#123;    res.send(str);  &#125;);</code></pre><h2 id="4-4-参数"><a href="#4-4-参数" class="headerlink" title="4.4 参数"></a>4.4 参数</h2><p>上面3个方法中的<code>options</code>可以选择的参数如下：</p><ul><li><code>cache</code> 缓存编译后的函数，需要指定 <code>filename</code>。</li><li><code>filename</code> 被 <code>cache</code> 参数用做键值，同时也用于 include 语句。</li><li><code>context</code> 函数执行时的上下文环境。</li><li><code>compileDebug</code> 当值为 <code>false</code> 时不编译调试语句。</li><li><code>client</code> 返回独立的编译后的函数。</li><li><code>delimiter</code> 放在角括号中的字符，用于标记标签的开与闭。</li><li><code>debug</code> 将生成的函数体输出。</li><li><code>_with</code> 是否使用 <code>with() {}</code> 结构。如果值为 <code>false</code>，所有局部数据将存储在 <code>locals</code> 对象上。</li><li><code>localsName</code> 如果不使用 <code>with</code> ，localsName 将作为存储局部变量的对象的名称。默认名称是 <code>locals</code>。</li><li><code>rmWhitespace</code> 删除所有可安全删除的空白字符，包括开始与结尾处的空格。对于所有标签来说，它提供了一个更安全版本的 <code>-%&gt;</code> 标签（在一行的中间并不会剔除标签后面的换行符)。</li><li><code>escape</code> 为 <code>&lt;%=</code> 结构设置对应的转义（escape）函数。它被用于输出结果以及在生成的客户端函数中通过 <code>.toString()</code> 输出。(默认转义 <code>XML</code>)。</li><li><code>outputFunctionName</code> 设置为代表函数名的字符串（例如 <code>&#39;echo&#39;</code> 或 <code>&#39;print&#39;</code>）时，将输出脚本标签之间应该输出的内容。</li><li><code>async</code> 当值为 <code>true</code> 时，EJS 将使用异步函数进行渲染。（依赖于 JS 运行环境对 <code>async/await</code> 是否支持）。</li></ul><h1 id="5-标签含义"><a href="#5-标签含义" class="headerlink" title="5. 标签含义"></a>5. 标签含义</h1><ul><li><code>&lt;%</code> ‘脚本’ 标签，用于流程控制，无输出。</li><li><code>&lt;%_</code> 删除其前面的空格符</li><li><code>&lt;%=</code> 输出数据到模板（输出是转义 HTML 标签）</li><li><code>&lt;%-</code> 输出非转义的数据到模板</li><li><code>&lt;%#</code> 注释标签，不执行、不输出内容</li><li><code>&lt;%%</code> 输出字符串 ‘&lt;%’</li><li><code>%&gt;</code> 一般结束标签</li><li><code>-%&gt;</code> 删除紧随其后的换行符</li><li><code>_%&gt;</code> 将结束标签后面的空格符删除</li></ul><h1 id="6-引入其它文件"><a href="#6-引入其它文件" class="headerlink" title="6. 引入其它文件"></a>6. 引入其它文件</h1><p>通过 <code>include</code> 指令将相对于模板路径中的模板片段包含进来。(需要提供 ‘<code>filename</code>‘ 参数。) </p><p>因为该项需要使用到<code>fs</code>所以只有在<code>Node</code>环境中才能生效，也就是说需要搭建一个<code>Node</code>后端服务器。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> people = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>],  html = ejs.render(<span class="hljs-string">`&lt;%- include('test.ejs') %&gt;`</span>, &#123;<span class="hljs-attr">filename</span>: <span class="hljs-string">'test.ejs'</span>&#125;);</code></pre><h1 id="7-自定义分隔符"><a href="#7-自定义分隔符" class="headerlink" title="7. 自定义分隔符"></a>7. 自定义分隔符</h1><p>可针对单个模板或全局使用自定义分隔符：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ejs'</span>),    users = [<span class="hljs-string">'geddy'</span>, <span class="hljs-string">'neil'</span>, <span class="hljs-string">'alex'</span>];<span class="hljs-comment">// 单个模板文件</span>ejs.render(<span class="hljs-string">'&lt;?= users.join(" | "); ?&gt;'</span>, &#123;<span class="hljs-attr">users</span>: users&#125;,    &#123;<span class="hljs-attr">delimiter</span>: <span class="hljs-string">'?'</span>&#125;);<span class="hljs-comment">// =&gt; 'geddy | neil | alex'</span><span class="hljs-comment">// 全局</span>ejs.delimiter = <span class="hljs-string">'$'</span>;ejs.render(<span class="hljs-string">'&lt;$= users.join(" | "); $&gt;'</span>, &#123;<span class="hljs-attr">users</span>: users&#125;);<span class="hljs-comment">// =&gt; 'geddy | neil | alex'</span></code></pre><h1 id="8-缓存"><a href="#8-缓存" class="headerlink" title="8. 缓存"></a>8. 缓存</h1><p>EJS 附带了一个基本的进程内缓存，用于缓在渲染模板过程中所生成的临时 JavaScript 函数。 通过 Node 的 <code>lru-cache</code> 库可以很容易地加入 LRU 缓存：</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ejs'</span>),    LRU = <span class="hljs-built_in">require</span>(<span class="hljs-string">'lru-cache'</span>);ejs.cache = LRU(<span class="hljs-number">100</span>); <span class="hljs-comment">// 具有 100 条内容限制的 LRU 缓存</span></code></pre><p>如果要清除 EJS 缓存，调用 <code>ejs.clearCache</code> 即可。如果你正在使用的是 LRU 缓存并且需要设置不同的限额，则只需要将 <code>ejs.cache</code> 重置为 一个新的 LRU 实例即可。</p><h1 id="9-自定义文件加载器"><a href="#9-自定义文件加载器" class="headerlink" title="9. 自定义文件加载器"></a>9. 自定义文件加载器</h1><p>默认的文件加载器是 <code>fs.readFileSync</code>，如果你想要的自定义它, 设置<code>ejs.fileLoader</code> 即可。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ejs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'ejs'</span>);<span class="hljs-keyword">let</span> myFileLoader = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">filePath</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">'myFileLoader: '</span> + fs.readFileSync(filePath);&#125;;ejs.fileLoader = myFileLoad;</code></pre><p>使用此功能，您可以在读取模板之前对其进行预处理。</p><h1 id="10-布局（Layouts）"><a href="#10-布局（Layouts）" class="headerlink" title="10. 布局（Layouts）"></a>10. 布局（Layouts）</h1><p>EJS 并未对块（blocks）提供专门的支持，但是可以通过 包含页眉和页脚来实现布局，如下所示：</p><pre><code class="hljs javascript">&lt;%- include(<span class="hljs-string">'header'</span>); -%&gt;&lt;h1&gt;  Title&lt;<span class="hljs-regexp">/h1&gt;</span><span class="hljs-regexp">&lt;p&gt;</span><span class="hljs-regexp">  My page</span><span class="hljs-regexp">&lt;/</span>p&gt;&lt;%- include(<span class="hljs-string">'footer'</span>); -%&gt;</code></pre><h1 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h1><p>总的来说这篇文章几乎就是参考了官方的文档，只是添加了一些使用方法，官方文档上某些用法讲的不是太明确。</p><p><code>EJS</code>上手还是非常简单的，但是有些高级用法就比较难了，因为<code>EJS</code>对于我来说不算很实用，所以就不过多的进行研究了，如果有用到，再研究也不迟。</p><p>在<code>Nodejs</code>搭建的后端中可能会用到<code>EJS</code>，但是前端项目一般不会使用<code>EJS</code>。</p><p><code>EJS</code>最方便的地方就是在于将项目给别人使用的时候，人家不用过多的去了解你的代码，直接修改配置文件就可以达到自己想要的效果。比如说<code>Hexo</code>中的配置都集中在<code>_config.yml</code>这个文件中，你根本不需要去一行一行的浏览源代码，就可以实现修改，达到你想要的效果。</p><h1 id="12-参考资料"><a href="#12-参考资料" class="headerlink" title="12. 参考资料"></a>12. 参考资料</h1><p><a href="https://ejs.bootcss.com/" target="_blank" rel="noopener">EJS官方中文文档</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>模板引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/目前最流行的前端打包工具-webpack</title>
    <link href="/2020/07/09/web%E5%BC%80%E5%8F%91/%E7%9B%AE%E5%89%8D%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-webpack/"/>
    <url>/2020/07/09/web%E5%BC%80%E5%8F%91/%E7%9B%AE%E5%89%8D%E6%9C%80%E6%B5%81%E8%A1%8C%E7%9A%84%E5%89%8D%E7%AB%AF%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7-webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>webpack 是一种前端资源构建工具，一个静态模块打包器(module bundler)。</p></blockquote><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h3><p>入口(<code>Entry</code>)指示 <code>webpack</code> 以哪个文件为入口起点开始打包，分析构建内部依赖图。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出(<code>Output</code>)指示 <code>webpack</code> 打包后的资源 <code>bundles</code> 输出到哪里去，以及如何命名。</p><h3 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h3><p><code>Loader</code> 让 <code>webpack</code> 能 够 去 处 理 那 些 非 <code>JavaScript</code> 文 件 (<code>webpack</code> 自 身 只 理 解 <code>JavaScript</code>)</p><h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><p>插件(<code>Plugins</code>)可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩， 一直到重新定义环境中的变量等。</p><h3 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h3><p>模式(<code>Mode</code>)指示 <code>webpack</code> 使用相应模式的配置。</p><h1 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs shell">npm initnpm install webpack webpack-cli -g   全局安装webpacknpm install webpack webpack-cli -D</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="无配置打包"><a href="#无配置打包" class="headerlink" title="无配置打包"></a>无配置打包</h3><p>开发环境指令：<code>webpack src/js/index.js -o build/js/built.js --mode=development</code> </p><p>功能：<code>webpack</code> 能够编译打包 <code>js</code> 和 <code>json</code> 文件，并且能将 <code>es6</code> 的模块化语法转换成 浏览器能识别的语法。 </p><p>生产环境指令：<code>webpack src/js/index.js -o build/js/built.js --mode=production</code></p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p><strong><code>webpack</code>是<code>node</code>写出来，所以需要使用<code>node</code>的语法</strong></p><p>即引入文件的时候使用<code>CommonJS</code>规范的<code>require</code>引入，而不能使用<code>ES6</code>的<code>import</code>引入。</p><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p><code>loader</code>执行顺序<strong>从下到上，从右到左</strong>。</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><p>如果要在打包中用到<code>css</code>就需要使用到这个<code>loader</code>。</p><pre><code class="hljs shell">npm i css-loader style-loader -Dnpm install --save-dev mini-css-extract-plugin css-loader</code></pre><pre><code class="hljs js">test: <span class="hljs-regexp">/\.css$/</span>,<span class="hljs-comment">// 使用哪些 loader 进行处理</span>use: [    <span class="hljs-comment">// use 数组中 loader 执行顺序：从右到左，从下到上 依次执行</span>    <span class="hljs-comment">// 创建 style 标签，将 js 中的样式资源插入进行，添加到 head 中生效</span>    <span class="hljs-string">'style-loader'</span>,    <span class="hljs-comment">// 将 css 文件变成 commonjs 模块加载 js 中，里面内容是样式字符串</span>    <span class="hljs-string">'css-loader'</span>]</code></pre><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    rules: [        &#123;        test: <span class="hljs-regexp">/\.css$/</span>,            use: [                <span class="hljs-comment">// 创建 style 标签，将样式放入</span>                <span class="hljs-comment">// 'style-loader',</span>                <span class="hljs-comment">// 这个 loader 取代 style-loader。作用：提取 js 中的 css 成单独文件</span>                MiniCssExtractPlugin.loader,                <span class="hljs-comment">// 将 css 文件整合到 js 文件中</span>                <span class="hljs-string">'css-loader'</span>            ]        &#125;    ]&#125;plugins: [    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    template: <span class="hljs-string">'./src/index.html'</span>    &#125;),    <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;    <span class="hljs-comment">// 对输出的 css 文件进行重命名</span>    filename: <span class="hljs-string">'css/built.css'</span>    &#125;)],</code></pre><p>兼容性处理</p><pre><code class="hljs shell">npm install --save-dev postcss-loader postcss-preset-env</code></pre><pre><code class="hljs js">use: [    MiniCssExtractPlugin.loader,    <span class="hljs-string">'css-loader'</span>,    &#123;        loader: <span class="hljs-string">'postcss-loader'</span>,        options: &#123;            ident: <span class="hljs-string">'postcss'</span>,            plugins: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [                <span class="hljs-comment">// postcss 的插件</span>                <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-preset-env'</span>)()            ]        &#125;    &#125;]</code></pre><p>修改<code>package.json</code></p><pre><code class="hljs json">"browserslist": &#123;    "development": [        "last 1 chrome version",        "last 1 firefox version",        <span class="hljs-string">"last 1 safari version"</span>    ],    "production": [        "&gt;0.2%",        "not dead",        <span class="hljs-string">"not op_mini all"</span>    ]&#125;</code></pre><p>提取成单独文件。</p><pre><code class="hljs shell">npm install --save-dev mini-css-extract-plugin</code></pre><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>如果想在项目中使用<code>less</code>就需要这个<code>loader</code>。</p><pre><code class="hljs shell">npm i less-loader less -D</code></pre><h4 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h4><p>打包的时候引用到的图片的打包方式。</p><pre><code class="hljs shell">npm install --save-dev html-loader url-loader file-loader</code></pre><pre><code class="hljs js">test: <span class="hljs-regexp">/\.(jpg|png|gif)$/</span>loader: <span class="hljs-string">"url-loader"</span>,options: &#123;    <span class="hljs-comment">// 图片大小小于 8kb，就会被 base64 处理</span>    <span class="hljs-comment">// 优点: 减少请求数量（减轻服务器压力）</span>    <span class="hljs-comment">// 缺点：图片体积会更大（文件请求速度更慢）</span>    limit: <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>,    <span class="hljs-comment">// 问题：因为 url-loader 默认使用 es6 模块化解析，而 html-loader 引入图片是 commonjs</span>    <span class="hljs-comment">// 解析时会出问题：[object Module]</span>    <span class="hljs-comment">// 解决：关闭 url-loader 的 es6 模块化，使用 commonjs 解析</span>    esModules: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 给图片进行重命名</span>    <span class="hljs-comment">// [hash:10]取图片的 hash 的前 10 位</span>    <span class="hljs-comment">// [ext]取文件原来扩展名</span>    name: <span class="hljs-string">"[hash:10].[ext]"</span>&#125;</code></pre><h4 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h4><p>即除了制定的资源以外的资源的打包方式。</p><pre><code class="hljs js">&#123;    <span class="hljs-comment">// 排除 css/js/html 资源</span>    exclude: <span class="hljs-regexp">/\.(css|js|html|less)$/</span>,    loader: <span class="hljs-string">'file-loader'</span>,    options: &#123;    name: <span class="hljs-string">'[hash:10].[ext]'</span>    &#125;&#125;</code></pre><h3 id="plugins-插件"><a href="#plugins-插件" class="headerlink" title="plugins 插件"></a>plugins 插件</h3><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code class="hljs shell">npm install --save-dev html-webpack-plugin</code></pre><pre><code class="hljs js"><span class="hljs-comment">// plugins 的配置</span><span class="hljs-comment">// html-webpack-plugin</span><span class="hljs-comment">// 功能：默认会创建一个空的 HTML，自动引入打包输出的所有资源（JS/CSS）</span><span class="hljs-comment">// 需求：需要有结构的 HTML 文件</span><span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;        <span class="hljs-comment">// 复制 './src/index.html' 文件，并自动引入打包输出的所有资源（JS/CSS）</span>        template: <span class="hljs-string">'./src/index.html'</span>&#125;)</code></pre><p>压缩</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;    template: <span class="hljs-string">'./src/index.html'</span>,    <span class="hljs-comment">// 压缩 html 代码</span>    minify: &#123;    <span class="hljs-comment">// 移除空格</span>    collapseWhitespace: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 移除注释</span>    removeComments: <span class="hljs-literal">true</span>    &#125;&#125;)</code></pre><h4 id="压缩CSS"><a href="#压缩CSS" class="headerlink" title="压缩CSS"></a>压缩CSS</h4><pre><code class="hljs shell">npm install --save-dev optimize-css-assets-webpack-plugin</code></pre><p>使用方法：</p><p>直接在插件处添加：</p><p><code>new OptimizeCssAssetsWebpackPlugin()</code></p><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p>语法检查<code>eslint</code>，如果要多人合作开发项目或者开发一个大型项目，<code>eslint</code>非常有必要，它不仅可以检测出代码中潜在的一些<code>BUG</code>，还可以将代码的风格进行统一。</p><pre><code class="hljs shell">npm install --save-dev eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import</code></pre><pre><code class="hljs js"><span class="hljs-comment">/*语法检查： eslint-loader eslint</span><span class="hljs-comment">注意：只检查自己写的源代码，第三方的库是不用检查的</span><span class="hljs-comment">设置检查规则：</span><span class="hljs-comment">package.json 中 eslintConfig 中设置~</span><span class="hljs-comment">"eslintConfig": &#123;</span><span class="hljs-comment">"extends": "airbnb-base"</span><span class="hljs-comment">&#125;</span><span class="hljs-comment">airbnb --&gt; eslint-config-airbnb-base eslint-plugin-import eslint</span><span class="hljs-comment">*/</span>&#123;    test: <span class="hljs-regexp">/\.js$/</span>,    exclude: <span class="hljs-regexp">/node_modules/</span>,    loader: <span class="hljs-string">'eslint-loader'</span>,    options: &#123;    <span class="hljs-comment">// 自动修复 eslint 的错误</span>        fix: <span class="hljs-literal">true</span>    &#125;&#125;</code></pre><p>修改<code>package.json</code></p><pre><code class="hljs json">"eslintConfig": &#123;  "extends": "airbnb-base",  "env": &#123;    "browser": true  &#125;</code></pre><h5 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h5><p>在不同的浏览器中，js支持的语法可能也不相同，所以可以指示 babel 做怎么样的兼容性处理。</p><pre><code class="hljs shell">npm install --save-dev babel-loader @babel/core @babel/polyfill core-js @babel/preset-env</code></pre><pre><code class="hljs js">&#123;    test: <span class="hljs-regexp">/\.js$/</span>,    exclude: <span class="hljs-regexp">/node_modules/</span>,    loader: <span class="hljs-string">'babel-loader'</span>,    options: &#123;        <span class="hljs-comment">// 预设：指示 babel 做怎么样的兼容性处理</span>        presets: [            [                <span class="hljs-string">'@babel/preset-env'</span>,                &#123;                    <span class="hljs-comment">// 按需加载</span>                    useBuiltIns: <span class="hljs-string">'usage'</span>,                    <span class="hljs-comment">// 指定 core-js 版本</span>                    corejs: &#123;                        version: <span class="hljs-number">3</span>                    &#125;,                    <span class="hljs-comment">// 指定兼容性做到哪个版本浏览器</span>                    targets: &#123;                        chrome: <span class="hljs-string">'60'</span>,                        firefox: <span class="hljs-string">'60'</span>,                        ie: <span class="hljs-string">'9'</span>,                        safari: <span class="hljs-string">'10'</span>,                        edge: <span class="hljs-string">'17'</span>                    &#125;                &#125;            ]        ]    &#125;&#125;</code></pre><p>生产环境会自动压缩js代码</p><p>每次打包自动删除</p><pre><code class="hljs shell">npm install --save-dev clean-webpack-plugin</code></pre><h3 id="devserver"><a href="#devserver" class="headerlink" title="devserver"></a>devserver</h3><p>如果使用<code>webpack</code>，则每次修改了代码就需要重新进行打包，但是<code>devserver</code>可以实现在你修改代码之后，自动为你打包运行，并且可以模拟出一个服务器。</p><p>运行：</p><pre><code class="hljs shell">npx webpack-dev-server</code></pre><p>使用：</p><pre><code class="hljs js">devServer: &#123;    <span class="hljs-comment">// 项目构建后路径</span>    contentBase: resolve(__dirname, <span class="hljs-string">'build'</span>),    <span class="hljs-comment">// 启动 gzip 压缩</span>    compress: <span class="hljs-literal">true</span>,    <span class="hljs-comment">// 端口号</span>    port: <span class="hljs-number">3000</span>,    <span class="hljs-comment">// 自动打开浏览器</span>    open: <span class="hljs-literal">true</span>&#125;</code></pre><h1 id="环境优化"><a href="#环境优化" class="headerlink" title="环境优化"></a>环境优化</h1><h2 id="HMR"><a href="#HMR" class="headerlink" title="HMR"></a>HMR</h2><ul><li><code>HMR:hot module replacement</code> 热模块替换/模块热替换作用：一个模块发生变化，只会重新打包这一个模块（而不是打包所有模块）极大提升构建速度。</li><li>样式文件：可以使用<code>HMR</code>功能：因为<code>style-loader</code>内部实现了。</li><li><code>。js</code>文件：默认不能使用<code>HMR</code>功能。</li><li><code>html</code>文件：默认不能使用<code>HMR</code>功能.同时会导致问题：<code>html</code>文件不能热更新了解决：修改<code>entry</code>入口，将<code>html</code>文件引入。</li></ul><h2 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h2><p><code>devtool: &quot;eval-source-map&quot;</code>：一种提供源代码到构建后代码映射技术，即如果代码出现报错，是否会指向源代码中错误的哪一行。</p><p><code>source-map</code>：外部</p><ul><li>错误代码准确信息和源代码的错误位置</li></ul><p><code>inline-source-map</code>：内联</p><ul><li>只生成一个内联source-map</li><li>错误代码准确信息和源代码的错误位置</li></ul><p><code>hidden-source-map</code>：外部</p><ul><li>错误代码错误原因，但是没有错误位置</li><li>不能追踪源代码错误，只能提示到构建后代码的错误位置</li></ul><p><code>eval-source-map</code>：内联</p><ul><li>每一个文件都生成对应的source-map，都在eval错误代码准确信息和源代码的错误位置</li></ul><p><code>nosources-source-map</code>：外部</p><ul><li>错误代码准确信息，但是没有任何源代码信息</li></ul><p><code>cheap-source-map</code>：外部</p><ul><li>错误代码准确信息和源代码的错误位置只能精确到行</li></ul><p><code>cheap-module-source-map</code>：外部</p><ul><li>错误代码准确信息和源代码的错误位置</li></ul><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>速度快，调试更友好</p><p>速度快（<code>eval&gt;inline&gt;cheap&gt;...</code>）</p><ul><li><code>eval-cheap-souce-map</code></li><li><code>eval-source-map</code></li></ul><p>调试更友好</p><ul><li><code>souce-map</code></li><li><code>cheap-module-souce-map</code></li><li><code>cheap-souce-map</code></li></ul><p>推荐选择 </p><ul><li><code>eval-source-map</code></li><li><code>eval-cheap-module-souce-map</code></li></ul><h3 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h3><p>源代码要不要隐藏？调试要不要更友好</p><p>内联会让代码体积变大，所以在生产环境不用内联</p><p><code>nosources-source-map</code>全部隐藏</p><p><code>hidden-source-map</code>只隐藏源代码，会提示构建后代码错误信息</p><p>选择</p><p><strong>source-map</strong>/cheap-module-souce-map</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><code>cacheDirectory:true</code>文件资源缓存</p><p><code>hash</code>：每次wepack构建时会生成一个唯一的hash值。</p><ul><li>问题：因为js和css同时使用一个hash值。</li><li>如果重新打包，会导致所有缓存失效。（可能我却只改动一个文件）</li></ul><p><code>chunkhash</code>：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样</p><ul><li>问题：js和css的hash值还是一样的</li><li>因为css是在js中被引入的，所以同属于一个chunk </li></ul><p><code>contenthash</code>：根据文件的内容生成hash值。不同文件hash值一定不一样</p><h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p>去除应用程序中没有使用的代码</p><ol><li>必须使用<code>ES6</code>模块化</li><li>开启<code>production</code>环境</li></ol><p>减少代码体积</p><p>在<code>package.json</code>中配置</p><p><code>&quot;sideEffects&quot;：false</code> </p><p>可能会把<code>css/@babel/polyfill</code>去除</p><h2 id="code-split"><a href="#code-split" class="headerlink" title="code split"></a>code split</h2><ol><li>可以将node_modules中代码单独打包一个chunk最终输出</li><li>自动分析多入口chunk中，有没有公共的文件。如果有会打包成单独一个chunk</li></ol><pre><code class="hljs js">optimization:&#123;    splitChunks:&#123;    chunks:<span class="hljs-string">'all'</span>&#125;&#125;,    <span class="hljs-comment">/*</span><span class="hljs-comment">通过s代码，让某个文件被单独打包成一个chunk</span><span class="hljs-comment">import动态导入语法：能将某个文件单独打包</span><span class="hljs-comment">*/</span><span class="hljs-keyword">import</span>(<span class="hljs-comment">/* webpackChunkName :"test",webpackPrefetch:true */</span><span class="hljs-string">"./test"</span>)</code></pre><p><code>webpackPrefetch</code> 预加载，会在使用之前加载</p><p><strong>存在兼容性问题 慎用</strong></p><p>正常加载可以认为是并行加载 预加载为浏览器空闲时才加载</p><h2 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h2><p>渐进式网络开发应用程序（离线访问技术），即没有网络的情况，也可以打开界面。</p><p>sw代码必须运行在服务器上</p><pre><code class="hljs shell">mpn i workbox-webpack-plugin -d</code></pre><pre><code class="hljs js"><span class="hljs-keyword">new</span> WorkboxwebpackPlugin.GenerateSw(&#123;    <span class="hljs-comment">/*</span><span class="hljs-comment">    1.帮助serviceworker快速启动</span><span class="hljs-comment">    2.删除旧的 serviceworker生成一个serviceworker配置文件。</span><span class="hljs-comment">    */</span>    clientsClaim:<span class="hljs-literal">true</span>,    skipWaiting:<span class="hljs-literal">true</span>    &#125;)</code></pre><h2 id="多进程打包"><a href="#多进程打包" class="headerlink" title="多进程打包"></a>多进程打包</h2><p><code>thread-loader</code>开启多进程打包。</p><p>进程启动大概为600ms，进程通信也有开销。</p><p>只有工作消耗时间比较长，才需要多进程打包，如果本身不大，使用多线程打包反而会更慢。</p><h2 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h2><pre><code class="hljs js">externals:&#123;<span class="hljs-comment">//拒绝jQuery被打包进来</span>jquery:<span class="hljs-string">'jQuery'</span>&#125;</code></pre><h2 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h2><p>将库打包成不同的文件</p><h1 id="配置详解"><a href="#配置详解" class="headerlink" title="配置详解"></a><a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">配置详解</a></h1><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><pre><code class="hljs js">resolve:&#123;    <span class="hljs-comment">//配置解析模块路径别名 缺点没有提示</span>    alias:&#123;   $css: resolve(__dirname,<span class="hljs-string">"src/css"</span>)    &#125;,    <span class="hljs-comment">//配置省略文件路径的后缀名</span>    extensions:[<span class="hljs-string">".js"</span>,<span class="hljs-string">".json"</span>],    <span class="hljs-comment">//告诉webpack解析模块是去找哪个目录</span>modules:[resolve（dirname，<span class="hljs-string">'../../node_modules'</span>），<span class="hljs-string">'node_modules'</span>]&#125;</code></pre><h2 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h2><pre><code class="hljs js">optimization: &#123;splitChunks: &#123;    chunks: <span class="hljs-string">'all'</span>    <span class="hljs-comment">// 默认值，可以不写~</span>&#125;,    <span class="hljs-comment">// 将当前模块的记录其他模块的 hash 单独打包为一个文件 runtime</span>    <span class="hljs-comment">// 解决：修改 a 文件导致 b 文件的 contenthash 变化</span>runtimeChunk: &#123;name: <span class="hljs-function"><span class="hljs-params">entrypoint</span> =&gt;</span> <span class="hljs-string">`runtime-<span class="hljs-subst">$&#123;entrypoint.name&#125;</span>`</span>&#125;,</code></pre><h1 id="webpack5"><a href="#webpack5" class="headerlink" title="webpack5"></a>webpack5</h1><pre><code class="hljs shell">npm iwebpack@next webpack-cli-D</code></pre><ul><li>通过持久缓存提高构建性能.</li><li>使用更好的算法和默认值来改善长期缓存。</li><li>通过更好的树摇和代码生成来改善捆绑包大小。</li><li>清除处于怪异状态的内部结构，同时在v4中实现功能而不引入任何重大更改.</li><li>通过引入重大更改来为将来的功能做准备，以使我们能够尽可能长时间地使用v5.</li></ul><p>添加了用于长期缓存的新算法。在生产模式下默认情况下启用这些功能。</p><p><code>nodejs</code>提供的模块需要手动添加。</p><p><code>webpack</code>内部有<code>chunk</code>命名规则，不再是以id（0，1，2）命名了。</p><p><code>webpack</code> 现在能够处理对嵌套模块的<code>tree shaking</code>。</p><p><code>webpack 4</code>默认只能输出ES5代码</p><p><code>webpack5</code>开始新增一个属性<code>output.ecmaVersion</code>，可以生成<code>ES5</code>和<code>ES6/ES2015</code>代码</p><h1 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h1><p>将<code>webpack</code>常用的配置放在下面，免得每次使用都需要进行配置：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; resolve &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"path"</span>);<span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"mini-css-extract-plugin"</span>);<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"optimize-css-assets-webpack-plugin"</span>);<span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">"html-webpack-plugin"</span>);<span class="hljs-keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">"clean-webpack-plugin"</span>);process.env.NODE_ENV = <span class="hljs-string">"production"</span>;<span class="hljs-keyword">const</span> commonCssLoader = [    MiniCssExtractPlugin.loader,    <span class="hljs-string">"css-loader"</span>,    &#123;        loader: <span class="hljs-string">"postcss-loader"</span>,        options: &#123;            ident: <span class="hljs-string">"postcss"</span>,            plugins: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> [<span class="hljs-built_in">require</span>(<span class="hljs-string">"postcss-preset-env"</span>)()]        &#125;    &#125;];<span class="hljs-built_in">module</span>.exports = &#123;    entry: [<span class="hljs-string">"./src/index.js"</span>, <span class="hljs-string">"./src/index.html"</span>],    output: &#123;        filename: <span class="hljs-string">"js/built.[contenthash:10].js"</span>,        path: resolve(__dirname, <span class="hljs-string">"build"</span>),        publicPath: <span class="hljs-string">"/"</span>,        chunkFilename: <span class="hljs-string">"js/[name].[contenthash:10]_chunk.js"</span>    &#125;,    <span class="hljs-built_in">module</span>: &#123;        rules: [            &#123;                test: <span class="hljs-regexp">/\.js$/</span>,                exclude: <span class="hljs-regexp">/node_modules/</span>,                enforce: <span class="hljs-string">"pre"</span>,                loader: <span class="hljs-string">"eslint-loader"</span>,                options: &#123;                    fix: <span class="hljs-literal">true</span>                &#125;            &#125;,            &#123;                oneOf: [                    &#123;                        test: <span class="hljs-regexp">/\.css$/</span>,                        use: [...commonCssLoader]                    &#125;,                    &#123;                        test: <span class="hljs-regexp">/\.js$/</span>,                        exclude: <span class="hljs-regexp">/node_modules/</span>,                        loader: <span class="hljs-string">"babel-loader"</span>,                        options: &#123;                            presets: [                                [                                    <span class="hljs-string">"@babel/preset-env"</span>,                                    &#123;                                        useBuiltIns: <span class="hljs-string">"usage"</span>,                                        corejs: &#123; <span class="hljs-attr">version</span>: <span class="hljs-number">3</span> &#125;,                                        targets: &#123;                                            chrome: <span class="hljs-string">"60"</span>,                                            firefox: <span class="hljs-string">"50"</span>,                                            ie: <span class="hljs-string">"9"</span>,                                            safari: <span class="hljs-string">"10"</span>,                                            edge: <span class="hljs-string">"17"</span>                                        &#125;                                    &#125;                                ]                            ],                            cacheDirectory: <span class="hljs-literal">true</span>                        &#125;                    &#125;,                    &#123;                        test: <span class="hljs-regexp">/\.(jpg|png|gif)/</span>,                        loader: <span class="hljs-string">"url-loader"</span>,                        options: &#123;                            limit: <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>,                            name: <span class="hljs-string">"[hash:10].[ext]"</span>,                            outputPath: <span class="hljs-string">"imgs"</span>,                            esModule: <span class="hljs-literal">false</span>                        &#125;                    &#125;,                    &#123;                        test: <span class="hljs-regexp">/\.html$/</span>,                        loader: <span class="hljs-string">"html-loader"</span>                    &#125;,                    &#123;                        exclude: <span class="hljs-regexp">/\.(js|css|less|html|jpg|png|gif)/</span>,                        loader: <span class="hljs-string">"file-loader"</span>,                        options: &#123;                            outputPath: <span class="hljs-string">"media"</span>                        &#125;                    &#125;                ]            &#125;]    &#125;,    plugins: [        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;            filename: <span class="hljs-string">"css/built.[contenthash:10].css"</span>        &#125;),        <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(),        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template: <span class="hljs-string">"./src/index.html"</span>,            minify: &#123;                collapseWhitespace: <span class="hljs-literal">true</span>,                removeComments: <span class="hljs-literal">true</span>            &#125;        &#125;),        <span class="hljs-keyword">new</span> CleanWebpackPlugin()    ],    mode: <span class="hljs-string">"development"</span>,    devServer: &#123;        contentBase: resolve(__dirname, <span class="hljs-string">"build"</span>),        compress: <span class="hljs-literal">true</span>,        port: <span class="hljs-number">3000</span>,        open: <span class="hljs-literal">true</span>,        clientLogLevel: <span class="hljs-string">"none"</span>,        hot: <span class="hljs-literal">true</span>,        watchContentBase: <span class="hljs-literal">true</span>,        watchOptions: &#123;            ignored: <span class="hljs-regexp">/node_modules/</span>        &#125;,        quiet: <span class="hljs-literal">true</span>    &#125;,    optimization: &#123;        splitChunks: &#123;            chunks: <span class="hljs-string">"all"</span>        &#125;,        runtimeChunk: &#123;            name:<span class="hljs-function"><span class="hljs-params">entrypoint</span> =&gt;</span><span class="hljs-string">`runtime-<span class="hljs-subst">$&#123;entrypoint.name&#125;</span>`</span>        &#125;    &#125;,    devtool: <span class="hljs-string">"source-map"</span>&#125;;</code></pre><p><code>package.json</code>添加</p><pre><code class="hljs json">"browserslist": &#123;  "development": [    "last 1 chrome version",    "last 1 firefox version",    <span class="hljs-string">"last 1 safari version"</span>  ],  "production": [    "&gt;0.2%",    "not dead",    <span class="hljs-string">"not op_mini all"</span>  ]&#125;,"eslintConfig": &#123;  "extends": "airbnb-base",  "env": &#123;    "browser": true  &#125;&#125;</code></pre><p>运行：</p><p><code>npx webpack-dev-server</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1e7411j7T5?p=3" target="_blank" rel="noopener">尚硅谷2020最新版Webpack5实战教程(从入门到精通)</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月08日</title>
    <link href="/2020/07/09/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8808%E6%97%A5/"/>
    <url>/2020/07/09/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8808%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>86662</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>58243</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>24744</td></tr><tr><td>4</td><td>地下城与勇士+dnf ↑2</td><td>19536</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>15465</td></tr><tr><td>6</td><td>梦幻西游 ↓2</td><td>13437</td></tr><tr><td>7</td><td>最终幻想14+ff14 ↑2</td><td>12313</td></tr><tr><td>8</td><td>刀塔2+DOTA2</td><td>11963</td></tr><tr><td>9</td><td>坦克世界 ↑6</td><td>11792</td></tr><tr><td>10</td><td>天龙八部 ↓3</td><td>11378</td></tr><tr><td>11</td><td>魔兽世界+wow ↓1</td><td>10519</td></tr><tr><td>12</td><td>csgo ↓1</td><td>10200</td></tr><tr><td>13</td><td>炉石传说 ↓1</td><td>9720</td></tr><tr><td>14</td><td>龙之谷 ↑4</td><td>8989</td></tr><tr><td>15</td><td>冒险岛 ↑1</td><td>8473</td></tr><tr><td>16</td><td>方舟生存进化 ↓2</td><td>7978</td></tr><tr><td>17</td><td>激战2 ↓4</td><td>7706</td></tr><tr><td>18</td><td>守望先锋 ↓1</td><td>6739</td></tr><tr><td>19</td><td>逆水寒</td><td>6278</td></tr><tr><td>20</td><td>QQ飞车 ↑8</td><td>5447</td></tr><tr><td>21</td><td>诛仙 ↓1</td><td>5374</td></tr><tr><td>22</td><td>变形金刚 ↓1</td><td>5186</td></tr><tr><td>23</td><td>星际战甲+warframe ↓1</td><td>5044</td></tr><tr><td>24</td><td>EVE ↓1</td><td>4927</td></tr><tr><td>25</td><td>龙族</td><td>4655</td></tr><tr><td>26</td><td>大话西游 ↓2</td><td>4606</td></tr><tr><td>27</td><td>剑灵 ↑2</td><td>4529</td></tr><tr><td>28</td><td>传奇 ↓1</td><td>4439</td></tr><tr><td>29</td><td>流放之路 ↓3</td><td>4428</td></tr><tr><td>30</td><td>天涯明月刀 ↑new</td><td>4094</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>155397</td></tr><tr><td>2</td><td>和平精英</td><td>63697</td></tr><tr><td>3</td><td>我的世界+mc</td><td>58220</td></tr><tr><td>4</td><td>迷你世界</td><td>54533</td></tr><tr><td>5</td><td>光遇 ↑8</td><td>50975</td></tr><tr><td>6</td><td>江南百景图</td><td>32465</td></tr><tr><td>7</td><td>香肠派对</td><td>27111</td></tr><tr><td>8</td><td>龙之谷2 ↑10</td><td>25013</td></tr><tr><td>9</td><td>最强蜗牛 ↓1</td><td>19129</td></tr><tr><td>10</td><td>荒野乱斗 ↓5</td><td>18918</td></tr><tr><td>11</td><td>第五人格 ↓2</td><td>15396</td></tr><tr><td>12</td><td>阴阳师 ↓2</td><td>15229</td></tr><tr><td>13</td><td>妖神记 ↓2</td><td>14288</td></tr><tr><td>14</td><td>球球大作战 ↓2</td><td>11808</td></tr><tr><td>15</td><td>炉石传说</td><td>9720</td></tr><tr><td>16</td><td>明日之后</td><td>9441</td></tr><tr><td>17</td><td>部落冲突 ↓3</td><td>9421</td></tr><tr><td>18</td><td>崩坏3 ↑1</td><td>9331</td></tr><tr><td>19</td><td>剑与远征 ↑3</td><td>9137</td></tr><tr><td>20</td><td>新神魔大陆 ↓3</td><td>7896</td></tr><tr><td>21</td><td>欢乐斗地主 ↓1</td><td>7663</td></tr><tr><td>22</td><td>灌篮高手 ↓1</td><td>6442</td></tr><tr><td>23</td><td>饥荒 ↑4</td><td>5848</td></tr><tr><td>24</td><td>火影忍者手游 ↓1</td><td>5543</td></tr><tr><td>25</td><td>梦幻西游手游 ↑4</td><td>5431</td></tr><tr><td>26</td><td>狼人杀 ↓1</td><td>5385</td></tr><tr><td>27</td><td>碧蓝航线 ↓1</td><td>5268</td></tr><tr><td>28</td><td>率土之滨</td><td>5123</td></tr><tr><td>29</td><td>神魔大陆 ↓5</td><td>4956</td></tr><tr><td>30</td><td>开心消消乐 ↑new</td><td>4631</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题常客之-Promise</title>
    <link href="/2020/07/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B8%B8%E5%AE%A2%E4%B9%8B-Promise/"/>
    <url>/2020/07/08/%E9%9D%A2%E8%AF%95%E9%A2%98%E5%B8%B8%E5%AE%A2%E4%B9%8B-Promise/</url>
    
    <content type="html"><![CDATA[<h1 id="Promise是什么"><a href="#Promise是什么" class="headerlink" title="Promise是什么"></a>Promise是什么</h1><p><code>Promise</code> 是异步编程的一种解决方案，比传统的解决方案<strong>回调函数和事件</strong>更合理和更强大。简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，<code>Promise</code> 是一个对象，从它可以获取异步操作的消息。<code>Promise</code> 提供统一的 <code>API</code>，各种异步操作都可以用同样的方法进行处理。</p><h1 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h1><p><code>Promise</code> 对象是 <code>JavaScript</code> 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（<code>proxy</code>），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。<code>Promise</code> 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><ol><li>回调地狱，代码难以维护。</li><li><code>promise</code>可以支持多个并发的请求，获取并发请求中的数据。</li><li><code>promise</code>可以解决可读性的问题，异步的嵌套带来的可读性的问题。</li><li><code>promise</code>可以解决信任问题，对于回调过早、回调过晚或没有调用和回调次数太少或太多，由于<code>promise</code>只能决议一次，决议值只能有一个，决议之后无法改变，任何then中的回调也只会被调用一次，所以这就保证了<code>Promise</code>可以解决信任问题。</li></ol><h1 id="其它解决方案"><a href="#其它解决方案" class="headerlink" title="其它解决方案"></a>其它解决方案</h1><ol><li><code>setTimeout</code>：缺点不精确，只是确保在一定时间后加入到任务队列，并不保证立马执行。只有执行引擎栈中的代码执行完毕，主线程才会去读取任务队列。</li><li>事件监听：任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</li><li><code>Generator</code>函数虽然将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段），即如何实现自动化的流程管理。</li><li><code>async</code>/<code>await</code>终极解决方案，但是过多的使用容易造成性能降低，一般只用在必须要使用的地方。</li></ol><h1 id="Promise-原理"><a href="#Promise-原理" class="headerlink" title="Promise 原理"></a>Promise 原理</h1><p><code>Promise</code> 对象是一个代理对象（代理一个值），被代理的值在<code>Promise</code>对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的<code>promise</code>对象</p><p>一个 <code>Promise</code>有以下几种状态:</p><ul><li><code>pending</code>: 初始状态，既不是成功，也不是失败状态。</li><li><code>fulfilled</code>: 意味着操作成功完成。</li><li><code>rejected</code>: 意味着操作失败。</li></ul><p><code>pending</code> 状态的 <code>Promise</code> 对象可能会变为fulfilled 状态并传递一个值给相应的状态处理方法，也可能变为失败状态（<code>rejected</code>）并传递失败信息。当其中任一种情况出现时，<code>Promise</code> 对象的 <code>then</code> 方法绑定的处理方法（<code>handlers</code> ）就会被调用（<code>then</code>方法包含两个参数：<code>onfulfilled</code> 和 <code>onrejected</code>，它们都是 <code>Function</code> 类型。当<code>Promise</code>状态为<code>fulfilled</code>时，调用 <code>then</code> 的 <code>onfulfilled</code> 方法，当<code>Promise</code>状态为<code>rejected</code>时，调用 <code>then</code> 的 <code>onrejected</code> 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。</p><p>因为 <code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code> 方法返回<code>promise</code> 对象， 所以它们可以被链式调用。</p><p><img src="/image/promises.png" srcset="/img/loading.gif" alt="img"></p><h1 id="Promise-创建"><a href="#Promise-创建" class="headerlink" title="Promise 创建"></a>Promise 创建</h1><p>创建一个<code>Promise</code>非常简单，使用 new 来调用 Promise 的构造器来进行实例化。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> promise =<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;    <span class="hljs-comment">// 异步处理</span>    <span class="hljs-comment">// 处理结束后、调用resolve 或 reject</span>&#125;)</code></pre><p><code>Promise</code> 构造函数包含一个参数和一个带有 <code>resolve</code>（解析）和 <code>reject</code>（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 <code>resolve</code>，否则调用 <code>reject</code>。</p><h1 id="Promise-常用的方法"><a href="#Promise-常用的方法" class="headerlink" title="Promise 常用的方法"></a>Promise 常用的方法</h1><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p><code>then</code>方法可以接受两个回调函数作为参数。</p><ul><li>第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用。</li><li>第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。</li></ul><p>其中，第二个函数是可选的，不一定要提供。这两个函数都接受<code>Promise</code>对象传出的值作为参数。</p><p>可以采用链式写法，例如：</p><pre><code class="hljs js">getJSON(<span class="hljs-string">"/posts.json"</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">json</span>) </span>&#123;  <span class="hljs-keyword">return</span> json.post;&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">post</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><ul><li><p>指定发生错误时的回调函数。</p></li><li><p>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</p></li><li><p>一般来说，不要在<code>then()</code>方法里面定义 Reject 状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。</p></li><li><p>没有报错时，会跳过<code>catch()</code></p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;    resolve(x + <span class="hljs-number">2</span>);  &#125;);&#125;;someAsyncThing()  <span class="hljs-comment">//没有报错时会跳过</span>  .catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"oh no"</span>, error);  &#125;)  .then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"carry on"</span>);  &#125;);</code></pre></li></ul><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>有时需要将现有对象转为 Promise 对象，<code>Promise.resolve()</code>方法就起到这个作用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jsPromise = <span class="hljs-built_in">Promise</span>.resolve($.ajax(<span class="hljs-string">'/whatever.json'</span>));</code></pre><p>上面代码将 jQuery 生成的<code>deferred</code>对象，转为一个新的 Promise 对象。</p><p><code>Promise.resolve()</code>等价于下面的写法。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'foo'</span>)<span class="hljs-comment">// 等价于</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(<span class="hljs-string">'foo'</span>))</code></pre><p><code>Promise.resolve</code>方法的参数分成四种情况。</p><p><strong>（1）参数是一个 Promise 实例</strong></p><p>如果参数是 Promise 实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p><p><strong>（2）参数是一个<code>thenable</code>对象</strong></p><p><code>thenable</code>对象指的是具有<code>then</code>方法的对象，比如下面这个对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    resolve(<span class="hljs-number">42</span>);  &#125;&#125;;</code></pre><p><code>Promise.resolve</code>方法会将这个对象转为 Promise 对象，然后就立即执行<code>thenable</code>对象的<code>then</code>方法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> thenable = &#123;  then: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    resolve(<span class="hljs-number">42</span>);  &#125;&#125;;<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(thenable);p1.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(value);  <span class="hljs-comment">// 42</span>&#125;);</code></pre><p>上面代码中，<code>thenable</code>对象的<code>then</code>方法执行后，对象<code>p1</code>的状态就变为<code>resolved</code>，从而立即执行最后那个<code>then</code>方法指定的回调函数，输出 42。</p><p><strong>（3）参数不是具有<code>then</code>方法的对象，或根本就不是对象</strong></p><p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的 Promise 对象，状态为<code>resolved</code>。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'Hello'</span>);p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>)</span>&#123;  <span class="hljs-built_in">console</span>.log(s)&#125;);<span class="hljs-comment">// Hello</span></code></pre><p>上面代码生成一个新的 Promise 对象的实例<code>p</code>。由于字符串<code>Hello</code>不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是<code>resolved</code>，所以回调函数会立即执行。<code>Promise.resolve</code>方法的参数，会同时传给回调函数。</p><p><strong>（4）不带有任何参数</strong></p><p><code>Promise.resolve()</code>方法允许调用时不带参数，直接返回一个<code>resolved</code>状态的 Promise 对象。</p><p>所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用<code>Promise.resolve()</code>方法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve();p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre><p>上面代码的变量<code>p</code>就是一个 Promise 对象。</p><p>需要注意的是，立即<code>resolve()</code>的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。</p><pre><code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'three'</span>);&#125;, <span class="hljs-number">0</span>);<span class="hljs-built_in">Promise</span>.resolve().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'two'</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'one'</span>);<span class="hljs-comment">// one</span><span class="hljs-comment">// two</span><span class="hljs-comment">// three</span></code></pre><p>上面代码中，<code>setTimeout(fn, 0)</code>在下一轮“事件循环”开始时执行，<code>Promise.resolve()</code>在本轮“事件循环”结束时执行，<code>console.log(&#39;one&#39;)</code>则是立即执行，因此最先输出。</p><h2 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h2><p><code>Promise.reject(reason)</code>方法也会返回一个新的 Promise 实例，该实例的状态为<code>rejected</code>。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-string">'出错了'</span>);<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> reject(<span class="hljs-string">'出错了'</span>))p.then(<span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(s)&#125;);<span class="hljs-comment">// 出错了</span></code></pre><p>上面代码生成一个 Promise 对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p><p>注意，<code>Promise.reject()</code>方法的参数，会原封不动地作为<code>reject</code>的理由，变成后续方法的参数。这一点与<code>Promise.resolve</code>方法不一致。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> thenable = &#123;  then(resolve, reject) &#123;    reject(<span class="hljs-string">'出错了'</span>);  &#125;&#125;;<span class="hljs-built_in">Promise</span>.reject(thenable).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(e === thenable)&#125;)<span class="hljs-comment">// true</span></code></pre><p>上面代码中，<code>Promise.reject</code>方法的参数是一个<code>thenable</code>对象，执行以后，后面<code>catch</code>方法的参数不是<code>reject</code>抛出的“出错了”这个字符串，而是<code>thenable</code>对象。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><ul><li>将多个 Promise 实例，包装成一个新的 Promise 实例。</li><li>只有每个实例的状态都变成<code>fulfilled</code>，或者其中有一个变为<code>rejected</code>，才会调用<code>Promise.all</code>方法后面的回调函数。</li><li>如果作为参数的 Promise 实例，自己定义了<code>catch</code>方法，那么它一旦被<code>rejected</code>，并不会触发<code>Promise.all()</code>的<code>catch</code>方法。</li></ul><p>例如：</p><pre><code class="hljs js"><span class="hljs-comment">// 生成一个Promise对象的数组</span><span class="hljs-keyword">const</span> promises = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id</span>) </span>&#123;  <span class="hljs-keyword">return</span> getJSON(<span class="hljs-string">'/post/'</span> + id + <span class="hljs-string">".json"</span>);&#125;);<span class="hljs-built_in">Promise</span>.all(promises).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">posts</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>)</span>&#123;  <span class="hljs-comment">// ...</span>&#125;);</code></pre><h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><ul><li>将多个 <code>Promise</code> 实例，包装成一个新的 <code>Promise</code> 实例。</li><li>率先改变的 <code>Promise</code> 实例的返回值就传给<code>P</code>的回调函数。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p><strong>ES9的标准，用于指定不管 Promise 对象最后状态如何，都会执行的操作。</strong></p><p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p><p><code>finally</code>本质上是<code>then</code>方法的特例。</p><pre><code class="hljs javascript">promise.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-comment">// 语句</span>&#125;);<span class="hljs-comment">// 等同于</span>promise.then(  result =&gt; &#123;    <span class="hljs-comment">// 语句</span>    <span class="hljs-keyword">return</span> result;  &#125;,  error =&gt; &#123;    <span class="hljs-comment">// 语句</span>    <span class="hljs-keyword">throw</span> error;  &#125;);</code></pre><p>实现方法</p><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;  <span class="hljs-keyword">let</span> P = <span class="hljs-keyword">this</span>.constructor;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(    value  =&gt; P.resolve(callback()).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> value),    reason =&gt; P.resolve(callback()).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;)  );&#125;;</code></pre><h1 id="async-await"><a href="#async-await" class="headerlink" title="async,await"></a>async,await</h1><p>为了解决<code>promise.then</code>过多导致代码可读性变差问题，在ES7中发布了<code>async,await</code>。使用<code>async,await</code>就可以将异步代码转换为同步代码。</p><ul><li><code>async</code>就是将函数返回值使用<code>Promise.resolve()</code>包裹了下，和<code>then</code>中处理返回值一样，并且<code>await</code>只能配套<code>async</code>使用。</li><li><code>await</code>就是<code>generator</code>加上<code>Promise</code>的语法糖，且内部实现了自动执行<code>generator</code>。</li><li><code>await</code> 将异步代码改造成同步代码，<strong>如果多个异步操作没有依赖性而使用 await 会导致性能上的降低，所以不能滥用。</strong></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实<code>Promise</code>的原理并不算太复杂，但是理解起来有一定难度，一般来讲只要会用就可以了，如果有闲心的话再去研究。</p><p>但是<code>Promise</code>是面试的时候的一个重点问题，所以还是建议多看看资料，其实这种原理性的问题，对于我来说，几天不看就忘记了…</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p><p><a href="https://juejin.im/post/5b32f552f265da59991155f0" target="_blank" rel="noopener">https://juejin.im/post/5b32f552f265da59991155f0</a></p><p><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/promise</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ES6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月07日</title>
    <link href="/2020/07/08/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8807%E6%97%A5/"/>
    <url>/2020/07/08/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8807%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><ul><li>今日新增关键词：<code>光遇</code>。</li><li>将<code>龙之谷2</code>移到手游榜。</li></ul><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>69035</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>59297</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>25834</td></tr><tr><td>4</td><td>梦幻西游 ↑2</td><td>16810</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>15927</td></tr><tr><td>6</td><td>地下城与勇士+dnf ↑3</td><td>14210</td></tr><tr><td>7</td><td>天龙八部 ↓3</td><td>13372</td></tr><tr><td>8</td><td>刀塔2+DOTA2</td><td>12400</td></tr><tr><td>9</td><td>最终幻想14+ff14 ↓2</td><td>12356</td></tr><tr><td>10</td><td>魔兽世界+wow ↑1</td><td>10418</td></tr><tr><td>11</td><td>csgo ↓1</td><td>10094</td></tr><tr><td>12</td><td>炉石传说 ↑2</td><td>9386</td></tr><tr><td>13</td><td>激战2 ↑4</td><td>9002</td></tr><tr><td>14</td><td>方舟生存进化 ↑2</td><td>8667</td></tr><tr><td>15</td><td>坦克世界</td><td>8549</td></tr><tr><td>16</td><td>冒险岛 ↓3</td><td>8137</td></tr><tr><td>17</td><td>守望先锋 ↑1</td><td>6394</td></tr><tr><td>18</td><td>龙之谷 ↑3</td><td>6293</td></tr><tr><td>19</td><td>逆水寒</td><td>6143</td></tr><tr><td>20</td><td>诛仙</td><td>5768</td></tr><tr><td>21</td><td>变形金刚 ↑2</td><td>5323</td></tr><tr><td>22</td><td>星际战甲+warframe ↑2</td><td>5184</td></tr><tr><td>23</td><td>EVE ↓1</td><td>4957</td></tr><tr><td>24</td><td>大话西游 ↑1</td><td>4772</td></tr><tr><td>25</td><td>龙族 ↑1</td><td>4604</td></tr><tr><td>26</td><td>流放之路 ↑1</td><td>4589</td></tr><tr><td>27</td><td>传奇 ↑2</td><td>4523</td></tr><tr><td>28</td><td>QQ飞车</td><td>4345</td></tr><tr><td>29</td><td>剑灵 ↑new</td><td>4109</td></tr><tr><td>30</td><td>apex+apex英雄</td><td>4020</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>111788</td></tr><tr><td>2</td><td>和平精英</td><td>60330</td></tr><tr><td>3</td><td>我的世界+mc</td><td>59179</td></tr><tr><td>4</td><td>迷你世界</td><td>54585</td></tr><tr><td>5</td><td>荒野乱斗</td><td>42056</td></tr><tr><td>6</td><td>江南百景图</td><td>33311</td></tr><tr><td>7</td><td>香肠派对</td><td>28246</td></tr><tr><td>8</td><td>最强蜗牛</td><td>20536</td></tr><tr><td>9</td><td>第五人格</td><td>15893</td></tr><tr><td>10</td><td>阴阳师 ↑1</td><td>14152</td></tr><tr><td>11</td><td>妖神记 ↓1</td><td>12572</td></tr><tr><td>12</td><td>球球大作战</td><td>11628</td></tr><tr><td>13</td><td>光遇 ↑new</td><td>10624</td></tr><tr><td>14</td><td>部落冲突</td><td>9610</td></tr><tr><td>15</td><td>炉石传说 ↑1</td><td>9386</td></tr><tr><td>16</td><td>明日之后 ↓1</td><td>9161</td></tr><tr><td>17</td><td>新神魔大陆 ↓4</td><td>8875</td></tr><tr><td>18</td><td>龙之谷2 ↑new</td><td>7943</td></tr><tr><td>19</td><td>崩坏3 ↓2</td><td>7885</td></tr><tr><td>20</td><td>欢乐斗地主 ↓2</td><td>7413</td></tr><tr><td>21</td><td>灌篮高手 ↓2</td><td>7123</td></tr><tr><td>22</td><td>剑与远征 ↓1</td><td>6228</td></tr><tr><td>23</td><td>火影忍者手游 ↓3</td><td>5651</td></tr><tr><td>24</td><td>神魔大陆 ↓2</td><td>5348</td></tr><tr><td>25</td><td>狼人杀</td><td>5304</td></tr><tr><td>26</td><td>碧蓝航线 ↓3</td><td>5190</td></tr><tr><td>27</td><td>饥荒 ↓3</td><td>5109</td></tr><tr><td>28</td><td>率土之滨 ↓1</td><td>4908</td></tr><tr><td>29</td><td>梦幻西游手游 ↓1</td><td>4816</td></tr><tr><td>30</td><td>大话西游 ↓4</td><td>4772</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月06日</title>
    <link href="/2020/07/07/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8806%E6%97%A5/"/>
    <url>/2020/07/07/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8806%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>72235</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>58718</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>24968</td></tr><tr><td>4</td><td>天龙八部 ↑2</td><td>20691</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>14984</td></tr><tr><td>6</td><td>梦幻西游 ↑2</td><td>14423</td></tr><tr><td>7</td><td>最终幻想14+ff14 ↑2</td><td>13987</td></tr><tr><td>8</td><td>刀塔2+DOTA2 ↑2</td><td>13184</td></tr><tr><td>9</td><td>地下城与勇士+dnf ↓2</td><td>12157</td></tr><tr><td>10</td><td>csgo ↑1</td><td>10522</td></tr><tr><td>11</td><td>魔兽世界+wow ↑2</td><td>10318</td></tr><tr><td>12</td><td>魔域 ↓8</td><td>10073</td></tr><tr><td>13</td><td>冒险岛 ↑4</td><td>9185</td></tr><tr><td>14</td><td>炉石传说</td><td>9019</td></tr><tr><td>15</td><td>坦克世界</td><td>8284</td></tr><tr><td>16</td><td>方舟生存进化 ↓4</td><td>8119</td></tr><tr><td>17</td><td>激战2 ↓1</td><td>7779</td></tr><tr><td>18</td><td>守望先锋</td><td>6791</td></tr><tr><td>19</td><td>逆水寒 ↑1</td><td>6407</td></tr><tr><td>20</td><td>诛仙 ↑1</td><td>5976</td></tr><tr><td>21</td><td>龙之谷 ↑6</td><td>5655</td></tr><tr><td>22</td><td>EVE ↑4</td><td>5350</td></tr><tr><td>23</td><td>变形金刚 ↓4</td><td>5322</td></tr><tr><td>24</td><td>星际战甲+warframe ↑1</td><td>5109</td></tr><tr><td>25</td><td>大话西游 ↓3</td><td>5052</td></tr><tr><td>26</td><td>龙族 ↓2</td><td>4829</td></tr><tr><td>27</td><td>流放之路 ↑2</td><td>4725</td></tr><tr><td>28</td><td>QQ飞车 ↓5</td><td>4435</td></tr><tr><td>29</td><td>传奇 ↓1</td><td>4431</td></tr><tr><td>30</td><td>apex+apex英雄 ↑new</td><td>4384</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>110848</td></tr><tr><td>2</td><td>和平精英 ↑1</td><td>59846</td></tr><tr><td>3</td><td>我的世界+mc ↑1</td><td>58735</td></tr><tr><td>4</td><td>迷你世界 ↓2</td><td>54779</td></tr><tr><td>5</td><td>荒野乱斗</td><td>47589</td></tr><tr><td>6</td><td>江南百景图 ↑1</td><td>33408</td></tr><tr><td>7</td><td>香肠派对 ↓1</td><td>28095</td></tr><tr><td>8</td><td>最强蜗牛</td><td>22062</td></tr><tr><td>9</td><td>第五人格</td><td>16126</td></tr><tr><td>10</td><td>妖神记</td><td>13530</td></tr><tr><td>11</td><td>阴阳师 ↑3</td><td>12908</td></tr><tr><td>12</td><td>球球大作战 ↓1</td><td>11910</td></tr><tr><td>13</td><td>新神魔大陆 ↑2</td><td>10461</td></tr><tr><td>14</td><td>部落冲突 ↓1</td><td>10080</td></tr><tr><td>15</td><td>明日之后 ↓3</td><td>9213</td></tr><tr><td>16</td><td>炉石传说</td><td>9019</td></tr><tr><td>17</td><td>崩坏3</td><td>8370</td></tr><tr><td>18</td><td>欢乐斗地主</td><td>7874</td></tr><tr><td>19</td><td>灌篮高手</td><td>7165</td></tr><tr><td>20</td><td>火影忍者手游 ↑3</td><td>6471</td></tr><tr><td>21</td><td>剑与远征 ↑1</td><td>6470</td></tr><tr><td>22</td><td>神魔大陆 ↓2</td><td>6355</td></tr><tr><td>23</td><td>碧蓝航线 ↑1</td><td>5461</td></tr><tr><td>24</td><td>饥荒 ↑1</td><td>5388</td></tr><tr><td>25</td><td>狼人杀 ↓4</td><td>5257</td></tr><tr><td>26</td><td>大话西游</td><td>5052</td></tr><tr><td>27</td><td>率土之滨</td><td>4887</td></tr><tr><td>28</td><td>梦幻西游手游 ↑1</td><td>4724</td></tr><tr><td>29</td><td>开心消消乐 ↓1</td><td>4417</td></tr><tr><td>30</td><td>奇迹暖暖</td><td>3570</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月05日</title>
    <link href="/2020/07/06/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8805%E6%97%A5/"/>
    <url>/2020/07/06/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8805%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>75328</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>74456</td></tr><tr><td>3</td><td>穿越火线+cf</td><td>28563</td></tr><tr><td>4</td><td>魔域</td><td>17130</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>16474</td></tr><tr><td>6</td><td>天龙八部</td><td>14628</td></tr><tr><td>7</td><td>地下城与勇士+dnf</td><td>14200</td></tr><tr><td>8</td><td>梦幻西游</td><td>12514</td></tr><tr><td>9</td><td>最终幻想14+ff14</td><td>12163</td></tr><tr><td>10</td><td>刀塔2+DOTA2</td><td>10774</td></tr><tr><td>11</td><td>csgo</td><td>10360</td></tr><tr><td>12</td><td>方舟生存进化</td><td>10302</td></tr><tr><td>13</td><td>魔兽世界+wow</td><td>9992</td></tr><tr><td>14</td><td>炉石传说</td><td>9377</td></tr><tr><td>15</td><td>坦克世界</td><td>8915</td></tr><tr><td>16</td><td>激战2</td><td>8581</td></tr><tr><td>17</td><td>冒险岛</td><td>8365</td></tr><tr><td>18</td><td>守望先锋</td><td>7685</td></tr><tr><td>19</td><td>变形金刚</td><td>6745</td></tr><tr><td>20</td><td>逆水寒</td><td>6433</td></tr><tr><td>21</td><td>诛仙</td><td>6218</td></tr><tr><td>22</td><td>大话西游</td><td>5600</td></tr><tr><td>23</td><td>QQ飞车</td><td>5311</td></tr><tr><td>24</td><td>龙族</td><td>5263</td></tr><tr><td>25</td><td>星际战甲+warframe</td><td>5201</td></tr><tr><td>26</td><td>EVE</td><td>5066</td></tr><tr><td>27</td><td>龙之谷</td><td>4989</td></tr><tr><td>28</td><td>传奇</td><td>4827</td></tr><tr><td>29</td><td>流放之路</td><td>4698</td></tr><tr><td>30</td><td>使命召唤16+cod16</td><td>4250</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>124290</td></tr><tr><td>2</td><td>迷你世界</td><td>77855</td></tr><tr><td>3</td><td>和平精英</td><td>77662</td></tr><tr><td>4</td><td>我的世界+mc</td><td>74095</td></tr><tr><td>5</td><td>荒野乱斗</td><td>45632</td></tr><tr><td>6</td><td>香肠派对</td><td>41660</td></tr><tr><td>7</td><td>江南百景图</td><td>29791</td></tr><tr><td>8</td><td>最强蜗牛</td><td>23152</td></tr><tr><td>9</td><td>第五人格</td><td>19547</td></tr><tr><td>10</td><td>妖神记 ↑2</td><td>17134</td></tr><tr><td>11</td><td>球球大作战</td><td>15512</td></tr><tr><td>12</td><td>明日之后 ↑3</td><td>15060</td></tr><tr><td>13</td><td>部落冲突 ↓3</td><td>13579</td></tr><tr><td>14</td><td>阴阳师 ↓1</td><td>12828</td></tr><tr><td>15</td><td>新神魔大陆 ↓1</td><td>11295</td></tr><tr><td>16</td><td>炉石传说 ↑1</td><td>9377</td></tr><tr><td>17</td><td>崩坏3 ↓1</td><td>8707</td></tr><tr><td>18</td><td>欢乐斗地主</td><td>8387</td></tr><tr><td>19</td><td>灌篮高手</td><td>7620</td></tr><tr><td>20</td><td>神魔大陆 ↑2</td><td>6586</td></tr><tr><td>21</td><td>狼人杀 ↓1</td><td>6236</td></tr><tr><td>22</td><td>剑与远征 ↓1</td><td>5900</td></tr><tr><td>23</td><td>火影忍者手游 ↑3</td><td>5870</td></tr><tr><td>24</td><td>碧蓝航线</td><td>5735</td></tr><tr><td>25</td><td>饥荒</td><td>5703</td></tr><tr><td>26</td><td>大话西游 ↓3</td><td>5600</td></tr><tr><td>27</td><td>率土之滨</td><td>4845</td></tr><tr><td>28</td><td>开心消消乐 ↑1</td><td>4395</td></tr><tr><td>29</td><td>梦幻西游手游 ↓1</td><td>4309</td></tr><tr><td>30</td><td>奇迹暖暖</td><td>4173</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月04日</title>
    <link href="/2020/07/05/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8804%E6%97%A5/"/>
    <url>/2020/07/05/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8804%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>我的世界+minecraft ↑1</td><td>77381</td></tr><tr><td>2</td><td>英雄联盟+lol ↓1</td><td>76364</td></tr><tr><td>3</td><td>穿越火线+cf ↑1</td><td>36483</td></tr><tr><td>4</td><td>魔域 ↓1</td><td>20714</td></tr><tr><td>5</td><td>绝地求生+pubg ↑2</td><td>16996</td></tr><tr><td>6</td><td>天龙八部 ↑7</td><td>15525</td></tr><tr><td>7</td><td>地下城与勇士+dnf ↓2</td><td>15453</td></tr><tr><td>8</td><td>梦幻西游</td><td>12897</td></tr><tr><td>9</td><td>最终幻想14+ff14</td><td>12128</td></tr><tr><td>10</td><td>刀塔2+DOTA2 ↓4</td><td>11960</td></tr><tr><td>11</td><td>csgo ↑1</td><td>10806</td></tr><tr><td>12</td><td>魔兽世界+wow ↓1</td><td>10414</td></tr><tr><td>13</td><td>方舟生存进化 ↑4</td><td>10126</td></tr><tr><td>14</td><td>炉石传说 ↑2</td><td>9458</td></tr><tr><td>15</td><td>坦克世界</td><td>9335</td></tr><tr><td>16</td><td>冒险岛 ↓2</td><td>9043</td></tr><tr><td>17</td><td>激战2 ↓7</td><td>8744</td></tr><tr><td>18</td><td>守望先锋 ↑1</td><td>7895</td></tr><tr><td>19</td><td>变形金刚 ↑4</td><td>6605</td></tr><tr><td>20</td><td>逆水寒 ↑2</td><td>6049</td></tr><tr><td>21</td><td>诛仙</td><td>5888</td></tr><tr><td>22</td><td>QQ飞车 ↑4</td><td>5817</td></tr><tr><td>23</td><td>大话西游 ↑2</td><td>5792</td></tr><tr><td>24</td><td>龙之谷 ↓4</td><td>5273</td></tr><tr><td>25</td><td>星际战甲+warframe ↑new</td><td>5240</td></tr><tr><td>26</td><td>EVE ↓8</td><td>5197</td></tr><tr><td>27</td><td>流放之路 ↓3</td><td>5005</td></tr><tr><td>28</td><td>龙族</td><td>4864</td></tr><tr><td>29</td><td>传奇 ↓2</td><td>4725</td></tr><tr><td>30</td><td>使命召唤16+cod16</td><td>4264</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>124757</td></tr><tr><td>2</td><td>迷你世界 ↑2</td><td>80834</td></tr><tr><td>3</td><td>和平精英 ↓1</td><td>80351</td></tr><tr><td>4</td><td>我的世界+mc ↓1</td><td>76913</td></tr><tr><td>5</td><td>荒野乱斗</td><td>50371</td></tr><tr><td>6</td><td>香肠派对</td><td>44688</td></tr><tr><td>7</td><td>江南百景图 ↑1</td><td>29005</td></tr><tr><td>8</td><td>最强蜗牛 ↓1</td><td>23868</td></tr><tr><td>9</td><td>第五人格 ↑1</td><td>20343</td></tr><tr><td>10</td><td>部落冲突 ↑3</td><td>15926</td></tr><tr><td>11</td><td>球球大作战 ↑3</td><td>15257</td></tr><tr><td>12</td><td>妖神记</td><td>14788</td></tr><tr><td>13</td><td>阴阳师 ↓2</td><td>12597</td></tr><tr><td>14</td><td>新神魔大陆 ↓5</td><td>11453</td></tr><tr><td>15</td><td>明日之后 ↑1</td><td>11219</td></tr><tr><td>16</td><td>崩坏3 ↓1</td><td>9590</td></tr><tr><td>17</td><td>炉石传说</td><td>9458</td></tr><tr><td>18</td><td>欢乐斗地主 ↑2</td><td>8009</td></tr><tr><td>19</td><td>灌篮高手</td><td>7883</td></tr><tr><td>20</td><td>狼人杀 ↑2</td><td>6934</td></tr><tr><td>21</td><td>剑与远征</td><td>6634</td></tr><tr><td>22</td><td>神魔大陆 ↓4</td><td>6290</td></tr><tr><td>23</td><td>大话西游 ↑3</td><td>5792</td></tr><tr><td>24</td><td>碧蓝航线 ↑3</td><td>5728</td></tr><tr><td>25</td><td>饥荒 ↑4</td><td>5418</td></tr><tr><td>26</td><td>火影忍者手游 ↓1</td><td>5079</td></tr><tr><td>27</td><td>率土之滨 ↓3</td><td>4929</td></tr><tr><td>28</td><td>梦幻西游手游 ↓5</td><td>4799</td></tr><tr><td>29</td><td>开心消消乐 ↓1</td><td>4543</td></tr><tr><td>30</td><td>奇迹暖暖</td><td>4471</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月03日</title>
    <link href="/2020/07/04/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8803%E6%97%A5/"/>
    <url>/2020/07/04/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8803%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>71367</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>56721</td></tr><tr><td>3</td><td>魔域 ↑2</td><td>42330</td></tr><tr><td>4</td><td>穿越火线+cf</td><td>24765</td></tr><tr><td>5</td><td>地下城与勇士+dnf ↓2</td><td>24169</td></tr><tr><td>6</td><td>刀塔2+DOTA2 ↑3</td><td>14436</td></tr><tr><td>7</td><td>绝地求生+pubg</td><td>14387</td></tr><tr><td>8</td><td>梦幻西游 ↓2</td><td>12976</td></tr><tr><td>9</td><td>最终幻想14+ff14 ↓1</td><td>12277</td></tr><tr><td>10</td><td>激战2 ↑4</td><td>11026</td></tr><tr><td>11</td><td>魔兽世界+wow</td><td>10555</td></tr><tr><td>12</td><td>csgo</td><td>10483</td></tr><tr><td>13</td><td>天龙八部</td><td>10314</td></tr><tr><td>14</td><td>冒险岛 ↓4</td><td>9992</td></tr><tr><td>15</td><td>坦克世界</td><td>8811</td></tr><tr><td>16</td><td>炉石传说</td><td>8586</td></tr><tr><td>17</td><td>方舟生存进化 ↑2</td><td>8095</td></tr><tr><td>18</td><td>EVE ↓1</td><td>6823</td></tr><tr><td>19</td><td>守望先锋 ↑1</td><td>6636</td></tr><tr><td>20</td><td>龙之谷 ↑1</td><td>6021</td></tr><tr><td>21</td><td>诛仙 ↑1</td><td>5962</td></tr><tr><td>22</td><td>逆水寒 ↓4</td><td>5743</td></tr><tr><td>23</td><td>变形金刚 ↑3</td><td>5257</td></tr><tr><td>24</td><td>流放之路</td><td>5017</td></tr><tr><td>25</td><td>大话西游 ↑2</td><td>4879</td></tr><tr><td>26</td><td>QQ飞车 ↓3</td><td>4831</td></tr><tr><td>27</td><td>传奇 ↑1</td><td>4474</td></tr><tr><td>28</td><td>龙族 ↑2</td><td>4149</td></tr><tr><td>29</td><td>apex+apex英雄 ↑new</td><td>4148</td></tr><tr><td>30</td><td>使命召唤16+cod16 ↑new</td><td>4040</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>107557</td></tr><tr><td>2</td><td>和平精英</td><td>61364</td></tr><tr><td>3</td><td>我的世界+mc</td><td>56675</td></tr><tr><td>4</td><td>迷你世界</td><td>56316</td></tr><tr><td>5</td><td>荒野乱斗 ↑3</td><td>31628</td></tr><tr><td>6</td><td>香肠派对</td><td>28712</td></tr><tr><td>7</td><td>最强蜗牛 ↓2</td><td>28087</td></tr><tr><td>8</td><td>江南百景图 ↑1</td><td>26095</td></tr><tr><td>9</td><td>新神魔大陆 ↓2</td><td>15340</td></tr><tr><td>10</td><td>第五人格</td><td>15251</td></tr><tr><td>11</td><td>阴阳师</td><td>12716</td></tr><tr><td>12</td><td>妖神记</td><td>12714</td></tr><tr><td>13</td><td>部落冲突</td><td>12033</td></tr><tr><td>14</td><td>球球大作战 ↑1</td><td>11152</td></tr><tr><td>15</td><td>崩坏3 ↑6</td><td>10167</td></tr><tr><td>16</td><td>明日之后 ↑2</td><td>8831</td></tr><tr><td>17</td><td>炉石传说 ↓1</td><td>8586</td></tr><tr><td>18</td><td>神魔大陆 ↓4</td><td>7769</td></tr><tr><td>19</td><td>灌篮高手</td><td>7725</td></tr><tr><td>20</td><td>欢乐斗地主 ↓3</td><td>7645</td></tr><tr><td>21</td><td>剑与远征 ↓1</td><td>7239</td></tr><tr><td>22</td><td>狼人杀 ↑3</td><td>5759</td></tr><tr><td>23</td><td>梦幻西游手游 ↑3</td><td>5358</td></tr><tr><td>24</td><td>率土之滨 ↓1</td><td>5240</td></tr><tr><td>25</td><td>火影忍者手游 ↑4</td><td>5167</td></tr><tr><td>26</td><td>大话西游 ↑1</td><td>4879</td></tr><tr><td>27</td><td>碧蓝航线 ↓3</td><td>4647</td></tr><tr><td>28</td><td>开心消消乐 ↓6</td><td>4568</td></tr><tr><td>29</td><td>饥荒 ↑1</td><td>4238</td></tr><tr><td>30</td><td>奇迹暖暖 ↑new</td><td>3595</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月02日</title>
    <link href="/2020/07/03/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8802%E6%97%A5/"/>
    <url>/2020/07/03/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8802%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>71535</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>50651</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>26400</td></tr><tr><td>4</td><td>穿越火线+cf</td><td>23339</td></tr><tr><td>5</td><td>魔域 ↑4</td><td>21921</td></tr><tr><td>6</td><td>梦幻西游</td><td>13886</td></tr><tr><td>7</td><td>绝地求生+pubg ↑1</td><td>13435</td></tr><tr><td>8</td><td>最终幻想14+ff14 ↓3</td><td>13169</td></tr><tr><td>9</td><td>刀塔2+DOTA2 ↑1</td><td>12346</td></tr><tr><td>10</td><td>冒险岛 ↓3</td><td>11180</td></tr><tr><td>11</td><td>魔兽世界+wow</td><td>11128</td></tr><tr><td>12</td><td>csgo ↑1</td><td>10138</td></tr><tr><td>13</td><td>天龙八部 ↓1</td><td>9902</td></tr><tr><td>14</td><td>激战2 ↑2</td><td>9653</td></tr><tr><td>15</td><td>坦克世界 ↓1</td><td>9038</td></tr><tr><td>16</td><td>炉石传说 ↓1</td><td>8594</td></tr><tr><td>17</td><td>EVE ↑6</td><td>8433</td></tr><tr><td>18</td><td>逆水寒</td><td>7576</td></tr><tr><td>19</td><td>方舟生存进化 ↓2</td><td>7502</td></tr><tr><td>20</td><td>守望先锋 ↓1</td><td>6404</td></tr><tr><td>21</td><td>龙之谷 ↓1</td><td>6288</td></tr><tr><td>22</td><td>诛仙 ↓1</td><td>6188</td></tr><tr><td>23</td><td>QQ飞车 ↓1</td><td>6097</td></tr><tr><td>24</td><td>流放之路</td><td>5450</td></tr><tr><td>25</td><td>跑跑卡丁车 ↑new</td><td>5213</td></tr><tr><td>26</td><td>变形金刚 ↓1</td><td>5045</td></tr><tr><td>27</td><td>大话西游 ↑1</td><td>4730</td></tr><tr><td>28</td><td>传奇 ↓1</td><td>4385</td></tr><tr><td>29</td><td>剑灵</td><td>4206</td></tr><tr><td>30</td><td>龙族 ↑new</td><td>4190</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>97978</td></tr><tr><td>2</td><td>和平精英</td><td>55671</td></tr><tr><td>3</td><td>我的世界+mc</td><td>50868</td></tr><tr><td>4</td><td>迷你世界</td><td>50053</td></tr><tr><td>5</td><td>最强蜗牛</td><td>24085</td></tr><tr><td>6</td><td>香肠派对</td><td>22961</td></tr><tr><td>7</td><td>新神魔大陆 ↑new</td><td>19979</td></tr><tr><td>8</td><td>荒野乱斗 ↓1</td><td>19526</td></tr><tr><td>9</td><td>江南百景图 ↑new</td><td>14737</td></tr><tr><td>10</td><td>第五人格</td><td>14556</td></tr><tr><td>11</td><td>阴阳师 ↓3</td><td>12989</td></tr><tr><td>12</td><td>妖神记 ↓3</td><td>12858</td></tr><tr><td>13</td><td>部落冲突 ↓1</td><td>11975</td></tr><tr><td>14</td><td>神魔大陆 ↑13</td><td>10827</td></tr><tr><td>15</td><td>球球大作战 ↓2</td><td>9628</td></tr><tr><td>16</td><td>炉石传说 ↓2</td><td>8594</td></tr><tr><td>17</td><td>欢乐斗地主 ↑1</td><td>8063</td></tr><tr><td>18</td><td>明日之后 ↓1</td><td>7883</td></tr><tr><td>19</td><td>灌篮高手 ↓4</td><td>7767</td></tr><tr><td>20</td><td>剑与远征 ↓4</td><td>7723</td></tr><tr><td>21</td><td>崩坏3 ↓2</td><td>7355</td></tr><tr><td>22</td><td>开心消消乐 ↓1</td><td>5342</td></tr><tr><td>23</td><td>率土之滨 ↓3</td><td>5320</td></tr><tr><td>24</td><td>碧蓝航线 ↑1</td><td>5252</td></tr><tr><td>25</td><td>狼人杀 ↓2</td><td>5199</td></tr><tr><td>26</td><td>梦幻西游手游 ↓15</td><td>4917</td></tr><tr><td>27</td><td>大话西游 ↓3</td><td>4730</td></tr><tr><td>28</td><td>影之诗 ↑new</td><td>4686</td></tr><tr><td>29</td><td>火影忍者手游 ↓7</td><td>4576</td></tr><tr><td>30</td><td>饥荒 ↓4</td><td>3890</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/学习前端如何将自己的页面部署到服务器</title>
    <link href="/2020/07/03/web%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2020/07/03/web%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A1%B5%E9%9D%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>本篇文章的视频地址：</p><div style="position: relative; padding: 35% 45%;"><iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"  src="//player.bilibili.com/player.html?aid=926161323&bvid=BV1HT4y1774Y&cid=208735231&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> ></iframe></div><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信前端的初学者在学习到一定的地步时，都会想将自己做的网页向人家进行展示，但是如何进行展示呢？是直接将网页的静态文件发送给别人？还是说给他地址，让他直接在浏览器上面进行查看。</p><p>当然是直接通过域名访问你做的网页更加的人性化！因为你就算给他静态文件，他也不一定会使用。</p><p>那么如何将自己的网页部署上线呢？</p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>这种方法无成本，只需要注册一个GitHub账号，具体可以看这篇文章：</p><a href="/2020/05/04/%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%92%8C%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7/" title="部署到Github-Pages上的博客，自定义域名，和免费域名如何申请">部署到Github-Pages上的博客，自定义域名，和免费域名如何申请</a><p><br/>当然，这种方式虽然免费，但是有一个严重的缺陷，就是<strong>国内的访问速度有时候会非常慢，图片会有一个很长的加载时间，或者打开网页的响应时间会很长。</strong></p><h2 id="虚拟服务器"><a href="#虚拟服务器" class="headerlink" title="虚拟服务器"></a>虚拟服务器</h2><blockquote><p>虚拟专用服务器，是将一台服务器分割成多个虚拟专用服务器的服务。实现VPS的技术分为容器技术和虚拟机技术。在容器或虚拟机中，每个VPS都可分配独立公网IP地址、独立操作系统、实现不同VPS间磁盘空间、内存、CPU资源、进程和系统配置的隔离，为用户和应用程序模拟出“独占”使用计算资源的体验。</p></blockquote><p>国内有腾讯云，阿里云，京东云等云服务器，但是国内的服务器如果要解析域名就必须进行备案。如果不进行备案，你通过服务器的公网IP也是能够访问到该服务器的，但是公网IP不便于记忆的同时，还显得跟<strong>暗网</strong>一样，让人家不敢打开。</p><h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><p>因为我有一台阿里云服务器，也曾经备案过，简单的说就是阿里云在备案时需要填写相关的资料并且提交后，如果不合格，会有客服打电话过来告诉你哪儿不合格，然后你按照他所描述的地方进行修改后再提交。</p><p>如果第一关客服关过了后，就需要等待相关部门的审核，当时我的服务器审核了大概1个多星期。</p><h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><p>如果购买的是国外的VPS，那么可以直接进行域名解析，是不用备案的，同时<code>VPS</code>的系统推荐使用<code>centos</code>。</p><p>但是国外的VPS可能存在连接<strong>不稳定，丢包，甚至无法进行访问的情况</strong>，而国内的VPS<strong>访问速度还是有保障的，基本可以跑满VPS的带宽</strong>。</p><p>所以是选择国内的VPS还是选择国外的VPS，还是根据自己的情况进行判断。</p><h1 id="连接VPS"><a href="#连接VPS" class="headerlink" title="连接VPS"></a>连接VPS</h1><p>那么服务器有了，我们就需要连接VPS的工具，这里推荐使用<code>FinalShell</code>，<code>Xshell</code>两种工具。</p><p><a href="https://www.hostbuf.com/t/988.html" target="_blank" rel="noopener">FinalShell下载</a></p><p><a href="https://www.netsarang.com/zh/xshell-download/" target="_blank" rel="noopener">Xshell下载</a></p><h1 id="安装宝塔面板"><a href="#安装宝塔面板" class="headerlink" title="安装宝塔面板"></a>安装宝塔面板</h1><p>首先我们需要通过<code>FinalShell</code>工具连接一下我们的VPS。</p><p><img src="/image/image-20200704110550648.png" srcset="/img/loading.gif" alt="image-20200704110550648"></p><p>然后，安装一下宝塔面板：<a href="https://bt.cn/bbs/thread-19376-1-1.html" target="_blank" rel="noopener">宝塔面板的安装方法</a>。</p><p>宝塔面板是非常好用的一个面板，可以大大简化我们部署个人博客的难度。根据文档中的提示，一步步进行安装，当安装结束后会弹出链接，用户名，密码。</p><p><img src="/image/image-20200704103025773.png" srcset="/img/loading.gif" alt="image-20200704103025773"></p><p>最后通过浏览器打开面板地址。</p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>域名可以选择免费的域名，至于免费的域名如何申请，在<a href="/2020/05/04/%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%92%8C%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7/" title="部署到Github-Pages上的博客，自定义域名，和免费域名如何申请">部署到Github-Pages上的博客，自定义域名，和免费域名如何申请</a>中有提到。</p><h1 id="部署网页"><a href="#部署网页" class="headerlink" title="部署网页"></a>部署网页</h1><p>在宝塔面板中<code>网站</code>-<code>添加网站</code>。</p><p><img src="/image/image-20200704105145466.png" srcset="/img/loading.gif" alt="image-20200704105145466"></p><p>填写进自己的域名。提交后访问一下域名，如果出现：</p><p><img src="/image/image-20200704105003618.png" srcset="/img/loading.gif" alt="image-20200704105003618"></p><p>上面这个界面，说明域名解析已经成功，并且可以开始上传自己的网页。</p><p><img src="/image/image-20200704105242692.png" srcset="/img/loading.gif" alt="image-20200704105242692"></p><p>通过Finalshell工具，来到添加站点中的根目录，将自己的网页放到这个目录就大功告成了。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>域名</tag>
      
      <tag>GitHub Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/更加实用的Grid布局</title>
    <link href="/2020/07/02/web%E5%BC%80%E5%8F%91/%E6%9B%B4%E5%8A%A0%E5%AE%9E%E7%94%A8%E7%9A%84Grid%E5%B8%83%E5%B1%80/"/>
    <url>/2020/07/02/web%E5%BC%80%E5%8F%91/%E6%9B%B4%E5%8A%A0%E5%AE%9E%E7%94%A8%E7%9A%84Grid%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>之前有一篇文章是讲解<code>CSS</code>中的<code>Flex</code>布局</p><a href="/2020/07/01/web%E5%BC%80%E5%8F%91/%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84Flex%E5%B8%83%E5%B1%80/" title="非常实用的Flex布局">非常实用的Flex布局</a><p><br/>所以本篇文章要讲解另一个更为强大的布局方式<code>Grid</code>。</p><h1 id="1-入门"><a href="#1-入门" class="headerlink" title="1. 入门"></a>1. 入门</h1><p>在早期的网页布局中，如果要实现非常复杂的布局是很麻烦的事情，只有通过<code>CSS</code>框架，或者自行花费大量的时间去写相关的<code>CSS</code>样式，所以在10年以前，网页的页面布局都非常的简陋。</p><p><code>Flex</code>和<code>Grid</code>非常的相似，同时也存在着非常大的不同，简单的来说<code>Flex</code>更适合用在单行的布局上，而多行布局使用<code>Flex</code>虽然能够实现，但是非常的麻烦。</p><p><code>Grid</code>的拿手好戏就是多行布局，它可以将容器划分为“行”和“列”，如果有做过控制台开发小游戏的朋友应该清楚，<strong>在一个平面中要做出一个游戏界面，就需要使用二维数组进行布局，而<code>Grid</code>就恰好是“二维布局”。</strong></p><p>正因为<code>Grid</code>是二维布局，所以它远比一维布局的<code>Flex</code>更加的强大。</p><style>  .grid-container {    width: 300px;    background-color: #dbdbdb;    display: grid;  }  .grid-container > div {    border: 1px solid black;    margin: 0 -1px -1px 0;  }  .grid-container > div:hover {    z-index: 1;    border: 2px solid #e20303;  }  .grid-container > div[data-index]::before {    content: attr(data-index);    background-color: #e5a9a9;    color: #fff;    position: absolute;    border-radius: 50%;    width: 20px;    height: 20px;    font-size: 14px;    text-align: center;    line-height: 20px;    z-index: 1;  }  label {    margin-left: 10px;  }</style><h1 id="2-基本概念"><a href="#2-基本概念" class="headerlink" title="2. 基本概念"></a>2. 基本概念</h1><h2 id="2-1-container和item"><a href="#2-1-container和item" class="headerlink" title="2.1 container和item"></a>2.1 container和item</h2><p>跟<code>Flex</code>一样，<code>Grid</code>布局也只对顶层子元素有效，比如：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"item"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>将<code>container</code>设置为<code>Grid</code>，那么<code>Grid</code>布局就仅仅只对<code>item</code>生效，对<code>&lt;p&gt;</code>是不生效的。</p><h2 id="2-2-row和column"><a href="#2-2-row和column" class="headerlink" title="2.2 row和column"></a>2.2 row和column</h2><p>  <code>container</code>中水平区域称为<code>row</code>（行），垂直区域称为<code>column</code>（列）。</p><h2 id="2-3-cell"><a href="#2-3-cell" class="headerlink" title="2.3 cell"></a>2.3 cell</h2><p>  行和列的交叉区域，就称为<code>cell</code>（单元格）。</p><h2 id="2-4-grid-line"><a href="#2-4-grid-line" class="headerlink" title="2.4 grid line"></a>2.4 grid line</h2><p>  划分单元格的线，就称为<code>grid line</code>（网格线），水平网格线划分出行，垂直网格线划分出列。</p><h1 id="3-容器属性"><a href="#3-容器属性" class="headerlink" title="3. 容器属性"></a>3. 容器属性</h1><h2 id="3-1-display属性"><a href="#3-1-display属性" class="headerlink" title="3.1 display属性"></a>3.1 display属性</h2><p>  <code>display: grid</code>指定一个容器采用网格布局。</p><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">display</span>: grid; <span class="hljs-comment">/*块级元素*/</span>    <span class="hljs-attribute">display</span>: inline-grid; <span class="hljs-comment">/*行内元素。*/</span>&#125;</code></pre><p>  <strong>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</strong></p><h2 id="3-2-grid-template-columns-属性，-grid-template-rows-属性"><a href="#3-2-grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="3.2 grid-template-columns 属性， grid-template-rows 属性"></a>3.2 grid-template-columns 属性， grid-template-rows 属性</h2><ul><li><code>grid-template-columns</code>属性定义每一列的列宽。</li><li><code>grid-template-rows</code>属性定义每一行的行高。</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;&#125;</code></pre><div class="grid-container" style="grid-template-columns: 100px 100px 100px;grid-template-rows: 100px 100px 100px;">  <div data-index="1"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div>  <div data-index="7"></div>  <div data-index="8"></div>  <div data-index="9"></div></div><br/><p>除了用绝对单位，也可以设置为容器的百分之多少：</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;&#125;</code></pre><div class="grid-container"     style="width: 300px;height: 300px;grid-template-columns: 33.33% 33.33% 33.33%;grid-template-rows: 33.33% 33.33% 33.33%;">  <div data-index="1"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div>  <div data-index="7"></div>  <div data-index="8"></div>  <div data-index="9"></div></div><h3 id="3-2-1-repeat"><a href="#3-2-1-repeat" class="headerlink" title="3.2.1 repeat()"></a>3.2.1 repeat()</h3><p>上面的代码用<code>repeat()</code>改写如下。</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);&#125;</code></pre><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p>同时所要重复的值可以是多个，例如：</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">50px</span> <span class="hljs-number">30px</span> <span class="hljs-number">60px</span>);    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">50%</span>);&#125;</code></pre><p>效果如下：</p><div class="grid-container"     style="height: 200px;grid-template-columns: repeat(2, 50px 30px 60px);grid-template-rows: repeat(2, 50%);">  <div data-index="1"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div>  <div data-index="7"></div>  <div data-index="8"></div>  <div data-index="9"></div></div><h3 id="3-2-2-auto-fill-关键字"><a href="#3-2-2-auto-fill-关键字" class="headerlink" title="3.2.2 auto-fill 关键字"></a>3.2.2 auto-fill 关键字</h3><p>如果单元格的大小固定，但是容器大小不确定的情况下，使用<code>auto-fill</code>就可以让每行或者每列尽可能多的收纳单元格。</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">2</span>, <span class="hljs-number">50%</span>);&#125;</code></pre><p>点一点看效果：</p><div>  <label>    <input onclick="gridClick('autoFill',value)" type="radio" name="autoFill" value="repeat(auto-fill, 30px)" checked>    grid-template-columns: repeat(auto-fill, 30px);  </label>  <label>    <input onclick="gridClick('autoFill',value)" type="radio" name="autoFill" value="repeat(auto-fill, 40px)">    grid-template-columns: repeat(auto-fill, 40px);  </label>  <label>    <input onclick="gridClick('autoFill',value)" type="radio" name="autoFill" value="repeat(auto-fill, 50px)">    grid-template-columns: repeat(auto-fill, 50px);  </label>  <div id="autoFill" class="grid-container"       style="height: 200px;grid-template-columns: repeat(auto-fill, 30px);grid-template-rows: repeat(2, 50%);">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><h3 id="3-2-3-fr-关键字"><a href="#3-2-3-fr-关键字" class="headerlink" title="3.2.3 fr 关键字"></a>3.2.3 fr 关键字</h3><p><code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);&#125;</code></pre><div>  <label>    <input onclick="gridClick('fr',value)" type="radio" name="fr" value="150px 1fr 2fr" checked> grid-template-columns:    150px 1fr 2fr  </label>  <label>    <input onclick="gridClick('fr',value)" type="radio" name="fr" value="150px 2fr 2fr"> grid-template-columns: 150px    2fr 2fr  </label>  <label>    <input onclick="gridClick('fr',value)" type="radio" name="fr" value="100px 3fr 2fr"> grid-template-columns: 100px    3fr 2fr  </label>  <div id="fr" class="grid-container"       style="height: 300px;grid-template-columns: 150px 1fr 2fr;grid-template-rows: repeat(3, 33.33%);">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><h3 id="3-2-4-minmax"><a href="#3-2-4-minmax" class="headerlink" title="3.2.4 minmax()"></a>3.2.4 minmax()</h3><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-columns</span>: 1<span class="hljs-selector-tag">fr</span> 1<span class="hljs-selector-tag">fr</span> <span class="hljs-selector-tag">minmax</span>(100<span class="hljs-selector-tag">px</span>, 1<span class="hljs-selector-tag">fr</span>);</code></pre><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><h3 id="3-2-5-auto-关键字"><a href="#3-2-5-auto-关键字" class="headerlink" title="3.2.5 auto 关键字"></a>3.2.5 auto 关键字</h3><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">40px</span> auto <span class="hljs-number">40px</span>;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;&#125;</code></pre><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><div class="grid-container" style="grid-template-columns: 40px auto 40px;grid-template-rows: 100px 100px 100px;">  <div data-index="1"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div>  <div data-index="7"></div>  <div data-index="8"></div>  <div data-index="9"></div></div><br/><h3 id="3-2-6-网格线的名称"><a href="#3-2-6-网格线的名称" class="headerlink" title="3.2.6 网格线的名称"></a>3.2.6 网格线的名称</h3><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: [c1] <span class="hljs-number">100px</span> [c2] <span class="hljs-number">100px</span> [c3] auto [c4];    <span class="hljs-attribute">grid-template-rows</span>: [r1] <span class="hljs-number">100px</span> [r2] <span class="hljs-number">100px</span> [r3] auto [r4];&#125;</code></pre><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><h2 id="3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="3.3 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>3.3 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h2><ul><li><code>grid-row-gap</code>属性设置行与行的间隔（行间距）。</li><li><code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</li><li><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式。</li></ul><p>注：现在可以简写成<code>row-gap</code>、<code>column-gap</code>、<code>gap</code>。</p><p>点一点看效果：</p><p><code>grid-row-gap</code>：</p><div>  <label>    <input onclick="gridClick('gridRowGap',value)" type="radio" name="grid-row-gap" value="10px" checked> grid-row-gap:    10px  </label>  <label>    <input onclick="gridClick('gridRowGap',value)" type="radio" name="grid-row-gap" value="20px"> grid-row-gap: 20px  </label>  <label>    <input onclick="gridClick('gridRowGap',value)" type="radio" name="grid-row-gap" value="25px"> grid-row-gap: 25px  </label>  <div id="gridRowGap" class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 80px);grid-template-rows: repeat(3, 80px);grid-row-gap: 10px;">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><p><code>grid-column-gap</code>：</p><div>  <label>    <input onclick="gridClick('gridColumnGap',value)" type="radio" name="grid-column-gap" value="10px" checked>    grid-column-gap: 10px  </label>  <label>    <input onclick="gridClick('gridColumnGap',value)" type="radio" name="grid-column-gap" value="20px"> grid-column-gap:    20px  </label>  <label>    <input onclick="gridClick('gridColumnGap',value)" type="radio" name="grid-column-gap" value="25px"> grid-column-gap:    25px  </label>  <div id="gridColumnGap" class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 80px);grid-template-rows: repeat(3, 80px);grid-column-gap: 10px;">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><h2 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h2><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><pre><code class="hljs css"><span class="hljs-selector-class">.brid-container</span> &#123;    <span class="hljs-attribute">display</span>: grid;    <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;    <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;    <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">'a b c'</span>                         <span class="hljs-string">'d e f'</span>                         <span class="hljs-string">'g h i'</span>;&#125;</code></pre><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><pre><code class="hljs css">grid-template-areas: 'a . c'                     'd . f'                     'g . i';</code></pre><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><p>注意，<strong>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</strong></p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p><h2 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h2><h3 id="3-5-1-属性"><a href="#3-5-1-属性" class="headerlink" title="3.5.1 属性"></a>3.5.1 属性</h3><ul><li><p><code>row</code>：先行后列。</p></li><li><p><code>column</code>：先列后行。</p></li><li><p><code>row dense</code>：”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p></li><li><p><code>column dense</code>：”先列后行”，并且尽量填满空格。</p></li></ul><p>点一点看效果：</p><div>  <label>    <input onclick="gridClick('gridAutoFlow',value)" type="radio" name="grid-auto-flow" value="row" checked> row  </label>  <label>    <input onclick="gridClick('gridAutoFlow',value)" type="radio" name="grid-auto-flow" value="column"> column  </label>  <div id="gridAutoFlow" class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><p><code>row dense</code></p><p>点一点看效果：</p><div> <label>    <input onclick="gridClick('rowDense',value)" type="radio" name="rowDense" value="row" checked> row  </label>  <label>    <input onclick="gridClick('rowDense',value)" type="radio" name="rowDense" value="row dense"> row dense  </label>  <div id="rowDense" class="grid-container"       style="height: 400px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);grid-auto-flow: row">    <div data-index="1" style="grid-column-start: 1;grid-column-end: 3"></div>    <div data-index="2" style="grid-column-start: 1;grid-column-end: 3"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><p><code>column dense</code></p><p>点一点看效果：</p><div> <label>    <input onclick="gridClick('columnDense',value)" type="radio" name="columnDense" value="column" checked> column   </label>  <label>    <input onclick="gridClick('columnDense',value)" type="radio" name="columnDense" value="column dense"> column dense  </label>  <div id="columnDense" class="grid-container"       style="height: 300px;grid-template-columns: repeat(4, 75px);grid-template-rows: repeat(3, 100px);grid-auto-flow: column;">    <div data-index="1" style="grid-column-start: 1;grid-column-end: 3;"></div>    <div data-index="2" ></div>    <div data-index="3" style="grid-row-start: 2;grid-row-end: 4"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><h2 id="3-6-justify-items-属性，-align-items-属性，-place-items-属性"><a href="#3-6-justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="3.6 justify-items 属性， align-items 属性， place-items 属性"></a>3.6 justify-items 属性， align-items 属性， place-items 属性</h2><ul><li><code>justify-items</code>属性设置单元格内容的水平位置（左中右）。</li><li><code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</li><li><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</li></ul><h3 id="3-6-1-属性"><a href="#3-6-1-属性" class="headerlink" title="3.6.1 属性"></a>3.6.1 属性</h3><ul><li><code>start</code>：对齐单元格的起始边缘。</li><li><code>end</code>：对齐单元格的结束边缘。</li><li><code>center</code>：单元格内部居中。</li><li><code>stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>点一点看效果：</p><p><code>justify-items</code>：</p><div>  <label>    <input onclick="gridClick('justifyItems',value)" type="radio" name="justify-items" value="start" checked> start  </label>  <label>    <input onclick="gridClick('justifyItems',value)" type="radio" name="justify-items" value="end"> end  </label>  <label>    <input onclick="gridClick('justifyItems',value)" type="radio" name="justify-items" value="center"> center  </label>  <label>    <input onclick="gridClick('justifyItems',value)" type="radio" name="justify-items" value="stretch"> stretch  </label>  <div id="justifyItems" class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);justify-items: start;">    <div style="min-width: 80px" data-index="1"></div>    <div style="min-width: 80px" data-index="2"></div>    <div style="min-width: 80px" data-index="3"></div>    <div style="min-width: 80px" data-index="4"></div>    <div style="min-width: 80px" data-index="5"></div>    <div style="min-width: 80px" data-index="6"></div>    <div style="min-width: 80px" data-index="7"></div>    <div style="min-width: 80px" data-index="8"></div>    <div style="min-width: 80px" data-index="9"></div>  </div></div><br/><p><code>align-items</code>：</p><div>  <label>    <input onclick="gridClick('alignItems',value)" type="radio" name="align-items" value="start" checked> start  </label>  <label>    <input onclick="gridClick('alignItems',value)" type="radio" name="align-items" value="end"> end  </label>  <label>    <input onclick="gridClick('alignItems',value)" type="radio" name="align-items" value="center"> center  </label>  <label>    <input onclick="gridClick('alignItems',value)" type="radio" name="align-items" value="stretch"> stretch  </label>  <div id="alignItems" class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);align-items: start;">    <div style="min-height: 80px" data-index="1"></div>    <div style="min-height: 80px" data-index="2"></div>    <div style="min-height: 80px" data-index="3"></div>    <div style="min-height: 80px" data-index="4"></div>    <div style="min-height: 80px" data-index="5"></div>    <div style="min-height: 80px" data-index="6"></div>    <div style="min-height: 80px" data-index="7"></div>    <div style="min-height: 80px" data-index="8"></div>    <div style="min-height: 80px" data-index="9"></div>  </div></div><br/><h2 id="3-7-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#3-7-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="3.7 justify-content 属性， align-content 属性， place-content 属性"></a>3.7 justify-content 属性， align-content 属性， place-content 属性</h2><ul><li><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右）。</li><li><code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</li><li><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</li></ul><h3 id="3-7-1-属性："><a href="#3-7-1-属性：" class="headerlink" title="3.7.1 属性："></a>3.7.1 属性：</h3><ul><li><code>start</code>：对齐容器的起始边框。</li><li><code>end</code>：对齐容器的结束边框。</li><li><code>center</code>：容器内部居中。</li><li><code>stretch</code>：项目大小没有指定时，拉伸占据整个网格容器。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li><li><code>space-between</code>：项目与项目的间隔相等，项目与容器边框之间没有间隔。</li><li><code>space-evenly</code>：项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul><p>点一点看效果：</p><p><code>justify-content</code>：</p><div>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="start" checked> start  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="end"> end  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="center"> center  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="stretch"> stretch  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="space-around">    space-around  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="space-between">    space-between  </label>  <label>    <input onclick="gridClick('justifyContent',value)" type="radio" name="justify-content" value="space-evenly">    space-evenly  </label>  <div id="justifyContent" class="grid-container"       style="grid-template-columns: repeat(3, 80px);grid-template-rows: repeat(3, 80px);grid-auto-rows: 50px;">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><p><code>align-content</code>：</p><div>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="start" checked> start  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="end"> end  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="center"> center  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="stretch"> stretch  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="space-around">    space-around  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="space-between">    space-between  </label>  <label>    <input onclick="gridClick('alignContent',value)" type="radio" name="align-content" value="space-evenly">    space-evenly  </label>  <div id="alignContent" class="grid-container"       style="height: 450px;grid-template-columns: repeat(3, 80px);grid-template-rows: repeat(3, 80px);grid-auto-rows: 50px;">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><h2 id="3-8-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#3-8-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="3.8 grid-auto-columns 属性， grid-auto-rows 属性"></a>3.8 grid-auto-columns 属性， grid-auto-rows 属性</h2><p>当一个网格仅仅只指定为3*3，而如果在指定网格之外还有项目，则可以使用<code>grid-auto-columns</code>和<code>grid-auto-rows</code>进行指定，如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>点一点看效果：</p><div>  <label>    <input onclick="gridClick('gridAutoRows',value)" type="radio" name="grid-auto-rows" value="50px" checked>    grid-auto-rows: 50px;  </label>  <label>    <input onclick="gridClick('gridAutoRows',value)" type="radio" name="grid-auto-rows" value="80px"> grid-auto-rows:    80px;  </label>  <label>    <input onclick="gridClick('gridAutoRows',value)" type="radio" name="grid-auto-rows" value="100px"> grid-auto-rows:    100px;  </label>  <div id="gridAutoRows" class="grid-container"       style="height: 400px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);grid-auto-rows: 50px;">    <div data-index="1"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9" style="grid-area: 4"></div>  </div></div><br/><h2 id="3-9-grid-template-属性，-grid-属性"><a href="#3-9-grid-template-属性，-grid-属性" class="headerlink" title="3.9 grid-template 属性， grid 属性"></a>3.9 grid-template 属性， grid 属性</h2><ul><li><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</li><li><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</li></ul><h1 id="4-项目属性"><a href="#4-项目属性" class="headerlink" title="4. 项目属性"></a>4. 项目属性</h1><h2 id="4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="4.1 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>4.1 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h2><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;    <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">2</span>;&#125;</code></pre><p>下面只改变<code>grid-column-end</code>的效果，其它的属性同理：</p><div>  <label>    <input onclick="gridClick('gridColumnEnd',value)" type="radio" name="grid-column-end" value="2" checked>    grid-column-end: 2  </label>  <label>    <input onclick="gridClick('gridColumnEnd',value)" type="radio" name="grid-column-end" value="3"> grid-column-end: 3  </label>  <label>    <input onclick="gridClick('gridColumnEnd',value)" type="radio" name="grid-column-end" value="4"> grid-column-end: 4  </label>  <div class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">    <div id="gridColumnEnd" data-index="1" style="grid-column-start: 1;grid-row-start: 1;grid-row-end: 2;"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>  </div></div><h2 id="4-2-grid-column-属性，-grid-row-属性"><a href="#4-2-grid-column-属性，-grid-row-属性" class="headerlink" title="4.2 grid-column 属性， grid-row 属性"></a>4.2 grid-column 属性， grid-row 属性</h2><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式。</p><p><code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><h2 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h2><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">3</span>;&#125;</code></pre><div class="grid-container"     style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">  <div data-index="1" style="grid-area: 3"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div>  <div data-index="7"></div>  <div data-index="8"></div>  <div data-index="9"></div></div><br/><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;    <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;&#125;</code></pre><div class="grid-container"     style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">  <div data-index="1" style="grid-area: 1 / 1 / 3 / 3"></div>  <div data-index="2"></div>  <div data-index="3"></div>  <div data-index="4"></div>  <div data-index="5"></div>  <div data-index="6"></div></div><h2 id="4-4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4.4 justify-self 属性， align-self 属性， place-self 属性"></a>4.4 justify-self 属性， align-self 属性， place-self 属性</h2><ul><li><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</li><li><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</li><li><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</li></ul><h3 id="4-4-1-属性"><a href="#4-4-1-属性" class="headerlink" title="4.4.1 属性"></a>4.4.1 属性</h3><ul><li><code>start</code>：对齐单元格的起始边缘。</li><li><code>end</code>：对齐单元格的结束边缘。</li><li><code>center</code>：单元格内部居中。</li><li><code>stretch</code>：拉伸，占满单元格的整个宽度（默认值）。</li></ul><p>点一点看效果：</p><p><code>justify-self</code>：</p><div>  <label>    <input onclick="gridClick('justifySelf',value)" type="radio" name="justify-self" value="start" checked> start  </label>  <label>    <input onclick="gridClick('justifySelf',value)" type="radio" name="justify-self" value="end"> end  </label>  <label>    <input onclick="gridClick('justifySelf',value)" type="radio" name="justify-self" value="center"> center  </label>  <label>    <input onclick="gridClick('justifySelf',value)" type="radio" name="justify-self" value="stretch"> stretch  </label>  <div class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">    <div id="justifySelf" data-index="1" style="width: 50px;height: 50px;"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><p><code>align-self</code>：</p><div>  <label>    <input onclick="gridClick('alignSelf',value)" type="radio" name="align-self" value="start" checked> start  </label>  <label>    <input onclick="gridClick('alignSelf',value)" type="radio" name="align-self" value="end"> end  </label>  <label>    <input onclick="gridClick('alignSelf',value)" type="radio" name="align-self" value="center"> center  </label>  <label>    <input onclick="gridClick('alignSelf',value)" type="radio" name="align-self" value="stretch"> stretch  </label>  <div class="grid-container"       style="height: 300px;grid-template-columns: repeat(3, 100px);grid-template-rows: repeat(3, 100px);">    <div id="alignSelf" data-index="1" style="width: 50px;height: 50px;"></div>    <div data-index="2"></div>    <div data-index="3"></div>    <div data-index="4"></div>    <div data-index="5"></div>    <div data-index="6"></div>    <div data-index="7"></div>    <div data-index="8"></div>    <div data-index="9"></div>  </div></div><br/><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>通过上面的眼花缭乱的属性，可以得知<code>Grid</code>比<code>Flex</code>强大的多，如果是单行布局建议选用<code>Flex</code>，而多行布局选用<code>Grid</code>，其实<code>Grid</code>和<code>Flex</code>在项目中也经常用到，不过我之前看教学视频的时候，貌似大部分讲师都更熟悉<code>Flex</code>一些，而<code>Grid</code>却很少用到（可能是由于<code>Grid</code>出来的比较晚）。所以导致我之前对<code>Grid</code>知之甚少，几乎没有用到过。</p><p>不过现在大部分现代浏览器都支持了<code>Grid</code>，所以可以放心大胆的用，但是如果是想要兼容老版本的<code>IE</code>浏览器…那就只能节哀顺变了。</p><h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><p><a href="https://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid 网格布局教程</a></p><script>  function gridClick(type, value) {    if (type === 'autoFill') {      $('#autoFill').css('gridTemplateColumns', value);    }    if (type === 'fr') {      $('#fr').css('gridTemplateColumns', value);    }    if (type === 'gridRowGap') {      $('#gridRowGap').css('gridRowGap', value);    }    if (type === 'gridColumnGap') {      $('#gridColumnGap').css('gridColumnGap', value);    }    if (type === 'gridAutoFlow') {      $('#gridAutoFlow').css('gridAutoFlow', value);    }    if (type === 'justifySelf') {      $('#justifySelf').css('justifySelf', value);    }    if (type === 'alignSelf') {      $('#alignSelf').css('alignSelf', value);    }    if (type === 'alignItems') {      $('#alignItems').css('alignItems', value);    }    if (type === 'justifyItems') {      $('#justifyItems').css('justifyItems', value);    }    if (type === 'gridColumnEnd') {      $('#gridColumnEnd').css('gridColumnEnd', value);    }    if (type === 'gridAutoRows') {      $('#gridAutoRows').css('gridAutoRows', value);    }    if (type === 'justifyContent') {      if (value === 'stretch') {        $('#justifyContent').css({'gridTemplateColumns': 'none', 'gridTemplateRows': 'none'});      } else {        $('#justifyContent').css({'gridTemplateColumns': 'repeat(3, 80px)', 'gridTemplateRows': 'repeat(3, 80px)'});      }      $('#justifyContent').css('justifyContent', value);    }    if (type === 'alignContent') {      if (value === 'stretch') {        $('#alignContent').css({'gridTemplateColumns': 'none', 'gridTemplateRows': 'none'});      } else {        $('#alignContent').css({'gridTemplateColumns': 'repeat(3, 80px)', 'gridTemplateRows': 'repeat(3, 80px)'});      }      $('#alignContent').css('alignContent', value);    }    if (type === 'rowDense') {      $('#rowDense').css('gridAutoFlow', value);    }    if (type === 'columnDense') {      $('#columnDense').css('gridAutoFlow', value);    }  }</script>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
      <tag>Flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年07月01日</title>
    <link href="/2020/07/02/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8801%E6%97%A5/"/>
    <url>/2020/07/02/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B407%E6%9C%8801%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>77526</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>46915</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>32814</td></tr><tr><td>4</td><td>穿越火线+cf ↑1</td><td>25976</td></tr><tr><td>5</td><td>最终幻想14+ff14 ↑2</td><td>16242</td></tr><tr><td>6</td><td>梦幻西游 ↓2</td><td>16007</td></tr><tr><td>7</td><td>冒险岛 ↑1</td><td>13873</td></tr><tr><td>8</td><td>绝地求生+pubg ↑1</td><td>13537</td></tr><tr><td>9</td><td>魔域 ↓3</td><td>12559</td></tr><tr><td>10</td><td>刀塔2+DOTA2</td><td>12253</td></tr><tr><td>11</td><td>魔兽世界+wow</td><td>12055</td></tr><tr><td>12</td><td>天龙八部</td><td>11723</td></tr><tr><td>13</td><td>csgo</td><td>10317</td></tr><tr><td>14</td><td>坦克世界 ↑1</td><td>8855</td></tr><tr><td>15</td><td>炉石传说 ↑2</td><td>8612</td></tr><tr><td>16</td><td>激战2</td><td>8233</td></tr><tr><td>17</td><td>方舟生存进化 ↑1</td><td>7026</td></tr><tr><td>18</td><td>逆水寒 ↑1</td><td>6722</td></tr><tr><td>19</td><td>守望先锋 ↑1</td><td>6670</td></tr><tr><td>20</td><td>龙之谷 ↑3</td><td>6616</td></tr><tr><td>21</td><td>诛仙 ↓7</td><td>6468</td></tr><tr><td>22</td><td>QQ飞车 ↑7</td><td>6292</td></tr><tr><td>23</td><td>EVE ↑1</td><td>5827</td></tr><tr><td>24</td><td>流放之路 ↓3</td><td>5294</td></tr><tr><td>25</td><td>变形金刚 ↑2</td><td>4609</td></tr><tr><td>26</td><td>天涯明月刀 ↑2</td><td>4548</td></tr><tr><td>27</td><td>传奇 ↓2</td><td>4497</td></tr><tr><td>28</td><td>大话西游 ↓2</td><td>4382</td></tr><tr><td>29</td><td>剑灵 ↓7</td><td>4219</td></tr><tr><td>30</td><td>摩尔庄园 ↑new</td><td>4013</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>94338</td></tr><tr><td>2</td><td>和平精英</td><td>51845</td></tr><tr><td>3</td><td>我的世界+mc</td><td>47113</td></tr><tr><td>4</td><td>迷你世界</td><td>45833</td></tr><tr><td>5</td><td>最强蜗牛</td><td>26578</td></tr><tr><td>6</td><td>香肠派对 ↑1</td><td>21057</td></tr><tr><td>7</td><td>荒野乱斗 ↓1</td><td>19259</td></tr><tr><td>8</td><td>阴阳师</td><td>14652</td></tr><tr><td>9</td><td>妖神记 ↑1</td><td>13578</td></tr><tr><td>10</td><td>第五人格 ↓1</td><td>13388</td></tr><tr><td>11</td><td>梦幻西游手游 ↑10</td><td>10260</td></tr><tr><td>12</td><td>部落冲突 ↑4</td><td>9610</td></tr><tr><td>13</td><td>球球大作战</td><td>9072</td></tr><tr><td>14</td><td>炉石传说 ↓2</td><td>8612</td></tr><tr><td>15</td><td>灌篮高手</td><td>8218</td></tr><tr><td>16</td><td>剑与远征 ↓5</td><td>7817</td></tr><tr><td>17</td><td>明日之后 ↓3</td><td>7572</td></tr><tr><td>18</td><td>欢乐斗地主 ↓1</td><td>7214</td></tr><tr><td>19</td><td>崩坏3 ↓1</td><td>6298</td></tr><tr><td>20</td><td>率土之滨</td><td>5531</td></tr><tr><td>21</td><td>开心消消乐 ↓2</td><td>5111</td></tr><tr><td>22</td><td>火影忍者手游 ↑4</td><td>4711</td></tr><tr><td>23</td><td>狼人杀 ↑2</td><td>4550</td></tr><tr><td>24</td><td>大话西游 ↓1</td><td>4382</td></tr><tr><td>25</td><td>碧蓝航线 ↓1</td><td>4351</td></tr><tr><td>26</td><td>饥荒 ↑1</td><td>3718</td></tr><tr><td>27</td><td>神魔大陆 ↑new</td><td>3514</td></tr><tr><td>28</td><td>奇迹暖暖</td><td>3131</td></tr><tr><td>29</td><td>问道</td><td>2997</td></tr><tr><td>30</td><td>爱上消消消 ↑new</td><td>2916</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/非常实用的Flex布局</title>
    <link href="/2020/07/01/web%E5%BC%80%E5%8F%91/%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84Flex%E5%B8%83%E5%B1%80/"/>
    <url>/2020/07/01/web%E5%BC%80%E5%8F%91/%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84Flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>传统的布局，基于盒装模型，早期的前端开发就是一个叠盒子的过程，即各种<code>&lt;div&gt;</code>的互相嵌套。</p><p>传统的布局一般依赖<code>position</code>或者<code>float</code>属性控制盒子所在的位置，但是对于特殊布局就显得非常的不方便，比如：垂直居中、均匀分布等。</p><p>在2009年，W3C提出了一种新的布局方案，即现在非常常用的Flex布局，可以非常轻松的完成和实现各种页面布局。到目前为止，它已经获得了主流浏览器的支持。但遗憾的是，如果要兼容早期的IE版本，还是得使用传统的<code>position</code>，<code>float</code>，不过由于兼容以前的IE版本会增加非常多的成本，所以现在大部分开发者已经放弃兼容早期的IE。</p><p>Flex是Flexible Box的缩写，意为”弹性布局”，现在比较流行的响应式界面，就是使用Flex和媒体查询进行实现。</p><style>    .box1 {        padding: 10px;        background-color: #f6ecec;    }    .box1>label {        margin-left: 10px;    }    #row,#wrap,#content,#items,#alignContent {        max-width: 600px;        display: flex;        border:1px #0f0f0f solid;    }    #alignContent {        height: 500px;        flex-wrap:wrap;    }    #flexBasis {        flex-basis: 100px;    }    #wrap>div,    #content>div,    #items>div,    #row>div,    #alignContent>div{        background-color:#f3b3b3;    }    #wrap>div[data-index]::before,    #content>div[data-index]::before,    #items>div[data-index]::before,    #row>div[data-index]::before,    #alignContent>div[data-index]::before {        content: attr(data-index);        background-color: #e5a9a9;        color: #fff;        position: absolute;        border-radius: 50%;        width: 20px;        height: 20px;        font-size: 14px;        text-align: center;        line-height: 20px;        z-index: 1;    }    @media screen  and (max-width: 600px){         #content>div {             width: 80px;         }         #alignContent>div:nth-child(5),              #alignContent>div:nth-child(6),              #alignContent>div:nth-child(7){              display: none;         }         .flex-grow>div {            width: 80px;         }         .flex-shrink-not {            display: none;         }    }</style><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>任何一个容易都可以指定为Flex布局。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;    <span class="hljs-attribute">display</span>: flex;&#125;</code></pre><p>注意：设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="rowClick('row',value)" type="radio" name="flex-direction" value="row" checked> row    </label>    <label>    <input onclick="rowClick('row',value)" type="radio" name="flex-direction" value="row-reverse"> row-reverse    </label>    <label>    <input onclick="rowClick('row',value)" type="radio" name="flex-direction" value="column"> column    </label>    <label>    <input onclick="rowClick('row',value)" type="radio" name="flex-direction" value="column-reverse"> column-reverse    </label>    <div id="row">    <div data-index="1">        <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><code>row</code> flex容器的主轴被定义为与文本方向相同。 主轴起点和主轴终点与内容方向相同。</li><li><code>row-reverse</code> 表现和row相同，但是置换了主轴起点和主轴终点</li><li><code>column</code> flex容器的主轴和块轴相同。主轴起点与主轴终点和书写模式的前后点相同</li><li><code>column-reverse</code> 表现和column相同，但是置换了主轴起点和主轴终点</li></ul><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>默认情况下，项目都排在一条线（又称“轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</code></pre><p>点一点看效果</p><div class="box1"><label>    <input onclick="rowClick('wrap',value)" type="radio" name="flex-wrap" value="nowrap" checked> nowrap</label><label>    <input onclick="rowClick('wrap',value)" type="radio" name="flex-wrap" value="wrap"> wrap</label><label>    <input onclick="rowClick('wrap',value)" type="radio" name="flex-wrap" value="wrap-reverse"> wrap-reverse</label>    <div id="wrap">    <div data-index="1">        <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="4">        <img width="200px" src="/image/Flex/4.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li><code>nowrap</code> flex 的元素被摆放到到一行，这可能导致溢出 flex 容器。 cross-start  会根据 flex-direction 的值 相当于 start 或 before。</li><li><code>wrap</code> flex 元素 被打断到多个行中。cross-start 会根据 flex-direction 的值选择等于start 或before。cross-end 为确定的 cross-start 的另一端。</li><li><code>wrap-reverse</code> 和 wrap 的行为一样，但是 cross-start 和 cross-end 互换。</li></ul><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre><p>点一点看效果</p><div class="box1"><label>    <input onclick="rowClick('content',value)" type="radio" name="justify-content" value="flex-start" checked> flex-start</label><label>    <input onclick="rowClick('content',value)" type="radio" name="justify-content" value="flex-end"> flex-end</label><label>    <input onclick="rowClick('content',value)" type="radio" name="justify-content" value="center"> center</label><label>    <input onclick="rowClick('content',value)" type="radio" name="justify-content" value="space-between"> space-between</label><label>    <input onclick="rowClick('content',value)" type="radio" name="justify-content" value="space-around"> space-around</label>    <div style="height: 200px;" id="content">    <div data-index="1">         <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h3 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h3><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p><code>align-items</code>属性定义项目在交叉轴上如何对齐。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre><p>点一点看效果</p><div class="box1"><label>    <input onclick="rowClick('items',value)" type="radio" name="align-items" value="flex-start" checked> flex-start</label><label>    <input onclick="rowClick('items',value)" type="radio" name="align-items" value="flex-end"> flex-end</label><label>    <input onclick="rowClick('items',value)" type="radio" name="align-items" value="center"> center</label><label>    <input onclick="rowClick('items',value)" type="radio" name="align-items" value="baseline"> baseline</label><label>    <input onclick="rowClick('items',value)" type="radio" name="align-items" value="stretch"> stretch</label>    <div style="height: 200px;" id="items">    <div data-index="1">        <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h3 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h3><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre><p>点一点看效果</p><div class="box1"><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="stretch" checked> stretch</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="flex-start"> flex-start</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="flex-end"> flex-end</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="center"> center</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="space-between"> space-between</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="space-around"> space-around</label><label>    <input onclick="rowClick('alignContent',value)" type="radio" name="choose" value="space-evenly"> space-evenly</label>    <div id="alignContent">    <div data-index="1">        <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="4">        <img width="200px" src="/image/Flex/4.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="5">        <img width="200px" src="/image/Flex/5.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="6">        <img width="200px" src="/image/Flex/6.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="7">        <img width="200px" src="/image/Flex/7.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h3 id="属性-4"><a href="#属性-4" class="headerlink" title="属性"></a>属性</h3><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><h1 id="子项上的属性"><a href="#子项上的属性" class="headerlink" title="子项上的属性"></a>子项上的属性</h1><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="childClick('order',value)" type="radio" name="order" value="0" checked> order: 0    </label>    <label>    <input onclick="childClick('order',value)" type="radio" name="order" value="1"> order: 1    </label>    <label>    <input onclick="childClick('order',value)" type="radio" name="order" value="2"> order: 2    </label>    <div id="row">    <div data-index="1" id="flex-order">    <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2" style="order: 0">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3" style="order: 1">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h2 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h2><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="childClick('flexGrow',value)" type="radio" name="flex-grow" value="0" checked> flex-grow: 0    </label>    <label>    <input onclick="childClick('flexGrow',value)" type="radio" name="flex-grow" value="0.5"> flex-grow: 0.5    </label>    <label>    <input onclick="childClick('flexGrow',value)" type="radio" name="flex-grow" value="1"> flex-grow: 1    </label>    <div class="flex-grow" style="height: 200px;" id="row">    <div data-index="1">    <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2" id="flexGrow">        <img width="110px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h2 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h2><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="childClick('flexShrink',value)" type="radio" name="flex-shrink" value="0" checked> flexShrink: 0    </label>    <label>    <input onclick="childClick('flexShrink',value)" type="radio" name="flex-shrink" value="3"> flexShrink: 1    </label>    <label>    <input onclick="childClick('flexShrink',value)" type="radio" name="flex-shrink" value="4"> flexShrink: 2    </label>    <div id="row">    <div data-index="1">        <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2" id="flexShrink">        <img src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    <div class="flex-shrink-not" data-index="4">            <img width="300px" src="/image/Flex/4.jpg" srcset="/img/loading.gif"/>        </div>    </div></div><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="childClick('flexBasis',value)" type="radio" name="flex-basis" value="100px" checked> flex-basis: 100px    </label>    <label>    <input onclick="childClick('flexBasis',value)" type="radio" name="flex-basis" value="150px"> flex-basis: 150px    </label>    <label>    <input onclick="childClick('flexBasis',value)" type="radio" name="flex-basis" value="200px"> flex-basis: 200px    </label>    <div id="row">    <div data-index="1">    <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="2" id="flexBasis">        <img src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">'flex-grow'</span>&gt; &lt;<span class="hljs-string">'flex-shrink'</span>&gt;? || &lt;<span class="hljs-string">'flex-basis'</span>&gt; ]&#125;</code></pre><p>该属性有两个快捷值：<code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code>。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><p>因为是上面3项的简写，所以这里就不再提供案例了。</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre><p>点一点看效果</p><div class="box1">    <label>        <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="auto" checked> auto    </label>    <label>            <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="flex-start"> flex-start        </label>        <label>                <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="flex-end"> flex-end            </label>            <label>                    <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="center" > center                </label>    <label>    <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="baseline"> baseline    </label>    <label>    <input onclick="childClick('alignSelf',value)" type="radio" name="align-self" value="stretch"> stretch    </label>    <div style="height:200px;align-items: baseline"  id="row">    <div data-index="1">    <img width="100px" src="/image/Flex/1.jpg" srcset="/img/loading.gif"/>    </div>    <div  data-index="2" id="alignSelf">        <img height="170px" src="/image/Flex/2.jpg" srcset="/img/loading.gif"/>    </div>    <div data-index="3">        <img width="200px" src="/image/Flex/3.jpg" srcset="/img/loading.gif"/>    </div>    </div></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我之前在做网页中会大量使用<code>Flex</code>，因为比起<code>position</code>或者<code>float</code>来讲实在是太过于方便了，其次用的比较多的就是<code>position</code>，<code>float</code>基本不怎么用到。</p><p>不过这些都要根据实际情况，因为老版本的<code>IE</code>仍然有一部分用户在使用，如果要兼容老版本的<code>IE</code>的话…那实在是很蛋疼。</p><script>    function rowClick(type,value) {        if(type==='row')        {           $('#row').css('flexDirection',value);        }        if(type==='wrap')        {           $('#wrap').css('flexWrap',value);        }        if(type==='content')        {           $('#content').css('justifyContent',value);        }        if(type==='items')        {           $('#items').css('alignItems',value);        }        if(type==='alignContent')        {           $('#alignContent').css('alignContent',value);        }    }    function childClick(type,value) {      if(type==='order'){        $('#flex-order').css('order',value);      }      if(type==='flexGrow'){          $('#flexGrow').css('flexGrow',value);      }      if(type==='flexShrink'){          $('#flexShrink').css('flexShrink',value);      }      if(type==='flexBasis'){          $('#flexBasis').css('flexBasis',value);      }      if(type==='alignSelf'){         $('#alignSelf').css('alignSelf',value);      }    }</script>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS3</tag>
      
      <tag>Flex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月30日</title>
    <link href="/2020/07/01/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8830%E6%97%A5/"/>
    <url>/2020/07/01/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8830%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>69047</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>43454</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>32432</td></tr><tr><td>4</td><td>梦幻西游 ↑3</td><td>21176</td></tr><tr><td>5</td><td>穿越火线+cf</td><td>19808</td></tr><tr><td>6</td><td>魔域 ↓2</td><td>16482</td></tr><tr><td>7</td><td>最终幻想14+ff14 ↑1</td><td>14054</td></tr><tr><td>8</td><td>冒险岛 ↑5</td><td>13793</td></tr><tr><td>9</td><td>绝地求生+pubg</td><td>13032</td></tr><tr><td>10</td><td>刀塔2+DOTA2 ↓4</td><td>13028</td></tr><tr><td>11</td><td>魔兽世界+wow ↓1</td><td>10940</td></tr><tr><td>12</td><td>天龙八部 ↑2</td><td>10715</td></tr><tr><td>13</td><td>csgo ↓2</td><td>10289</td></tr><tr><td>14</td><td>诛仙 ↑2</td><td>9405</td></tr><tr><td>15</td><td>坦克世界</td><td>8750</td></tr><tr><td>16</td><td>激战2 ↑1</td><td>8203</td></tr><tr><td>17</td><td>炉石传说 ↑1</td><td>8159</td></tr><tr><td>18</td><td>方舟生存进化 ↑1</td><td>7376</td></tr><tr><td>19</td><td>逆水寒 ↑1</td><td>6861</td></tr><tr><td>20</td><td>守望先锋 ↑2</td><td>6031</td></tr><tr><td>21</td><td>流放之路</td><td>5663</td></tr><tr><td>22</td><td>剑灵 ↑5</td><td>5566</td></tr><tr><td>23</td><td>龙之谷</td><td>5120</td></tr><tr><td>24</td><td>EVE</td><td>4908</td></tr><tr><td>25</td><td>传奇</td><td>4642</td></tr><tr><td>26</td><td>大话西游</td><td>4636</td></tr><tr><td>27</td><td>变形金刚 ↑1</td><td>4529</td></tr><tr><td>28</td><td>天涯明月刀 ↑new</td><td>4427</td></tr><tr><td>29</td><td>QQ飞车 ↓17</td><td>4153</td></tr><tr><td>30</td><td>龙族</td><td>3988</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>95344</td></tr><tr><td>2</td><td>和平精英</td><td>48841</td></tr><tr><td>3</td><td>我的世界+mc</td><td>43676</td></tr><tr><td>4</td><td>迷你世界</td><td>42705</td></tr><tr><td>5</td><td>最强蜗牛</td><td>29517</td></tr><tr><td>6</td><td>荒野乱斗</td><td>20513</td></tr><tr><td>7</td><td>香肠派对</td><td>19615</td></tr><tr><td>8</td><td>阴阳师</td><td>13423</td></tr><tr><td>9</td><td>第五人格</td><td>12850</td></tr><tr><td>10</td><td>妖神记</td><td>11655</td></tr><tr><td>11</td><td>剑与远征 ↑3</td><td>10365</td></tr><tr><td>12</td><td>炉石传说 ↓1</td><td>8159</td></tr><tr><td>13</td><td>球球大作战</td><td>8114</td></tr><tr><td>14</td><td>明日之后 ↑2</td><td>7590</td></tr><tr><td>15</td><td>灌篮高手</td><td>7465</td></tr><tr><td>16</td><td>部落冲突 ↑2</td><td>7182</td></tr><tr><td>17</td><td>欢乐斗地主</td><td>7037</td></tr><tr><td>18</td><td>崩坏3 ↑1</td><td>6269</td></tr><tr><td>19</td><td>开心消消乐 ↑3</td><td>5760</td></tr><tr><td>20</td><td>率土之滨 ↑1</td><td>5557</td></tr><tr><td>21</td><td>梦幻西游手游 ↑4</td><td>4721</td></tr><tr><td>22</td><td>剑网3指尖江湖 ↓10</td><td>4709</td></tr><tr><td>23</td><td>大话西游 ↑1</td><td>4636</td></tr><tr><td>24</td><td>碧蓝航线 ↓1</td><td>4480</td></tr><tr><td>25</td><td>狼人杀 ↑1</td><td>4392</td></tr><tr><td>26</td><td>火影忍者手游 ↑1</td><td>4301</td></tr><tr><td>27</td><td>饥荒 ↑1</td><td>3645</td></tr><tr><td>28</td><td>奇迹暖暖 ↑new</td><td>2982</td></tr><tr><td>29</td><td>问道 ↑1</td><td>2920</td></tr><tr><td>30</td><td>恋与制作人 ↓1</td><td>2884</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月29日</title>
    <link href="/2020/06/30/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8829%E6%97%A5/"/>
    <url>/2020/06/30/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8829%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>70844</td></tr><tr><td>2</td><td>我的世界+minecraft ↑1</td><td>40796</td></tr><tr><td>3</td><td>地下城与勇士+dnf ↓1</td><td>37027</td></tr><tr><td>4</td><td>魔域</td><td>26358</td></tr><tr><td>5</td><td>穿越火线+cf</td><td>19167</td></tr><tr><td>6</td><td>刀塔2+DOTA2</td><td>17653</td></tr><tr><td>7</td><td>梦幻西游 ↑3</td><td>16147</td></tr><tr><td>8</td><td>最终幻想14+ff14 ↓1</td><td>13332</td></tr><tr><td>9</td><td>绝地求生+pubg</td><td>12657</td></tr><tr><td>10</td><td>魔兽世界+wow ↑2</td><td>10719</td></tr><tr><td>11</td><td>csgo</td><td>9960</td></tr><tr><td>12</td><td>QQ飞车 ↓4</td><td>9800</td></tr><tr><td>13</td><td>冒险岛 ↑1</td><td>9476</td></tr><tr><td>14</td><td>天龙八部 ↓1</td><td>9455</td></tr><tr><td>15</td><td>坦克世界 ↑1</td><td>8784</td></tr><tr><td>16</td><td>诛仙 ↑4</td><td>8423</td></tr><tr><td>17</td><td>激战2 ↓2</td><td>8136</td></tr><tr><td>18</td><td>炉石传说 ↓1</td><td>8023</td></tr><tr><td>19</td><td>方舟生存进化</td><td>7254</td></tr><tr><td>20</td><td>逆水寒 ↓2</td><td>7038</td></tr><tr><td>21</td><td>流放之路</td><td>6127</td></tr><tr><td>22</td><td>守望先锋 ↑1</td><td>5748</td></tr><tr><td>23</td><td>龙之谷 ↑2</td><td>5054</td></tr><tr><td>24</td><td>EVE</td><td>4997</td></tr><tr><td>25</td><td>传奇 ↓3</td><td>4912</td></tr><tr><td>26</td><td>大话西游 ↑1</td><td>4664</td></tr><tr><td>27</td><td>剑灵 ↑2</td><td>4509</td></tr><tr><td>28</td><td>变形金刚 ↓2</td><td>4426</td></tr><tr><td>29</td><td>qq三国 ↑new</td><td>4071</td></tr><tr><td>30</td><td>龙族</td><td>3992</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>114409</td></tr><tr><td>2</td><td>和平精英</td><td>46965</td></tr><tr><td>3</td><td>我的世界+mc</td><td>41003</td></tr><tr><td>4</td><td>迷你世界</td><td>40678</td></tr><tr><td>5</td><td>最强蜗牛 ↑1</td><td>28296</td></tr><tr><td>6</td><td>荒野乱斗 ↓1</td><td>21617</td></tr><tr><td>7</td><td>香肠派对</td><td>17910</td></tr><tr><td>8</td><td>阴阳师</td><td>13051</td></tr><tr><td>9</td><td>第五人格</td><td>12728</td></tr><tr><td>10</td><td>妖神记 ↑new</td><td>12631</td></tr><tr><td>11</td><td>炉石传说</td><td>8023</td></tr><tr><td>12</td><td>剑网3指尖江湖 ↓2</td><td>7693</td></tr><tr><td>13</td><td>球球大作战</td><td>7595</td></tr><tr><td>14</td><td>剑与远征 ↑new</td><td>7402</td></tr><tr><td>15</td><td>灌篮高手 ↑1</td><td>7379</td></tr><tr><td>16</td><td>明日之后 ↓4</td><td>7212</td></tr><tr><td>17</td><td>欢乐斗地主 ↓3</td><td>7196</td></tr><tr><td>18</td><td>部落冲突 ↓1</td><td>6722</td></tr><tr><td>19</td><td>崩坏3 ↓1</td><td>6500</td></tr><tr><td>20</td><td>QQ飞车手游 ↓5</td><td>5784</td></tr><tr><td>21</td><td>率土之滨 ↓2</td><td>5631</td></tr><tr><td>22</td><td>开心消消乐 ↓1</td><td>5137</td></tr><tr><td>23</td><td>碧蓝航线 ↓3</td><td>4881</td></tr><tr><td>24</td><td>大话西游 ↓2</td><td>4664</td></tr><tr><td>25</td><td>梦幻西游手游 ↓2</td><td>4631</td></tr><tr><td>26</td><td>狼人杀 ↓2</td><td>4332</td></tr><tr><td>27</td><td>火影忍者手游 ↓1</td><td>3880</td></tr><tr><td>28</td><td>饥荒 ↓3</td><td>3583</td></tr><tr><td>29</td><td>恋与制作人 ↑new</td><td>3393</td></tr><tr><td>30</td><td>问道 ↓1</td><td>3127</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公众号自定义样式，令人惊叹的文章编辑器，SVG篇</title>
    <link href="/2020/06/30/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8CSVG%E7%AF%87/"/>
    <url>/2020/06/30/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8%EF%BC%8CSVG%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>这个系列居然还有第二期，我是没有想到的，虽然我的公众号已经放弃维护了，现在在搞我的博客。</p><a href="/2020/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8/" title="公众号自定义样式，令人惊叹的文章编辑器">公众号自定义样式，令人惊叹的文章编辑器</a><h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>事情的起因是因为我无意之中看到了人家微信公众号的文章中有这样的效果：</p><p><img src="/image/click.gif" srcset="/img/loading.gif" alt="click"></p><p>一个公众号中的文章，居然还能够实现这种效果，太不可思议了，于是马上开始研究起来。</p><h1 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h1><p>使用Chrome浏览器打开这篇文章的链接，然后通过开发者工具进行检查，发现了下面的代码：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 0px; box-sizing: border-box;"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">    <span class="hljs-attr">opacity</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">        box-sizing: border-box;</span></span><span class="hljs-tag"><span class="hljs-string">        transform: rotateZ(0deg);</span></span><span class="hljs-tag"><span class="hljs-string">        background-size: contain;</span></span><span class="hljs-tag"><span class="hljs-string">        background-repeat: no-repeat;</span></span><span class="hljs-tag"><span class="hljs-string">        background-position: 50% 50%;</span></span><span class="hljs-tag"><span class="hljs-string">        background-color: rgb(254, 254, 254);</span></span><span class="hljs-tag"><span class="hljs-string">        background-image: url('https://mmbiz.qpic.cn/sz_mmbiz_jpg/9NT6Pkus6TMhBVMGv3j06B9VLRMjicpOibfjdbNsRjcXH13pkfZNStyX67yH3QcgppNiaPOQYrMvGGfnP7sVmcaqw/640?wx_fmt=jpeg');</span></span><span class="hljs-tag"><span class="hljs-string">        width: 100%;</span></span><span class="hljs-tag"><span class="hljs-string">    "</span></span><span class="hljs-tag">    <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 100 120.2"</span></span><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">    &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">animate</span></span><span class="hljs-tag">        <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"width"</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span></span><span class="hljs-tag">        <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">        <span class="hljs-attr">from</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">        <span class="hljs-attr">duration</span>=<span class="hljs-string">"0.01"</span></span><span class="hljs-tag">        <span class="hljs-attr">begin</span>=<span class="hljs-string">"click + 0.5s"</span></span><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">        <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">        <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">    &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rect</span></span><span class="hljs-tag">            <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">            <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box; opacity: 1; fill: transparent;"</span></span><span class="hljs-tag">            <span class="hljs-attr">x</span>=<span class="hljs-string">"0%"</span></span><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span></span><span class="hljs-tag">        &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 100%; height: 100%; box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">        &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">animate</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span></span><span class="hljs-tag">        <span class="hljs-attr">dur</span>=<span class="hljs-string">"0.5"</span></span><span class="hljs-tag">        <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"opacity"</span></span><span class="hljs-tag">        <span class="hljs-attr">begin</span>=<span class="hljs-string">"click"</span></span><span class="hljs-tag">        <span class="hljs-attr">from</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">        <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>是的，在微信提供的编辑器中还可以使用<code>svg</code>标签，果然不是一个普通的文字编辑器啊！</p><p>将上面的那段代码新建一个<code>html</code>文件。</p><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span> /&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"height: 0px; box-sizing: border-box;"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">    <span class="hljs-attr">opacity</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">"</span></span><span class="hljs-tag"><span class="hljs-string">        box-sizing: border-box;</span></span><span class="hljs-tag"><span class="hljs-string">        transform: rotateZ(0deg);</span></span><span class="hljs-tag"><span class="hljs-string">        background-size: contain;</span></span><span class="hljs-tag"><span class="hljs-string">        background-repeat: no-repeat;</span></span><span class="hljs-tag"><span class="hljs-string">        background-position: 50% 50%;</span></span><span class="hljs-tag"><span class="hljs-string">        background-color: rgb(254, 254, 254);</span></span><span class="hljs-tag"><span class="hljs-string">        background-image: url('https://mmbiz.qpic.cn/sz_mmbiz_jpg/9NT6Pkus6TMhBVMGv3j06B9VLRMjicpOibfjdbNsRjcXH13pkfZNStyX67yH3QcgppNiaPOQYrMvGGfnP7sVmcaqw/640?wx_fmt=jpeg');</span></span><span class="hljs-tag"><span class="hljs-string">        width: 100%;</span></span><span class="hljs-tag"><span class="hljs-string">    "</span></span><span class="hljs-tag">    <span class="hljs-attr">viewBox</span>=<span class="hljs-string">"0 0 100 120.2"</span></span><span class="hljs-tag">    <span class="hljs-attr">width</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">    &gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">animate</span></span><span class="hljs-tag">        <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"width"</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span></span><span class="hljs-tag">        <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">        <span class="hljs-attr">from</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">        <span class="hljs-attr">duration</span>=<span class="hljs-string">"0.01"</span></span><span class="hljs-tag">        <span class="hljs-attr">begin</span>=<span class="hljs-string">"click + 0.5s"</span></span><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">        <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">        <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">    &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">rect</span></span><span class="hljs-tag">            <span class="hljs-attr">width</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">            <span class="hljs-attr">height</span>=<span class="hljs-string">"100%"</span></span><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box; opacity: 1; fill: transparent;"</span></span><span class="hljs-tag">            <span class="hljs-attr">x</span>=<span class="hljs-string">"0%"</span></span><span class="hljs-tag">        &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span></span><span class="hljs-tag">        &gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">svg</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 100%; height: 100%; box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">version</span>=<span class="hljs-string">"1.1"</span></span><span class="hljs-tag">        <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.w3.org/2000/svg"</span></span><span class="hljs-tag">        &gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">animate</span></span><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">"box-sizing: border-box;"</span></span><span class="hljs-tag">        <span class="hljs-attr">fill</span>=<span class="hljs-string">"freeze"</span></span><span class="hljs-tag">        <span class="hljs-attr">dur</span>=<span class="hljs-string">"0.5"</span></span><span class="hljs-tag">                <span class="hljs-attr">attributeName</span>=<span class="hljs-string">"opacity"</span></span><span class="hljs-tag">        <span class="hljs-attr">begin</span>=<span class="hljs-string">"click"</span></span><span class="hljs-tag">        <span class="hljs-attr">from</span>=<span class="hljs-string">"1"</span></span><span class="hljs-tag">        <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span></span><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">animate</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre><p>会出现下面的效果：</p><p><img src="/image/click1.gif" srcset="/img/loading.gif" alt="click1"></p><p>可以看到，点击浮现的效果即是使用了一个SVG遮住了下面的图片。</p><h1 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h1><p>如果想要学习SVG，可以看这篇文章<a href="https://www.ruanyifeng.com/blog/2018/08/svg.html" target="_blank" rel="noopener">SVG 图像入门教程</a> 因为这种前端知识，不是本篇的重点，那么接下来我们看一下公众号的编辑器可以实现哪些酷炫的效果吧。</p><p><img src="/image/%E6%95%88%E6%9E%9C.gif" srcset="/img/loading.gif" alt=""></p><h1 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h1><p><a href="https://mp.weixin.qq.com/s/fYTeLpJ3_RuPxumk6l6uxg" target="_blank" rel="noopener">公众号文章能够实现的酷炫效果</a></p><p>亲测如果使用Chrome打开链接是无法触发SVG的点击事件，只有通过微信浏览器打开才能触发点击事件，不知道是不是我的问题。</p>]]></content>
    
    
    <categories>
      
      <category>微信公众号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>提高处理Excel效率的终极神器-VBA初步入门</title>
    <link href="/2020/06/29/%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86Excel%E6%95%88%E7%8E%87%E7%9A%84%E7%BB%88%E6%9E%81%E7%A5%9E%E5%99%A8-VBA%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/"/>
    <url>/2020/06/29/%E6%8F%90%E9%AB%98%E5%A4%84%E7%90%86Excel%E6%95%88%E7%8E%87%E7%9A%84%E7%BB%88%E6%9E%81%E7%A5%9E%E5%99%A8-VBA%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-什么是VBA？"><a href="#1-1-什么是VBA？" class="headerlink" title="1.1 什么是VBA？"></a>1.1 什么是VBA？</h2><p><code>Visual Basic For Application(VBA)</code>可以认为 VBA 是非常流行的应用程序开发语言<code>VASUAL BASIC</code>的子集。实际上VBA是”寄生于”VB应用程序的版本。</p><p>也就是说为了自动化需要，微软开发出的一款对于自家的产品（例如：Excel，Word等）的一种通用的自动化语言。也就是说可以帮助人们完成对Excel的一些重复性操作。</p><h2 id="1-2-为什么要学习VBA？"><a href="#1-2-为什么要学习VBA？" class="headerlink" title="1.2 为什么要学习VBA？"></a>1.2 为什么要学习VBA？</h2><p>相信不管是什么岗位，在现在这个年代，或多或少都会跟Excel打交道，而VBA比起Excel的公式来说更具有学习成本，但是VBA比Excel的公式更为强大，因为它本身就是一种<strong>脚本语言</strong>。</p><h2 id="1-3-VBA能做到什么？"><a href="#1-3-VBA能做到什么？" class="headerlink" title="1.3 VBA能做到什么？"></a>1.3 VBA能做到什么？</h2><p>对于Excel而言你能做到的，它都能做到，同时它能比你完成的更快，更好。如果是重复性的工作交给人来办，多多少少都会有错误，但是你交给VBA来办，只要在你代码编写正确的情况下，就算是再多的数据，它都不可能出错。</p><h2 id="1-4-感受VBA"><a href="#1-4-感受VBA" class="headerlink" title="1.4 感受VBA"></a>1.4 感受VBA</h2><p><img src="/image/image-20200629132556351.png" srcset="/img/loading.gif" alt="image-20200629132556351"></p><p>这是最近在做的一个游戏数据排行榜，有兴趣的话可以到<a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">游戏排行榜</a>进行查看。</p><h3 id="1-4-1-需求"><a href="#1-4-1-需求" class="headerlink" title="1.4.1 需求"></a>1.4.1 需求</h3><p>我的需求是右边的数据对比左边的数据，比如说<strong>迷你世界</strong>，右边的数据比左边的数据下降了2个排名，那我就需要在右边的数据中标出<code>↓2</code>并且将它们的文字颜色更改为绿色。</p><p>而对于<strong>我的世界</strong>这种排行上升的游戏我也需要在右边的数据中标出<code>↑1</code>并将文字改变成红色。</p><p>对于<strong>QQ飞车手游</strong>这种前一天排行榜上面没有的游戏就标记为<code>↑new</code>就跟下面的图一样：</p><p><img src="/image/image-20200629133034681.png" srcset="/img/loading.gif" alt="image-20200629133034681"></p><p>如果对于你来说，没有学习过VBA那么怎么进行操作？右边对着左边一项一项的比对，然后就行标记？没错，我前2天就是这样，但是后面觉得麻烦，编写了一段VBA代码实现自动化，下面是效果：</p><p><img src="/image/sort.gif" srcset="/img/loading.gif" alt=""></p><p>可以看到几乎在几秒钟的时间内，就完成了我们一项一项去比对少花费数分钟或者数十分钟的时间，而且自行比对还容易出错。</p><h1 id="2-Excel宏命令"><a href="#2-Excel宏命令" class="headerlink" title="2. Excel宏命令"></a>2. Excel宏命令</h1><h2 id="2-1-调出开发工具"><a href="#2-1-调出开发工具" class="headerlink" title="2.1 调出开发工具"></a>2.1 调出开发工具</h2><p>如果你只是要实现简单的自动化，那么使用录制宏功能就可以了。</p><p>首先调出<strong>开发工具</strong>，点击<code>文件</code>-<code>选项</code>-<code>自定义功能区</code></p><p><img src="/image/image-20200629161719166.png" srcset="/img/loading.gif" alt="image-20200629161719166"></p><p>勾选后点击<code>确定</code></p><p><img src="/image/image-20200629161849883.png" srcset="/img/loading.gif" alt="image-20200629161849883"></p><p>可以看到主界面上出现了一个开发工具。</p><p><strong>注：如果是盗版office可能会出现打不开开发工具的情况。</strong></p><h2 id="2-2-录制宏"><a href="#2-2-录制宏" class="headerlink" title="2.2 录制宏"></a>2.2 录制宏</h2><p>点击录制宏，会将你所有的动作录制下来，下次再运行宏时会重复你这次录制的操作。</p><p><img src="/image/%E5%BD%95%E5%88%B6%E5%AE%8F.gif" srcset="/img/loading.gif" alt=""></p><h2 id="2-3-运行宏"><a href="#2-3-运行宏" class="headerlink" title="2.3 运行宏"></a>2.3 运行宏</h2><p><img src="/image/%E8%BF%90%E8%A1%8C%E5%AE%8F.gif" srcset="/img/loading.gif" alt=""></p><h2 id="2-4-编辑宏"><a href="#2-4-编辑宏" class="headerlink" title="2.4 编辑宏"></a>2.4 编辑宏</h2><p>编辑宏的方式是在上面的运行宏时，选择<code>编辑</code></p><p><img src="/image/image-20200629162624012.png" srcset="/img/loading.gif" alt="image-20200629162624012"></p><p>打开后会看到下面的界面</p><p><img src="/image/image-20200629162653844.png" srcset="/img/loading.gif" alt="image-20200629162653844"></p><h1 id="3-修改宏命令"><a href="#3-修改宏命令" class="headerlink" title="3. 修改宏命令"></a>3. 修改宏命令</h1><p>如果你想用宏实现更为复杂的功能，那就需要学习下面的知识，<strong>上面那仅仅是录制宏，下面开始才是真正的VBA知识。</strong></p><h2 id="3-1-标识符"><a href="#3-1-标识符" class="headerlink" title="3.1 标识符"></a>3.1 标识符</h2><p>标识符是一种标识变量、常量、过程、函数、类等语言构成单位的符号，利用它可以完成对变量、常量、过程、函数、类等引用。</p><h3 id="3-1-1-命名规则"><a href="#3-1-1-命名规则" class="headerlink" title="3.1.1 命名规则"></a>3.1.1 命名规则</h3><ul><li>字母打头，由字母、数字和下划线组成，如<code>A987b_23Abc</code></li><li>字符长度小于40，（Excel2002以上中文版本等，可以用汉字且长度可达254个字符）</li><li>不能与VB保留字重名，如<code>public，private，dim，goto，next，with，integer，single</code>等</li><li>尽量见名知意，比如名字命名为<code>name</code>，而不要命名为<code>n</code>或者其它不知道含义的名字。</li></ul><h2 id="3-2-运算符"><a href="#3-2-运算符" class="headerlink" title="3.2 运算符"></a>3.2 运算符</h2><ul><li>赋值运算符  <code>=</code></li><li>数学运算符 <code>&amp;、+ (字符连接符)、+(加)、-（减）、Mod（取余）、\（整除）、*（乘）、/（除）、-（负号）、^（指数）</code></li><li>逻辑运算符 <code>Not（非）、And（与）、Or(或)、Xor(异或)、Eqv(相等)、Imp(隐含)</code></li><li>关系运算符 <code>= （相同）、&lt;&gt;（不等）、&gt;（大于）、&lt;（小于）、&gt;=（不小于）、&lt;=（不大于）、Like、Is</code></li><li>位运算符（不常用）  <code>Not（逻辑非）、And（逻辑与）、Or（逻辑或）、Xor（逻辑异或）、Eqv（逻辑等）、Imp（隐含）</code> </li></ul><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><table><thead><tr><th>数据类型</th><th>类型标识符</th><th>字节</th></tr></thead><tbody><tr><td>String 字符串型</td><td>$</td><td>字符长度(0-65400)</td></tr><tr><td>Byte 字节型</td><td>无</td><td>1</td></tr><tr><td>Boolean 布尔型</td><td>无</td><td>2</td></tr><tr><td>Integer 整数型</td><td>%</td><td>2</td></tr><tr><td>Long 长整数型</td><td>&amp;</td><td>4</td></tr><tr><td>Single 单精度型</td><td>!</td><td>4</td></tr><tr><td>Double 双精度型</td><td>#</td><td>8</td></tr><tr><td>Date 日期型</td><td>无</td><td>8 公元 100/1/1-99/12/31</td></tr><tr><td>Currency 货币型</td><td>@</td><td>8</td></tr><tr><td>Decimal 小数点型</td><td>无</td><td>14</td></tr><tr><td>Variant 变体型</td><td>无</td><td>以上任意类型，可变</td></tr><tr><td>Object 对象型</td><td>无</td><td>4</td></tr></tbody></table><p><strong>PS：这一部分了解就行了，如果不是要做更深入的研究用处不大。</strong></p><h2 id="3-4-变量与常量"><a href="#3-4-变量与常量" class="headerlink" title="3.4 变量与常量"></a>3.4 变量与常量</h2><h3 id="3-4-1-未定义变量"><a href="#3-4-1-未定义变量" class="headerlink" title="3.4.1 未定义变量"></a>3.4.1 未定义变量</h3><p><strong>VBA允许使用未定义的变量，默认是变体变量</strong>例如：</p><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> test()a = <span class="hljs-number">100</span>MsgBox a<span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span></code></pre><h3 id="3-4-2-强制定义变量"><a href="#3-4-2-强制定义变量" class="headerlink" title="3.4.2 强制定义变量"></a>3.4.2 强制定义变量</h3><p><strong>在模块通用说明部分，加入Option Explicit语句可以强迫用户进行变量定义</strong></p><h3 id="3-4-3变量定义语句及变量作用域"><a href="#3-4-3变量定义语句及变量作用域" class="headerlink" title="3.4.3变量定义语句及变量作用域"></a>3.4.3变量定义语句及变量作用域</h3><p><code>Dim 变量 as 类型</code>定义为局部变量，如<code>Dim xyz as integer</code> </p><p><code>Private 变量 as 类型</code>定义为私有变量，如<code>Private xyz as byte</code> </p><p><code>Public 变量as 类型</code>定义为公有变量，如<code>Public xyz as single</code> </p><p><code>Global 变量as 类型</code>定义为全局变量，如<code>Globlal xyz as date</code> </p><p><code>Static 变量 as 类型</code>定义为静态变量，如<code>Static xyz as double</code></p><p>一般变量作用域的原则是，那部分定义就在那部分起作用，模块中定义则在该模块那作用。</p><h3 id="3-4-4-常量"><a href="#3-4-4-常量" class="headerlink" title="3.4.4 常量"></a>3.4.4 常量</h3><p>常量为变量的一种特例，用<code>Const</code>定义，且定义时赋值，程序中不能改变值，作用域也如同变量作用域。如下定义：<code>Const Pi As Single = 3.1415926</code></p><h2 id="3-5-数组"><a href="#3-5-数组" class="headerlink" title="3.5 数组"></a>3.5 数组</h2><p>数组是包含相同数据类型的一组变量的集合，对数组中的单个变量引用通过数组索引下标进行。在内存中表现为一个连续的内存块，必须用<code>Global</code>或<code>Dim</code>语句来定义。定义规则如下：</p><p><code>Dim 数组名([lower to ]upper [, [lower to ]upper, ….]) as type ;Lower</code>缺省值为0。二维数组是按行列排列，如<code>XYZ(行，列)</code>。</p><p>除了以上固定数组外，<code>VBA</code> 还有一种功能强大的动态数组，定义时无大小维数声明；在程序中再利用<code>Redim</code>语句来重新改变数组大小，原来数组内容可以通过加<code>preserve</code>关键字来保留。</p><h2 id="3-6-注释和赋值语句"><a href="#3-6-注释和赋值语句" class="headerlink" title="3.6 注释和赋值语句"></a>3.6 注释和赋值语句</h2><p>注释语句是用来说明程序中某些语句的功能和作用；</p><p>VBA中有两种方法标识为注释语句。</p><ul><li>单引号 <code>’</code>  ;如：<code>’定义全局变量；</code>可以位于别的语句之尾，也可单独一行</li><li><code>Rem</code>如：<code>Rem定义全局变量；</code>只能单独一行</li></ul><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> 宏<span class="hljs-number">1</span>()<span class="hljs-comment">'</span><span class="hljs-comment">' 宏1 宏</span><span class="hljs-comment">'</span><span class="hljs-keyword">Rem</span> 定义全局变量<span class="hljs-comment">'数学运算符</span>a = <span class="hljs-number">1</span>b = <span class="hljs-number">2</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span></code></pre><p>赋值语句是进行对变量或对象属性赋值的语句，采用赋值号 <code>=</code>，如<code>X=123</code>,<code>Form1.caption=”我的窗口”</code></p><p>对对象的赋值采用：<code>set myobject=object</code> 或  <code>myobject:=object</code></p><h2 id="3-7-书写规范"><a href="#3-7-书写规范" class="headerlink" title="3.7 书写规范"></a>3.7 书写规范</h2><ul><li>VBA不区分标识符的字母大小写，一律认为是小写字母；</li><li>一行可以书写多条语句，各语句之间以冒号 :  分开；</li><li>一条语句可以多行书写，以空格加下划线 <code>_</code> 来标识下行为续行；</li><li>标识符最好能简洁明了，不造成歧义。</li></ul><h2 id="3-8-判断语句"><a href="#3-8-判断语句" class="headerlink" title="3.8 判断语句"></a>3.8 判断语句</h2><h3 id="3-8-1-If…Then…Else语句（最常用）"><a href="#3-8-1-If…Then…Else语句（最常用）" class="headerlink" title="3.8.1 If…Then…Else语句（最常用）"></a>3.8.1 If…Then…Else语句（最常用）</h3><pre><code class="hljs vb"><span class="hljs-keyword">If</span> 条件 <span class="hljs-keyword">Then</span>表达式<span class="hljs-keyword">ElseIf</span> 条件 <span class="hljs-keyword">Then</span>表达式<span class="hljs-keyword">Else</span>表达式<span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>例如<span class="hljs-keyword">If</span> Number &lt; <span class="hljs-number">10</span>  <span class="hljs-keyword">Then</span>     Digits = <span class="hljs-number">1</span><span class="hljs-keyword">ElseIf</span> Number &lt; <span class="hljs-number">100</span>  <span class="hljs-keyword">Then</span>     Digits = <span class="hljs-number">2</span><span class="hljs-keyword">Else</span>     Digits = <span class="hljs-number">3</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span></code></pre><h3 id="3-8-2-Select-Case…Case…End-Case语句"><a href="#3-8-2-Select-Case…Case…End-Case语句" class="headerlink" title="3.8.2 Select Case…Case…End Case语句"></a>3.8.2 Select Case…Case…End Case语句</h3><pre><code class="hljs bv">Select Case  Pid   Case  “A101”   Price&#x3D;200   Case  “A102”   Price&#x3D;300   ……   Case Else   Price&#x3D;900End Case</code></pre><h3 id="3-8-3-Choose-函数"><a href="#3-8-3-Choose-函数" class="headerlink" title="3.8.3 Choose 函数"></a>3.8.3 Choose 函数</h3><p><code>choose(index, choce-1,choice-2,…,choice-n)</code>，可以用来选择自变量串列中的一个值，并将其返回，index 必要参数，数值表达式或字段，它的运算结果是一个数值，且界于 1 和可选择的项目数之间。</p><p><code>choice</code> 必要参数，<code>Variant</code>表达式，包含可选择项目的其中之一。如：<code>GetChoice = Choose(Ind, &quot;Speedy&quot;, &quot;United&quot;, &quot;Federal&quot;)</code></p><h3 id="3-8-4-Switch函数"><a href="#3-8-4-Switch函数" class="headerlink" title="3.8.4 Switch函数"></a>3.8.4 Switch函数</h3><p><code>Switch(expr-1, value-1[, expr-2, value-2 _ [, expr-n,value-n]])switch</code> 函数和 <code>Choose</code> 函数类似，但它是以两个一组的方式返回所要的值，在串列中，最先为<code>TRUE</code> 的值会被返回。</p><p> <code>expr</code> 必要参数，要加以计算的 <code>Variant</code> 表达式。<code>value</code> 必要参数。如果相关的表达式为 <code>True</code>，则返回此部分的数值或表达式，没有一个表达式为 <code>True</code>，<code>Switch</code> 会返回一个 <code>Null</code>值。</p><h2 id="3-9-循环语句"><a href="#3-9-循环语句" class="headerlink" title="3.9 循环语句"></a>3.9 循环语句</h2><h3 id="3-9-1For-Next语句"><a href="#3-9-1For-Next语句" class="headerlink" title="3.9.1For Next语句"></a>3.9.1For Next语句</h3><p>以指定次数来重复执行一组语句</p><pre><code class="hljs vb"><span class="hljs-keyword">For</span> counter = start <span class="hljs-keyword">To</span> <span class="hljs-keyword">end</span> [<span class="hljs-keyword">Step</span> <span class="hljs-keyword">step</span>]                  ＇<span class="hljs-keyword">step</span> 缺省值为<span class="hljs-number">1</span>[statements][<span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span>][statements]<span class="hljs-keyword">Next</span> [counter]如<span class="hljs-number">1</span>：<span class="hljs-keyword">For</span> Words = <span class="hljs-number">10</span> <span class="hljs-keyword">To</span> <span class="hljs-number">1</span> <span class="hljs-keyword">Step</span>  <span class="hljs-number">-1</span>                               ＇建立 <span class="hljs-number">10</span> 次循环       <span class="hljs-keyword">For</span> Chars = <span class="hljs-number">0</span> <span class="hljs-keyword">To</span> <span class="hljs-number">9</span>                                        ＇建立 <span class="hljs-number">10</span> 次循环           MyString = MyString &amp; Chars                      ＇将数字添加到字符串中      <span class="hljs-keyword">Next</span> Chars                                                   ＇Increment counter      MyString = MyString &amp; <span class="hljs-string">" "</span>                                ＇添加一个空格<span class="hljs-keyword">Next</span>  Words</code></pre><h3 id="3-9-2-For-Each…Next-语句"><a href="#3-9-2-For-Each…Next-语句" class="headerlink" title="3.9.2 For Each…Next 语句"></a>3.9.2 For Each…Next 语句</h3><p>主要功能是对一个数组或集合对象进行，让所有元素重复执行一次语句</p><pre><code class="hljs vb"><span class="hljs-keyword">For</span> <span class="hljs-keyword">Each</span> element <span class="hljs-keyword">In</span>  <span class="hljs-keyword">group</span>Statements[<span class="hljs-keyword">Exit</span> <span class="hljs-keyword">for</span>]Statements<span class="hljs-keyword">Next</span>  [element]如<span class="hljs-number">1</span>：<span class="hljs-keyword">For</span> <span class="hljs-keyword">Each</span> rang2 <span class="hljs-keyword">In</span>  range1     <span class="hljs-keyword">With</span> range2.interior             .colorindex=<span class="hljs-number">6</span>             .pattern=xlSolid     <span class="hljs-keyword">End</span> <span class="hljs-keyword">with</span><span class="hljs-keyword">Next</span></code></pre><h3 id="3-9-3-其他循环语句"><a href="#3-9-3-其他循环语句" class="headerlink" title="3.9.3 其他循环语句"></a>3.9.3 其他循环语句</h3><p>因为不介意使用所以这里就不过多介绍了。</p><h2 id="3-10-错误语句处理"><a href="#3-10-错误语句处理" class="headerlink" title="3.10 错误语句处理"></a>3.10 错误语句处理</h2><p>执行阶段有时会有错误的情况发生，利用OnError语句来处理错误，启动一个错误的处理程序。</p><p>语法如下：</p><p><code>On Error Goto Line</code>     当错误发生时，会立刻转移到line行去<br><code>On Error Resume Next</code>   当错误发生时，会立刻转移到发生错误的下一行去<br><code>On Erro Goto 0</code>       当错误发生时，会立刻停止过程中任何错误处理过程</p><h2 id="3-11-过程和函数"><a href="#3-11-过程和函数" class="headerlink" title="3.11 过程和函数"></a>3.11 过程和函数</h2><p>过程是构成程序的一个模块，往往用来完成一个相对独立的功能。过程可以使程序更清晰、更具结构性。VBA具有四种过程：Sub 过程、Function函数、Property属性过程和Event事件过程。</p><h3 id="3-11-1-Sub过程"><a href="#3-11-1-Sub过程" class="headerlink" title="3.11.1 Sub过程"></a>3.11.1 Sub过程</h3><p>Sub 过程的参数有两种传递方式：按值传递(ByVal)和按地址传递(ByRef)。如下例：</p><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> password (<span class="hljs-keyword">ByVal</span> x <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>, <span class="hljs-keyword">ByRef</span> y <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>)   <span class="hljs-keyword">If</span> y=<span class="hljs-number">100</span> <span class="hljs-keyword">then</span> y=x+y <span class="hljs-keyword">else</span> y=x-y   x=x+<span class="hljs-number">100</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">sub</span><span class="hljs-keyword">Sub</span> call_password ()   <span class="hljs-keyword">Dim</span> x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>   <span class="hljs-keyword">Dim</span> y1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>   x1=<span class="hljs-number">12</span>   y1=<span class="hljs-number">100</span>   Callpassword(x1,y1)   ‘调用过程方式：<span class="hljs-number">1.</span><span class="hljs-keyword">Call</span>  过程名(参数<span class="hljs-number">1</span>,  参数<span class="hljs-number">2</span>…);<span class="hljs-number">2.</span>  过程名 参数<span class="hljs-number">1</span>, 参数<span class="hljs-number">2</span>…   debug.print x1,y1     ‘结果是<span class="hljs-number">12</span>、<span class="hljs-number">112</span>，y1按地址传递改变了值，而x1按值传递，未改变原值<span class="hljs-keyword">End</span> <span class="hljs-keyword">sub</span></code></pre><h3 id="3-11-2-Function函数"><a href="#3-11-2-Function函数" class="headerlink" title="3.11.2 Function函数"></a>3.11.2 Function函数</h3><p>函数实际是实现一种映射，它通过一定的映射规则，完成运算并返回结果。参数传递也两种：按值传递(ByVal)和按地址传递(ByRef)。如下例：</p><pre><code class="hljs vb"><span class="hljs-keyword">Function</span> password(<span class="hljs-keyword">ByVal</span> x <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>, <span class="hljs-keyword">byref</span> y <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>) <span class="hljs-keyword">as</span> <span class="hljs-built_in">boolean</span>    <span class="hljs-keyword">If</span> y=<span class="hljs-number">100</span> <span class="hljs-keyword">then</span> y=x+y <span class="hljs-keyword">else</span> y=x-y    x=x+<span class="hljs-number">100</span>    <span class="hljs-keyword">if</span> y=<span class="hljs-number">150</span> <span class="hljs-keyword">then</span> password=<span class="hljs-literal">true</span> <span class="hljs-keyword">else</span> password=<span class="hljs-literal">false</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">Function</span><span class="hljs-keyword">Sub</span> call_password ()   <span class="hljs-keyword">Dim</span> x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>   <span class="hljs-keyword">Dim</span> y1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">integer</span>   x1=<span class="hljs-number">12</span>   y1=<span class="hljs-number">100</span>   <span class="hljs-keyword">if</span> password <span class="hljs-keyword">then</span> ‘调用函数：<span class="hljs-number">1.</span> 作为一个表达式放在=右端 ; <span class="hljs-number">2.</span> 作为参数使用   debug.print x1   <span class="hljs-keyword">end</span> <span class="hljs-keyword">if</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">sub</span></code></pre><h3 id="3-11-3-Property属性过程和Event事件过程"><a href="#3-11-3-Property属性过程和Event事件过程" class="headerlink" title="3.11.3 Property属性过程和Event事件过程"></a>3.11.3 Property属性过程和Event事件过程</h3><p>这是VB在对象功能上添加的两个过程，与对象特征密切相关，也是VBA比较重要组成，技术比较复杂，可以参考相关书籍。</p><h2 id="3-12-内部函数"><a href="#3-12-内部函数" class="headerlink" title="3.12 内部函数"></a>3.12 内部函数</h2><p>在VBA程序语言中有许多内置函数，可以帮助程序代码设计和减少代码的编写工作。</p><h3 id="3-12-1-测试函数"><a href="#3-12-1-测试函数" class="headerlink" title="3.12.1 测试函数"></a>3.12.1 测试函数</h3><p><code>IsNumeric(x)</code>      ‘是否为数字,  返回Boolean结果，True  or False</p><p><code>IsDate(x)</code>        ‘是否是日期,  返回Boolean结果，True  or False</p><p><code>IsEmpty（x）</code>     ‘是否为Empty, 返回Boolean结果，True  or False</p><p><code>IsArray(x)</code>       ‘指出变量是否为一个数组。</p><p><code>IsError(expression)</code>  ‘指出表达式是否为一个错误值</p><p><code>IsNull(expression)</code>   ‘指出表达式是否不包含任何有效数据 (Null)。</p><p><code>IsObject(identifier)</code>  ‘指出标识符是否表示对象变量</p><h3 id="3-12-2-数学函数"><a href="#3-12-2-数学函数" class="headerlink" title="3.12.2 数学函数"></a>3.12.2 数学函数</h3><p><code>Sin(X)</code>、<code>Cos(X)</code>、<code>Tan(X)</code>、<code>Atan(x)</code>  三角函数，单位为弧度</p><p><code>Log(x)</code> 返回x的自然对数</p><p><code>Exp(x)</code>返回 <img src="https://atts.w3cschool.cn/attachments/day_161019/201610190955366418.png" srcset="/img/loading.gif" alt="img"></p><p><code>Abs(x)</code> 返回绝对值</p><p><code>Int(number)</code>、<code>Fix(number)</code> 都返回参数的整数部分，区别：<code>Int</code> 将 -8.4 转换成 -9，而 <code>Fix</code> 将-8.4 转换成 -8</p><p><code>Sgn(number)</code> 返回一个 <code>Variant (Integer)</code>，指出参数的正负号</p><p><code>Sqr(number)</code> 返回一个 <code>Double</code>，指定参数的平方根</p><p><code>VarType(varname)</code> 返回一个 <code>Integer</code>，指出变量的子类型</p><p><code>Rnd（x）</code>返回0-1之间的单精度数据，x为随机种子</p><h3 id="3-12-3-字符串函数"><a href="#3-12-3-字符串函数" class="headerlink" title="3.12.3 字符串函数"></a>3.12.3 字符串函数</h3><p><code>Trim(string)</code>去掉string左右两端空白</p><p><code>Ltrim(string)</code>去掉string左端空白</p><p><code>Rtrim(string)</code>去掉string右端空白</p><p><code>Len(string)</code>计算string长度</p><p><code>Left(string, x)</code>取string左段x个字符组成的字符串</p><p><code>Right(string, x)</code>取string右段x个字符组成的字符串</p><p><code>Mid(string, start,x)</code>取string从start位开始的x个字符组成的字符串</p><p><code>Ucase(string)</code>转换为大写</p><p><code>Lcase(string)</code>转换为小写</p><p><code>Space(x)</code>返回x个空白的字符串</p><p><code>Asc(string)</code>返回一个 integer，代表字符串中首字母的字符代码</p><p><code>Chr(charcode)</code>返回 string,其中包含有与指定的字符代码相关的字符</p><h3 id="3-12-4-转换函数"><a href="#3-12-4-转换函数" class="headerlink" title="3.12.4 转换函数"></a>3.12.4 转换函数</h3><p><code>CBool(expression)</code>转换为Boolean型</p><p><code>CByte(expression)</code>转换为Byte型</p><p><code>CCur(expression)</code>转换为Currency型</p><p><code>CDate(expression)</code>转换为Date型</p><p><code>CDbl(expression)</code>转换为Double型</p><p><code>CDec(expression)</code>转换为Decemal型</p><p><code>CInt(expression)</code>转换为Integer型</p><p><code>CLng(expression)</code>转换为Long型</p><p><code>CSng(expression)</code>转换为Single型</p><p><code>CStr(expression)</code>转换为String型</p><p><code>CVar(expression)</code>转换为Variant型</p><p><code>Val(string)</code>转换为数据型</p><p><code>Str(number)</code>转换为String</p><h3 id="3-12-5-时间函数"><a href="#3-12-5-时间函数" class="headerlink" title="3.12.5 时间函数"></a>3.12.5 时间函数</h3><p><code>Now</code>  返回一个 Variant (Date)，根据计算机系统设置的日期和时间来指定日期和时间。</p><p><code>Date</code>返回包含系统日期的 Variant (Date)。</p><p><code>Time</code> 返回一个指明当前系统时间的 Variant (Date)。</p><p><code>Timer</code> 返回一个 Single，代表从午夜开始到现在经过的秒数。</p><p><code>TimeSerial(hour, minute, second)</code> 返回一个 Variant (Date)，包含具有具体时、分、秒的时间。</p><p><code>DateDiff(interval, date1, date2[, firstdayofweek[, firstweekofyear]])</code> 返回 Variant(Long) 的值，表示两个指定日期间的时间间隔数目</p><p><code>Second(time) 返回一个 Variant (Integer)</code>，其值为 0 到 59 之间的整数，表示一分钟之中的某个秒</p><p><code>Minute(time) 返回一个 Variant (Integer)</code>，其值为 0 到 59 之间的整数，表示一小时中的某分钟Hour(time)  返回一个 </p><p><code>Variant(Integer)</code>，其值为 0 到 23 之间的整数，表示一天之中的某一钟点</p><p><code>Day(date)</code>  返回一个 <code>Variant(Integer)</code>，其值为 1 到 31 之间的整数，表示一个月中的某一日</p><p><code>Month(date)</code> 返回一个 <code>Variant(Integer)</code>，其值为 1 到 12 之间的整数，表示一年中的某月</p><p><code>Year(date)</code>  返回 <code>Variant (Integer)</code>，包含表示年份的整数。</p><p><code>Weekday(date, [firstdayofweek])</code> 返回一个 <code>Variant (Integer)</code>，包含一个整数，代表某个日期是星期几</p><h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4. 最后"></a>4. 最后</h1><p>最后给出之前的<code>1.4 感受VBA</code>中我使用到的代码。</p><pre><code class="hljs vb"><span class="hljs-keyword">Sub</span> 游戏排行宏()<span class="hljs-comment">'</span><span class="hljs-comment">' 宏2 宏</span><span class="hljs-comment">'</span><span class="hljs-comment">'核心代码</span>    <span class="hljs-keyword">For</span> i = <span class="hljs-number">2</span> <span class="hljs-keyword">To</span> <span class="hljs-number">31</span>    isHave = <span class="hljs-literal">False</span>     <span class="hljs-keyword">For</span> j = <span class="hljs-number">2</span> <span class="hljs-keyword">To</span> <span class="hljs-number">31</span>     <span class="hljs-keyword">If</span> Range(<span class="hljs-string">"F"</span> &amp; i) = Range(<span class="hljs-string">"B"</span> &amp; j) <span class="hljs-keyword">Then</span>     isHave = <span class="hljs-literal">True</span>     <span class="hljs-keyword">If</span> Range(<span class="hljs-string">"E"</span> &amp; i) - Range(<span class="hljs-string">"A"</span> &amp; j) &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>     Count = Range(<span class="hljs-string">"E"</span> &amp; i) - Range(<span class="hljs-string">"A"</span> &amp; j)     Range(<span class="hljs-string">"F"</span> &amp; i) = Range(<span class="hljs-string">"F"</span> &amp; i) &amp; <span class="hljs-string">" ↓"</span> &amp; Count     Range(<span class="hljs-string">"E"</span> &amp; i &amp; <span class="hljs-string">":"</span> &amp; <span class="hljs-string">"G"</span> &amp; i).<span class="hljs-keyword">Select</span>     <span class="hljs-keyword">With</span> Selection.Font        .ThemeColor = xlThemeColorAccent6        .TintAndShade = <span class="hljs-number">0</span>     <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>     <span class="hljs-keyword">ElseIf</span> Range(<span class="hljs-string">"E"</span> &amp; i) - Range(<span class="hljs-string">"A"</span> &amp; j) &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">Then</span>     Count = Abs(Range(<span class="hljs-string">"E"</span> &amp; i) - Range(<span class="hljs-string">"A"</span> &amp; j))     Range(<span class="hljs-string">"F"</span> &amp; i) = Range(<span class="hljs-string">"F"</span> &amp; i) &amp; <span class="hljs-string">" ↑"</span> &amp; Count     Range(<span class="hljs-string">"E"</span> &amp; i &amp; <span class="hljs-string">":"</span> &amp; <span class="hljs-string">"G"</span> &amp; i).<span class="hljs-keyword">Select</span>     <span class="hljs-keyword">With</span> Selection.Font        .Color = <span class="hljs-number">-16776961</span>        .TintAndShade = <span class="hljs-number">0</span>     <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>     <span class="hljs-keyword">Exit</span> <span class="hljs-keyword">For</span>     <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>     <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>     <span class="hljs-keyword">Next</span>    <span class="hljs-keyword">If</span> isHave = <span class="hljs-literal">False</span> <span class="hljs-keyword">Then</span>    Range(<span class="hljs-string">"F"</span> &amp; i) = Range(<span class="hljs-string">"F"</span> &amp; i) &amp; <span class="hljs-string">" ↑new"</span>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">If</span>    <span class="hljs-keyword">Next</span><span class="hljs-comment">' 下面为调整格式，直接通过录制宏拷贝过来的代码</span>    Columns(<span class="hljs-string">"E:E"</span>).ColumnWidth = <span class="hljs-number">7</span>    Columns(<span class="hljs-string">"F:F"</span>).ColumnWidth = <span class="hljs-number">50</span>    Columns(<span class="hljs-string">"G:G"</span>).ColumnWidth = <span class="hljs-number">21.5</span>    Range(<span class="hljs-string">"E1:G31"</span>).<span class="hljs-keyword">Select</span>    Range(<span class="hljs-string">"F16"</span>).Activate    Selection.Borders(xlDiagonalDown).LineStyle = xlNone    Selection.Borders(xlDiagonalUp).LineStyle = xlNone    <span class="hljs-keyword">With</span> Selection.Borders(xlEdgeLeft)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Borders(xlEdgeTop)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Borders(xlEdgeBottom)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Borders(xlEdgeRight)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Borders(xlInsideVertical)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Borders(xlInsideHorizontal)        .LineStyle = xlContinuous        .ColorIndex = <span class="hljs-number">0</span>        .TintAndShade = <span class="hljs-number">0</span>        .Weight = xlThin    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    <span class="hljs-keyword">With</span> Selection.Font        .Name = <span class="hljs-string">"阿里巴巴普惠体"</span>        .Size = <span class="hljs-number">11</span>        .Strikethrough = <span class="hljs-literal">False</span>        .Superscript = <span class="hljs-literal">False</span>        .Subscript = <span class="hljs-literal">False</span>        .OutlineFont = <span class="hljs-literal">False</span>        .Shadow = <span class="hljs-literal">False</span>        .Underline = xlUnderlineStyleNone        .TintAndShade = <span class="hljs-number">0</span>        .ThemeFont = xlThemeFontNone    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span>    Range(<span class="hljs-string">"1:1,3:3,5:5,7:7,9:9"</span>).<span class="hljs-keyword">Select</span>    Range(<span class="hljs-string">"A9"</span>).Activate    ActiveWindow.SmallScroll Down:=<span class="hljs-number">6</span>    Range( _        <span class="hljs-string">"1:1,3:3,5:5,7:7,9:9,11:11,13:13,15:15,17:17,19:19,21:21,23:23,25:25,27:27,29:29,31:31"</span> _        ).<span class="hljs-keyword">Select</span>    Range(<span class="hljs-string">"A31"</span>).Activate    <span class="hljs-keyword">With</span> Selection.Interior        .Pattern = xlSolid        .PatternColorIndex = xlAutomatic        .ThemeColor = xlThemeColorDark1        .TintAndShade = <span class="hljs-number">-0.149998474074526</span>        .PatternTintAndShade = <span class="hljs-number">0</span>    <span class="hljs-keyword">End</span> <span class="hljs-keyword">With</span><span class="hljs-keyword">End</span> <span class="hljs-keyword">Sub</span></code></pre><p>其实有个简单的方法，你先将你需要的功能通过<code>录制宏</code>录制下来，再进行编辑这个宏就可以了。</p><p>如果上面的知识你都差不多了解了的话，那么VBA就基本上入门了，如果遇到什么无法解决的问题，到时候再通过百度进行学习就可以了。</p><h2 id="4-1-参考资料"><a href="#4-1-参考资料" class="headerlink" title="4.1 参考资料"></a>4.1 参考资料</h2><p><a href="https://www.w3cschool.cn/excelvba/excelvba-basics.html" target="_blank" rel="noopener">VBA语言的基础认识</a></p>]]></content>
    
    
    <categories>
      
      <category>Excel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>宏命令</tag>
      
      <tag>VBA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月28日</title>
    <link href="/2020/06/29/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8828%E6%97%A5/"/>
    <url>/2020/06/29/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8828%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>72050</td></tr><tr><td>2</td><td>地下城与勇士+dnf ↑1</td><td>48762</td></tr><tr><td>3</td><td>我的世界+minecraft ↓1</td><td>41460</td></tr><tr><td>4</td><td>魔域</td><td>25931</td></tr><tr><td>5</td><td>穿越火线+cf</td><td>20590</td></tr><tr><td>6</td><td>刀塔2+DOTA2 ↑4</td><td>15827</td></tr><tr><td>7</td><td>最终幻想14+ff14</td><td>13792</td></tr><tr><td>8</td><td>QQ飞车 ↑22</td><td>13337</td></tr><tr><td>9</td><td>绝地求生+pubg ↓3</td><td>13026</td></tr><tr><td>10</td><td>梦幻西游 ↓2</td><td>13020</td></tr><tr><td>11</td><td>csgo ↓2</td><td>11115</td></tr><tr><td>12</td><td>魔兽世界+wow</td><td>10428</td></tr><tr><td>13</td><td>天龙八部 ↓2</td><td>9895</td></tr><tr><td>14</td><td>冒险岛 ↓1</td><td>9426</td></tr><tr><td>15</td><td>激战2 ↑2</td><td>8618</td></tr><tr><td>16</td><td>坦克世界 ↓2</td><td>8614</td></tr><tr><td>17</td><td>炉石传说 ↓1</td><td>8211</td></tr><tr><td>18</td><td>逆水寒</td><td>7634</td></tr><tr><td>19</td><td>方舟生存进化 ↓4</td><td>6881</td></tr><tr><td>20</td><td>诛仙 ↑3</td><td>6857</td></tr><tr><td>21</td><td>流放之路 ↓2</td><td>6526</td></tr><tr><td>22</td><td>传奇 ↓2</td><td>6396</td></tr><tr><td>23</td><td>守望先锋 ↓2</td><td>5972</td></tr><tr><td>24</td><td>EVE ↑1</td><td>5131</td></tr><tr><td>25</td><td>龙之谷 ↑1</td><td>5064</td></tr><tr><td>26</td><td>变形金刚 ↓4</td><td>4852</td></tr><tr><td>27</td><td>大话西游 ↓3</td><td>4760</td></tr><tr><td>28</td><td>天涯明月刀 ↓1</td><td>4412</td></tr><tr><td>29</td><td>剑灵 ↓1</td><td>4359</td></tr><tr><td>30</td><td>龙族 ↓1</td><td>4007</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>117788</td></tr><tr><td>2</td><td>和平精英 ↑1</td><td>48081</td></tr><tr><td>3</td><td>我的世界+mc ↑1</td><td>41630</td></tr><tr><td>4</td><td>迷你世界 ↓2</td><td>41477</td></tr><tr><td>5</td><td>荒野乱斗</td><td>36665</td></tr><tr><td>6</td><td>最强蜗牛 ↑1</td><td>30939</td></tr><tr><td>7</td><td>香肠派对 ↓1</td><td>18343</td></tr><tr><td>8</td><td>阴阳师 ↑2</td><td>13141</td></tr><tr><td>9</td><td>第五人格</td><td>11770</td></tr><tr><td>10</td><td>剑网3指尖江湖 ↓2</td><td>10572</td></tr><tr><td>11</td><td>炉石传说 ↑3</td><td>8211</td></tr><tr><td>12</td><td>明日之后</td><td>7681</td></tr><tr><td>13</td><td>球球大作战 ↓2</td><td>7623</td></tr><tr><td>14</td><td>欢乐斗地主 ↑1</td><td>7486</td></tr><tr><td>15</td><td>QQ飞车手游 ↑new</td><td>7305</td></tr><tr><td>16</td><td>灌篮高手</td><td>7101</td></tr><tr><td>17</td><td>部落冲突 ↓4</td><td>6660</td></tr><tr><td>18</td><td>崩坏3 ↓1</td><td>6469</td></tr><tr><td>19</td><td>率土之滨</td><td>5515</td></tr><tr><td>20</td><td>碧蓝航线</td><td>4931</td></tr><tr><td>21</td><td>开心消消乐 ↑1</td><td>4808</td></tr><tr><td>22</td><td>大话西游 ↓1</td><td>4760</td></tr><tr><td>23</td><td>梦幻西游手游 ↑1</td><td>4679</td></tr><tr><td>24</td><td>狼人杀 ↓6</td><td>4479</td></tr><tr><td>25</td><td>饥荒 ↓2</td><td>3797</td></tr><tr><td>26</td><td>火影忍者手游 ↓1</td><td>3672</td></tr><tr><td>27</td><td>黑猫警长</td><td>3048</td></tr><tr><td>28</td><td>奇迹暖暖 ↓2</td><td>2957</td></tr><tr><td>29</td><td>问道 ↑new</td><td>2814</td></tr><tr><td>30</td><td>爱上消消消 ↓2</td><td>2740</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月27日</title>
    <link href="/2020/06/28/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8827%E6%97%A5/"/>
    <url>/2020/06/28/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8827%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>80864</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>64804</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>41146</td></tr><tr><td>4</td><td>魔域 ↑1</td><td>40355</td></tr><tr><td>5</td><td>穿越火线+cf ↓1</td><td>24095</td></tr><tr><td>6</td><td>绝地求生+pubg</td><td>15398</td></tr><tr><td>7</td><td>最终幻想14+ff14</td><td>14050</td></tr><tr><td>8</td><td>梦幻西游</td><td>12110</td></tr><tr><td>9</td><td>csgo</td><td>10930</td></tr><tr><td>10</td><td>刀塔2+DOTA2</td><td>10808</td></tr><tr><td>11</td><td>天龙八部</td><td>10426</td></tr><tr><td>12</td><td>魔兽世界+wow ↑3</td><td>9588</td></tr><tr><td>13</td><td>冒险岛 ↑1</td><td>9230</td></tr><tr><td>14</td><td>坦克世界 ↓2</td><td>9220</td></tr><tr><td>15</td><td>方舟生存进化 ↑1</td><td>9149</td></tr><tr><td>16</td><td>炉石传说 ↓3</td><td>8789</td></tr><tr><td>17</td><td>激战2</td><td>8551</td></tr><tr><td>18</td><td>逆水寒</td><td>8111</td></tr><tr><td>19</td><td>流放之路 ↑1</td><td>7270</td></tr><tr><td>20</td><td>传奇 ↑2</td><td>7012</td></tr><tr><td>21</td><td>守望先锋 ↓2</td><td>6801</td></tr><tr><td>22</td><td>变形金刚 ↓1</td><td>6286</td></tr><tr><td>23</td><td>诛仙</td><td>5352</td></tr><tr><td>24</td><td>大话西游</td><td>5272</td></tr><tr><td>25</td><td>EVE ↑2</td><td>4809</td></tr><tr><td>26</td><td>龙之谷 ↓1</td><td>4785</td></tr><tr><td>27</td><td>天涯明月刀 ↑new!</td><td>4602</td></tr><tr><td>28</td><td>剑灵 ↑1</td><td>4280</td></tr><tr><td>29</td><td>龙族 ↓1</td><td>4177</td></tr><tr><td>30</td><td>QQ飞车 ↓4</td><td>4155</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>181589</td></tr><tr><td>2</td><td>迷你世界</td><td>75040</td></tr><tr><td>3</td><td>和平精英</td><td>70584</td></tr><tr><td>4</td><td>我的世界+mc</td><td>64198</td></tr><tr><td>5</td><td>荒野乱斗 ↑1</td><td>41588</td></tr><tr><td>6</td><td>香肠派对 ↓1</td><td>36832</td></tr><tr><td>7</td><td>最强蜗牛 ↑1</td><td>32067</td></tr><tr><td>8</td><td>剑网3指尖江湖 ↓1</td><td>20884</td></tr><tr><td>9</td><td>第五人格</td><td>17350</td></tr><tr><td>10</td><td>阴阳师</td><td>14691</td></tr><tr><td>11</td><td>球球大作战</td><td>11865</td></tr><tr><td>12</td><td>明日之后</td><td>9948</td></tr><tr><td>13</td><td>部落冲突</td><td>8943</td></tr><tr><td>14</td><td>炉石传说</td><td>8789</td></tr><tr><td>15</td><td>欢乐斗地主</td><td>7822</td></tr><tr><td>16</td><td>灌篮高手</td><td>7737</td></tr><tr><td>17</td><td>崩坏3</td><td>7021</td></tr><tr><td>18</td><td>狼人杀</td><td>5546</td></tr><tr><td>19</td><td>率土之滨 ↑2</td><td>5307</td></tr><tr><td>20</td><td>碧蓝航线 ↓1</td><td>5299</td></tr><tr><td>21</td><td>大话西游 ↓1</td><td>5272</td></tr><tr><td>22</td><td>开心消消乐 ↑2</td><td>4702</td></tr><tr><td>23</td><td>饥荒</td><td>4616</td></tr><tr><td>24</td><td>梦幻西游手游 ↓2</td><td>4498</td></tr><tr><td>25</td><td>火影忍者手游</td><td>4305</td></tr><tr><td>26</td><td>奇迹暖暖</td><td>4041</td></tr><tr><td>27</td><td>黑猫警长</td><td>3352</td></tr><tr><td>28</td><td>爱上消消消 ↑2</td><td>3106</td></tr><tr><td>29</td><td>荒野行动</td><td>2810</td></tr><tr><td>30</td><td>一梦江湖 ↓2</td><td>2788</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo进阶-生成站点地图（Sitemap）</title>
    <link href="/2020/06/27/Hexo%E8%BF%9B%E9%98%B6-%E7%94%9F%E6%88%90%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%EF%BC%88Sitemap%EF%BC%89/"/>
    <url>/2020/06/27/Hexo%E8%BF%9B%E9%98%B6-%E7%94%9F%E6%88%90%E7%AB%99%E7%82%B9%E5%9C%B0%E5%9B%BE%EF%BC%88Sitemap%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>在之前的文章中，介绍了如何通过Hexo搭建一个个人博客：</p><a href="/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/" title="一个简单易用的制作博客的框架：Hexo">一个简单易用的制作博客的框架：Hexo</a><p><br/>当时我仅仅是觉得<code>Hexo</code>搭建一个博客非常的方便，但是还是不如<code>Vue</code>或者<code>React</code>的适配性强，直到后面我开始接触<code>SEO</code>，才发现<code>Vue</code>和<code>React</code>都是客户端渲染，对<code>SEO</code>非常不友好，反观<code>Hexo</code>，拥有清晰的页面结构，纯静态界面，对<code>SEO</code>那是相当的友好。</p><p>正因为这样，我用<code>Hexo</code>搭建了博客后，这几天一直在学习<code>Hexo</code>以及SEO相关的知识。</p><h1 id="1-站点地图（Sitemap）"><a href="#1-站点地图（Sitemap）" class="headerlink" title="1. 站点地图（Sitemap）"></a>1. 站点地图（Sitemap）</h1><blockquote><p>站点地图描述了一个网站的架构。 它可以是一个任意形式的文档，用作网页设计的设计工具，也可以是列出网站中所有页面的一个网页，通常采用分级形式。这有助于访问者以及搜索引擎的爬虫找到网站中的页面。</p></blockquote><p>站点地图为<code>SEO</code>带来的好处。 </p><ol><li>为搜索引擎爬虫提供可以浏览整个网站的链接；</li><li>为搜索引擎爬虫提供一些链接，指向动态页面或者采用其他方法比较难以到达的页面；</li><li>如果访问者试图访问网站所在域内并不存在的URL，那么这个访问者就会被转到“无法找到文件”的错误页面，而网站地图可以作为该页面的“准”内容。</li></ol><p><strong>说白了就是让搜索引擎的爬虫，尽可能多的收录你站点上的页面，页面收录的越多，你的网站的流量就会越大。</strong></p><h1 id="2-Hexo如何生成Sitemap"><a href="#2-Hexo如何生成Sitemap" class="headerlink" title="2. Hexo如何生成Sitemap"></a>2. Hexo如何生成Sitemap</h1><h2 id="2-1-Google-版本"><a href="#2-1-Google-版本" class="headerlink" title="2.1 Google 版本"></a>2.1 Google 版本</h2><p>进入到根目录下，打开CMD，运行下面的命令：</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-generator-sitemap <span class="hljs-comment">--save</span></code></pre><h2 id="2-2-Baidu-版本"><a href="#2-2-Baidu-版本" class="headerlink" title="2.2 Baidu 版本"></a>2.2 Baidu 版本</h2><p>进入到根目录下，打开CMD，运行下面的命令：</p><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save</code></pre><h2 id="2-3-生成站点地图"><a href="#2-3-生成站点地图" class="headerlink" title="2.3 生成站点地图"></a>2.3 生成站点地图</h2><p>安装结束后，在<code>_config.yml</code>中找到<code>url</code>，改成你自己的域名。 </p><pre><code class="hljs xml"># URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: 改成你自己的域名root: /permalink: :year/:month/:day/:title/permalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks  trailing_html: true # Set to false to remove trailing '.html' from permalinks</code></pre><p>更改完成后，每次进行打包的时候，会自动在<code>public</code>文件夹下生成<code>sitemap.xml</code>和<code>baidusitemap.xml</code>分别用于Google和百度。</p><h1 id="3-查看"><a href="#3-查看" class="headerlink" title="3. 查看"></a>3. 查看</h1><p>将页面提交到服务器后，通过域名<code>/sitemap.xml</code>或者域名<code>/baidusitemap.xml</code>可以进行访问<code>sitemap</code>。 </p><p>最后到Google或百度对应的站长工具进行提交<code>sitemap</code>就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>站点地图</tag>
      
      <tag>Hexo</tag>
      
      <tag>SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月26日</title>
    <link href="/2020/06/27/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8826%E6%97%A5/"/>
    <url>/2020/06/27/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8826%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>90238</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>71494</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>49768</td></tr><tr><td>4</td><td>穿越火线+cf</td><td>26568</td></tr><tr><td>5</td><td>魔域    ↑1</td><td>23032</td></tr><tr><td>6</td><td>绝地求生+pubg    ↓1</td><td>17080</td></tr><tr><td>7</td><td>最终幻想14+ff14</td><td>14315</td></tr><tr><td>8</td><td>梦幻西游    ↑2</td><td>12183</td></tr><tr><td>9</td><td>csgo    ↓2</td><td>11808</td></tr><tr><td>10</td><td>刀塔2+DOTA2    ↓2</td><td>11236</td></tr><tr><td>11</td><td>天龙八部    ↑3</td><td>10699</td></tr><tr><td>12</td><td>坦克世界</td><td>10180</td></tr><tr><td>13</td><td>炉石传说    ↓4</td><td>9881</td></tr><tr><td>14</td><td>冒险岛    ↓2</td><td>9640</td></tr><tr><td>15</td><td>魔兽世界+wow    ↑3</td><td>9585</td></tr><tr><td>16</td><td>方舟生存进化    ↑1</td><td>9415</td></tr><tr><td>17</td><td>激战2    ↓2</td><td>9285</td></tr><tr><td>18</td><td>逆水寒    ↓5</td><td>8860</td></tr><tr><td>19</td><td>守望先锋</td><td>7324</td></tr><tr><td>20</td><td>流放之路</td><td>6597</td></tr><tr><td>21</td><td>变形金刚</td><td>6293</td></tr><tr><td>22</td><td>传奇    ↑5</td><td>5880</td></tr><tr><td>23</td><td>诛仙    ↑3</td><td>5676</td></tr><tr><td>24</td><td>大话西游    ↓1</td><td>5561</td></tr><tr><td>25</td><td>龙之谷    ↓3</td><td>5041</td></tr><tr><td>26</td><td>QQ飞车    ↓2</td><td>5020</td></tr><tr><td>27</td><td>EVE    ↑2</td><td>4718</td></tr><tr><td>28</td><td>龙族    ↓3</td><td>4644</td></tr><tr><td>29</td><td>剑灵    ↑1</td><td>4368</td></tr><tr><td>30</td><td>qq三国    ↓2</td><td>3856</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>王者荣耀</td><td>119944</td></tr><tr><td>2</td><td>迷你世界    ↑1</td><td>86552</td></tr><tr><td>3</td><td>和平精英    ↓1</td><td>83153</td></tr><tr><td>4</td><td>我的世界+mc</td><td>70675</td></tr><tr><td>5</td><td>香肠派对</td><td>46616</td></tr><tr><td>6</td><td>荒野乱斗    ↑1</td><td>42836</td></tr><tr><td>7</td><td>剑网3指尖江湖    ↓1</td><td>41262</td></tr><tr><td>8</td><td>最强蜗牛</td><td>34440</td></tr><tr><td>9</td><td>第五人格</td><td>20012</td></tr><tr><td>10</td><td>阴阳师    ↑1</td><td>14871</td></tr><tr><td>11</td><td>球球大作战    ↓1</td><td>14478</td></tr><tr><td>12</td><td>明日之后    ↑2</td><td>11629</td></tr><tr><td>13</td><td>部落冲突    ↓1</td><td>10776</td></tr><tr><td>14</td><td>炉石传说    ↓1</td><td>9881</td></tr><tr><td>15</td><td>欢乐斗地主    ↑1</td><td>8522</td></tr><tr><td>16</td><td>灌篮高手    ↑1</td><td>8033</td></tr><tr><td>17</td><td>崩坏3    ↓2</td><td>7974</td></tr><tr><td>18</td><td>狼人杀</td><td>6720</td></tr><tr><td>19</td><td>碧蓝航线</td><td>5954</td></tr><tr><td>20</td><td>大话西游</td><td>5561</td></tr><tr><td>21</td><td>率土之滨    ↑3</td><td>5319</td></tr><tr><td>22</td><td>梦幻西游手游    ↑3</td><td>5277</td></tr><tr><td>23</td><td>饥荒    ↓2</td><td>5209</td></tr><tr><td>24</td><td>开心消消乐    ↓2</td><td>5052</td></tr><tr><td>25</td><td>火影忍者手游    ↑1</td><td>4862</td></tr><tr><td>26</td><td>奇迹暖暖    ↓3</td><td>4574</td></tr><tr><td>27</td><td>黑猫警长</td><td>3726</td></tr><tr><td>28</td><td>一梦江湖</td><td>3326</td></tr><tr><td>29</td><td>荒野行动</td><td>3083</td></tr><tr><td>30</td><td>爱上消消消    ↑new!</td><td>3074</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏排行榜/2020年06月25日</title>
    <link href="/2020/06/26/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8825%E6%97%A5/"/>
    <url>/2020/06/26/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/2020%E5%B9%B406%E6%9C%8825%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>现在的游戏市场很奇怪，奇怪到你根本找不到一个靠谱的游戏排行榜单，在百度上面搜索“游戏排行榜”，会发现搜索出来的大部分页面的游戏榜单几乎都是软广告。根本没有听过或者身边根本没有人玩的游戏还会排到排行榜首位。而“英雄联盟”，“地下城与勇士”，“穿越火线”这种一看就很火的游戏却没有出现在榜单上。</p><p>在之前的时候我很喜欢多玩的游戏排行榜单，它根据百度搜索的热度前10位进行排行，不说非常靠谱，但是也表达出了当下比较火的游戏，然而现在多玩已经不再提供这个榜单了。</p><p>而我自身无聊的时候就喜欢看看这些游戏排行榜，所以我决定通过百度指数，拟出一份比较有参考价值的游戏榜单，该榜单尽量做到每天更新，如果本系列还比较受欢迎，我会考虑在我的博客上面建立一个单独的页面，每天进行统计。</p><p><strong>由于本排行榜的游戏收集有限，所以有些游戏可能存在百度指数很高，但是没有出现在排行榜中的情况，如果有的话可以在评论里面告诉我，我会添加新的关键词。</strong></p><h1 id="网络游戏PC端"><a href="#网络游戏PC端" class="headerlink" title="网络游戏PC端"></a>网络游戏PC端</h1><table><thead><tr><th>名次</th><th>百度搜索关键词</th><th>百度指数</th></tr></thead><tbody><tr><td>1</td><td>英雄联盟+lol</td><td>85383</td></tr><tr><td>2</td><td>我的世界+minecraft</td><td>83928</td></tr><tr><td>3</td><td>地下城与勇士+dnf</td><td>36816</td></tr><tr><td>4</td><td>穿越火线+cf</td><td>29996</td></tr><tr><td>5</td><td>绝地求生+pubg</td><td>18142</td></tr><tr><td>6</td><td>魔域</td><td>17020</td></tr><tr><td>7</td><td>最终幻想14+ff14</td><td>15392</td></tr><tr><td>8</td><td>刀塔2+DOTA2</td><td>14935</td></tr><tr><td>9</td><td>炉石传说</td><td>13056</td></tr><tr><td>10</td><td>梦幻西游</td><td>12655</td></tr><tr><td>11</td><td>csgo</td><td>12533</td></tr><tr><td>12</td><td>坦克世界</td><td>11784</td></tr><tr><td>13</td><td>逆水寒</td><td>11780</td></tr><tr><td>14</td><td>天龙八部</td><td>11548</td></tr><tr><td>15</td><td>激战2</td><td>11245</td></tr><tr><td>16</td><td>冒险岛</td><td>10611</td></tr><tr><td>17</td><td>方舟生存进化</td><td>9231</td></tr><tr><td>18</td><td>魔兽世界+wow</td><td>8733</td></tr><tr><td>19</td><td>守望先锋</td><td>8240</td></tr><tr><td>20</td><td>流放之路</td><td>7010</td></tr><tr><td>21</td><td>变形金刚</td><td>6720</td></tr><tr><td>22</td><td>龙之谷</td><td>6250</td></tr><tr><td>23</td><td>大话西游</td><td>6120</td></tr><tr><td>24</td><td>QQ飞车</td><td>5967</td></tr><tr><td>25</td><td>龙族</td><td>5376</td></tr><tr><td>26</td><td>诛仙</td><td>5245</td></tr><tr><td>27</td><td>传奇</td><td>5042</td></tr><tr><td>28</td><td>qq三国</td><td>4919</td></tr><tr><td>29</td><td>EVE</td><td>4840</td></tr><tr><td>30</td><td>剑灵</td><td>4664</td></tr></tbody></table><h1 id="手机游戏"><a href="#手机游戏" class="headerlink" title="手机游戏"></a>手机游戏</h1><table><thead><tr><th align="left">名次</th><th align="left">百度搜索关键词</th><th align="left">百度指数</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">王者荣耀</td><td align="left">142153</td></tr><tr><td align="left">2</td><td align="left">和平精英</td><td align="left">104065</td></tr><tr><td align="left">3</td><td align="left">迷你世界</td><td align="left">98965</td></tr><tr><td align="left">4</td><td align="left">我的世界+minecraft</td><td align="left">83928</td></tr><tr><td align="left">5</td><td align="left">香肠派对</td><td align="left">57708</td></tr><tr><td align="left">6</td><td align="left">剑网3指尖江湖</td><td align="left">57456</td></tr><tr><td align="left">7</td><td align="left">荒野乱斗</td><td align="left">47794</td></tr><tr><td align="left">8</td><td align="left">最强蜗牛</td><td align="left">37357</td></tr><tr><td align="left">9</td><td align="left">第五人格</td><td align="left">23535</td></tr><tr><td align="left">10</td><td align="left">球球大作战</td><td align="left">17885</td></tr><tr><td align="left">11</td><td align="left">阴阳师</td><td align="left">16441</td></tr><tr><td align="left">12</td><td align="left">部落冲突</td><td align="left">13317</td></tr><tr><td align="left">13</td><td align="left">炉石传说</td><td align="left">13056</td></tr><tr><td align="left">14</td><td align="left">明日之后</td><td align="left">12172</td></tr><tr><td align="left">15</td><td align="left">崩坏3</td><td align="left">9387</td></tr><tr><td align="left">16</td><td align="left">欢乐斗地主</td><td align="left">9156</td></tr><tr><td align="left">17</td><td align="left">灌篮高手</td><td align="left">7723</td></tr><tr><td align="left">18</td><td align="left">狼人杀</td><td align="left">7056</td></tr><tr><td align="left">19</td><td align="left">碧蓝航线</td><td align="left">6329</td></tr><tr><td align="left">20</td><td align="left">大话西游</td><td align="left">6120</td></tr><tr><td align="left">21</td><td align="left">饥荒</td><td align="left">5885</td></tr><tr><td align="left">22</td><td align="left">开心消消乐</td><td align="left">5223</td></tr><tr><td align="left">23</td><td align="left">奇迹暖暖</td><td align="left">4926</td></tr><tr><td align="left">24</td><td align="left">率土之滨</td><td align="left">4833</td></tr><tr><td align="left">25</td><td align="left">梦幻西游手游</td><td align="left">4750</td></tr><tr><td align="left">26</td><td align="left">火影忍者手游</td><td align="left">4695</td></tr><tr><td align="left">27</td><td align="left">黑猫警长</td><td align="left">4152</td></tr><tr><td align="left">28</td><td align="left">一梦江湖</td><td align="left">3464</td></tr><tr><td align="left">29</td><td align="left">荒野行动</td><td align="left">3274</td></tr><tr><td align="left">30</td><td align="left">血族</td><td align="left">3208</td></tr></tbody></table><h1 id="更多榜单"><a href="#更多榜单" class="headerlink" title="更多榜单"></a><a href="https://www.cclliang.com/categories/%E6%B8%B8%E6%88%8F%E6%8E%92%E8%A1%8C%E6%A6%9C/">更多榜单</a></h1>]]></content>
    
    
    <categories>
      
      <category>游戏排行榜</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排行榜</tag>
      
      <tag>游戏</tag>
      
      <tag>hide</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客评论系统：Valine</title>
    <link href="/2020/06/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%9AValine/"/>
    <url>/2020/06/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%9AValine/</url>
    
    <content type="html"><![CDATA[<p>之前我也写过一篇个人博客的评论系统：Gitalk。</p><p><a href="https://zhuanlan.zhihu.com/p/141078552" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/141078552</a></p><p>但是这个评论系统有一个不太好的地方，它需要使用GitHub账号才能够进行评论，这就涉及到很多人不想暴露自己的隐私或者没有GitHub账号就无法进行评论。</p><p>所以当我在重新搭建我的个人博客时，找了一款新的评论系统：Valine。</p><p><a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>它可以实现不用进行登录就可以使用留言功能。</p><p><img src="/image/v2-9f9e697dd96073a019396aac5f531096_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>首先需要一个LeanCloud账号：</p><p><a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">https://leancloud.cn/dashboard/login.html#/signup</a></p><p>注册时需要进行实名认证。</p><p><img src="/image/v2-f66fe2f66f86046bf32f382c78517fef_720w.png" srcset="/img/loading.gif" alt="img"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了：</p><p><img src="/image/v2-806cbb9bc64a5463238e541e711a7764_720w.png" srcset="/img/loading.gif" alt="img"></p><p>接下来直接参考</p><p><a href="https://valine.js.org/quickstart.htmlvaline.js.org" target="_blank" rel="noopener">https://valine.js.org/quickstart.htmlvaline.js.org</a></p><p>进行配置就可以了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>由于各种实名认证，最后我放弃将它集成在我的博客上面，有兴趣的朋友可以直接按照官方文档进行集成，还是非常简单方便的。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/Vue服务器渲染优秀项目：Nuxt.js</title>
    <link href="/2020/06/22/web%E5%BC%80%E5%8F%91/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%EF%BC%9ANuxt.js/"/>
    <url>/2020/06/22/web%E5%BC%80%E5%8F%91/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%EF%BC%9ANuxt.js/</url>
    
    <content type="html"><![CDATA[<h1 id="1-服务器渲染"><a href="#1-服务器渲染" class="headerlink" title="1. 服务器渲染"></a>1. 服务器渲染</h1><h2 id="1-1-什么是服务器渲染"><a href="#1-1-什么是服务器渲染" class="headerlink" title="1. 1 什么是服务器渲染"></a>1. 1 什么是服务器渲染</h2><p><a href="[https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F](https://ssr.vuejs.org/zh/#什么是服务器端渲染-ssr-？)">Vue.js 服务器端渲染指南 </a></p><p>Vue官网已经对服务器渲染讲解的很详细了，可以直接参考上面的文档。不过就是因为讲解的太过于全面，所以有时候可能看的一头雾水。</p><h2 id="1-2-为什么需要服务器渲染"><a href="#1-2-为什么需要服务器渲染" class="headerlink" title="1.2 为什么需要服务器渲染"></a>1.2 为什么需要服务器渲染</h2><p><strong>更好的 SEO，搜索引擎的爬虫抓取工具可以直接查看完全渲染的页面。</strong></p><p>这段话是什么意思呢，大家可以打开自己的Vue项目，右键查看源代码：</p><p><img src="/image/v2-28299477732b658e149ce2d986203754_720w.png" srcset="/img/loading.gif" alt="img"></p><p>可以看到，不管你的Vue项目有多庞大，作为入口的<code>index.html</code>一般就长成上面这个样子，页面中的<code>DOM</code>元素是由<code>JavaScript</code>进行生成，无法在<code>index.html</code>中直接查看到。</p><p>就是因为无法在<code>index.html</code>中直接查看到完全渲染的页面，尤其是在页面上的内容使用<code>ajax</code>动态获取渲染时，<strong>搜索引擎的爬虫就很难爬取得到你页面上的内容，不利于搜索引擎对你的页面进行排名 。</strong></p><p>如果你并不是指望着通过网站带来的广告费赚钱，那么完全不需要使用服务器渲染，当你想通过网站的流量获得广告费时，服务器渲染就显得特别重要，因为完全渲染的页面才有利于搜索引擎爬虫的爬取。不信你可以看看现在的主流网站，全是服务器渲染。</p><p><strong>更快的内容到达时间 (time-to-content)</strong></p><p>对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验。</p><p>没有人能够忍受打开一个网站需要长达10多秒的响应时间，服务器渲染也解决了这个痛点。</p><h1 id="2-Nuxt-js"><a href="#2-Nuxt-js" class="headerlink" title="2. Nuxt.js"></a>2. Nuxt.js</h1><p>如果你想要从头搭建服务端渲染，那么需要耗费大量的精力去进行研究，而<code>Nuxt.js</code>的出现，让一切都变得很简单。</p><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">https://zh.nuxtjs.org/</a></p><h1 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3. 创建项目"></a>3. 创建项目</h1><p>Nuxt.js团队创建了脚手架工具<a href="https://github.com/nuxt/create-nuxt-app" target="_blank" rel="noopener">create-nuxt-app</a>。</p><pre><code class="hljs powershell">npx create<span class="hljs-literal">-nuxt</span><span class="hljs-literal">-app</span> &lt;项目名&gt;yarn create nuxt<span class="hljs-literal">-app</span> &lt;项目名&gt;运行npm run dev</code></pre><h1 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4. 目录结构"></a>4. 目录结构</h1><p><code>assets</code> 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。</p><p><code>components</code> 用于组织应用的 Vue.js 组件。</p><p><code>layouts</code> 用于组织应用的布局组件。</p><p><code>middleware</code> 用于存放应用的中间件。</p><p><code>pages</code> 页面目录，用于组织应用的路由及视图。</p><p><code>plugins</code> 插件目录。</p><p><code>static</code> 存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。</p><p><code>store</code> 用于组织应用的 Vuex 状态树 文件。</p><p><code>nuxt.config.js</code>文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。</p><p><code>package.json</code>文件用于描述应用的依赖关系和对外暴露的脚本接口。</p><h1 id="5-创建页面"><a href="#5-创建页面" class="headerlink" title="5. 创建页面"></a>5. 创建页面</h1><p>到了这一步开始，几乎就和正常的使用Vue创建项目差不多，将页面放在pages中，<code>Nuxt.js</code>会自动找到<code>index.vue</code>作为入口文件。</p><p>如果是之前创建的项目，直接将项目按照目录文件逐渐移动过来。</p><h1 id="6-asyncData-fetch"><a href="#6-asyncData-fetch" class="headerlink" title="6. asyncData fetch"></a>6. asyncData fetch</h1><p><a href="https://zh.nuxtjs.org/guide/async-data/" target="_blank" rel="noopener">https://zh.nuxtjs.org/guide/async-data/</a></p><p>上面的问题解决后，还存在一个问题，就是通过<code>ajax</code>取得的数据然后进行渲染的<code>DOM</code>元素并没有出现在<code>html</code>文件上， 解决这个问题就需要使用到<code>asyncData</code>，<code>fetch</code>。</p><p><strong>注：需要写在第一个入口文件中。</strong></p><p>在这两个方法中都无法调用<code>this</code>获取<strong>组件实例，</strong>因为它们是在<strong>组件初始化之前</strong>被调用。</p><ul><li><code>asyncData</code> 可以在设置组件的数据之前能异步获取或处理数据。</li><li><code>fetch</code> 用于在渲染页面前填充应用的状态树（store）数据， 与<code>asyncData</code>方法类似，不同的是它不会设置组件的数据。</li></ul><h1 id="7-部署上线"><a href="#7-部署上线" class="headerlink" title="7. 部署上线"></a>7. 部署上线</h1><h2 id="7-1-服务端渲染应用部署（常用）"><a href="#7-1-服务端渲染应用部署（常用）" class="headerlink" title="7.1 服务端渲染应用部署（常用）"></a>7.1 服务端渲染应用部署（常用）</h2><p>因为我的服务上装了宝塔面板，强烈推荐宝塔面板！很多东西都是一键安装，非常方便。</p><p><a href="https://bt.cn/" target="_blank" rel="noopener">https://bt.cn/</a></p><p><strong>第一步</strong></p><p>打包应用<code>npm run build</code> 。</p><p><strong>第二步</strong></p><p>在宝塔面板中的<code>网站</code>-<code>添加网站</code>，如果是要部署到服务器，那么相信大家都对服务器有一定了解。</p><p>添加网站后在<code>根目录</code>可以看到一个文件夹地址，将项目中的<code>.nuxt</code>，<code>static</code>，<code>nuxt.config.js</code>，<code>package.json</code>拷贝到该文件夹中。</p><p><strong>第三步</strong></p><p>服务器中安装<code>pm2</code> 直接在宝塔面板的<code>软件商店</code>里面搜索后安装。安装完成后进入到刚才拷贝项目的文件夹中，运行<code>npm install</code>。</p><p><strong>第四步</strong></p><p>等待<code>npm</code>运行完成后，运行项目：</p><pre><code class="hljs powershell">pm2 start npm -<span class="hljs-literal">-name</span> <span class="hljs-string">"nuxt-name"</span> -- run start</code></pre><p><code>nuxt-name</code>为<code>package.json</code>中的项目名称。</p><p><strong>第五步</strong></p><p>如果上面的步骤都没有问题的话，就开启反向代理，在宝塔面板中<code>网站</code>-<code>设置</code>-<code>反向代理</code>，<code>目标url</code>中填写<code>http://localhost:3000</code>，<code>发送域名</code>中就填写你自己的域名。 到这里，项目就部署完毕了。</p><h2 id="7-2-静态应用部署"><a href="#7-2-静态应用部署" class="headerlink" title="7.2 静态应用部署"></a>7.2 静态应用部署</h2><p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。</p><p>可利用下面的命令生成应用的静态目录和文件：</p><pre><code class="hljs text">npm run generate</code></pre><p>这个命令会创建一个 <code>dist</code> 文件夹，所有静态化后的资源文件均在其中。</p><p>注意：<code>nuxt generate</code>在 build/generate 时间内仍然需要SSR引擎，<strong>而且如果首页是动态获取数据的话，那千万别用这种方式打包，因为如果数据发生了改变，你就必须要重新进行打包。</strong></p><h2 id="7-3-单页面应用程序部署-SPA"><a href="#7-3-单页面应用程序部署-SPA" class="headerlink" title="7.3 单页面应用程序部署 (SPA)"></a>7.3 单页面应用程序部署 (SPA)</h2><p>使用时启用SPA模式<code>mode: &#39;spa&#39;</code>或<code>--spa</code>。</p><ul><li>将<code>nuxt.config.js</code>中的<code>mode</code>更改为<code>spa</code>。</li><li>运行 <code>npm run build</code>.</li><li>自动生成<code>dist/</code>文件夹，部署到您的服务器，如<code>Surge</code>，<code>GitHub Pages</code>或<code>nginx</code>。</li></ul><p>注意：这种方式打包出来的文件就和<code>Vue</code>直接打包出来的文件没有什么区别，最主要的用途就是将项目部署到<code>GitHub Pages</code>。</p><h1 id="8-错误"><a href="#8-错误" class="headerlink" title="8. 错误"></a>8. 错误</h1><h2 id="8-1-Interface-39-NuxtApp-39-incorrectly-extends-interface-39-Vue-39"><a href="#8-1-Interface-39-NuxtApp-39-incorrectly-extends-interface-39-Vue-39" class="headerlink" title="8.1 Interface &#39;NuxtApp&#39; incorrectly extends interface &#39;Vue&#39;"></a>8.1 <code>Interface &#39;NuxtApp&#39; incorrectly extends interface &#39;Vue&#39;</code></h2><p><a href="https://github.com/nuxt/typescript/issues/49" target="_blank" rel="noopener">https://github.com/nuxt/typescript/issues/49</a></p><p>可能是由于<code>element-ui</code>的<code>$loading</code>和<code>nuxt.js</code> 中的<code>$loading</code>冲突导致。</p><p>解决方法：</p><p>在<code>tsconfig.json</code>添加：</p><pre><code class="hljs json">"skipLibCheck":true,</code></pre><h2 id="8-2-window-is-not-defined"><a href="#8-2-window-is-not-defined" class="headerlink" title="8.2 window is not defined"></a>8.2 <code>window is not defined</code></h2><p>一些只兼容客户端的脚本被打包进了服务端的执行脚本中去。 对于只适合在客户端运行的脚本，需要通过使用<code>process.client</code>变量来判断导入。比如我要引入<code>smooth-scroll</code>这个页面平滑滚动插件，就需要写在<code>if</code>条件判断中，不然就会报错。</p><pre><code class="hljs js">created () &#123;  <span class="hljs-keyword">if</span> (process.client) &#123;    <span class="hljs-keyword">const</span> SmoothScroll = <span class="hljs-built_in">require</span>(<span class="hljs-string">'smooth-scroll'</span>)    <span class="hljs-keyword">const</span> scroll = <span class="hljs-keyword">new</span> SmoothScroll(<span class="hljs-string">'a[href*="#"]'</span>)  &#125;&#125;</code></pre><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>使用<code>Nuxt.js</code>最主要的原因就是为了<code>SEO</code>给网站带来更高的流量，提高网页的打开速度，如果不靠着网站盈利，我个人觉得完全没有必要使用服务器渲染，因为服务器渲染给服务器带来更大的压力，增加服务器的成本。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务端渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/Viewer.js图片查看器</title>
    <link href="/2020/06/15/web%E5%BC%80%E5%8F%91/Viewer.js%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/"/>
    <url>/2020/06/15/web%E5%BC%80%E5%8F%91/Viewer.js%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>做界面时可能会需要图片查看的功能，就比如QQ空间查看照片的功能。</p><p>虽然这个功能自己实现也不是太难，但是直接引入第三方库有个最大的好处是第三方库一般都经过很多个版本的更新迭代，不管是性能还是体验上一般都优于自己动手写（大佬除外）。</p><p><a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener">Viewer.js</a>几乎是开源出来的图片查看器中功能最全的库。 </p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><h2 id="1-1-npm"><a href="#1-1-npm" class="headerlink" title="1.1 npm"></a>1.1 npm</h2><pre><code class="hljs shell">npm install viewerjs</code></pre><h2 id="1-2-browser"><a href="#1-2-browser" class="headerlink" title="1.2 browser"></a>1.2 browser</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">"/path/to/viewer.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/path/to/viewer.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><pre><code class="hljs react">&lt;div&gt;  &lt;ul id&#x3D;&quot;images&quot;&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-1.jpg&quot; alt&#x3D;&quot;Picture 1&quot;&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-2.jpg&quot; alt&#x3D;&quot;Picture 2&quot;&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-3.jpg&quot; alt&#x3D;&quot;Picture 3&quot;&gt;&lt;&#x2F;li&gt;  &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;import Viewer from &#39;viewerjs&#39;;import &#39;viewerjs&#x2F;dist&#x2F;viewer.css&#39;;const viewer &#x3D; new Viewer(document.getElementById(&#39;images&#39;), &#123;  &#x2F;&#x2F; 配置选项&#125;);</code></pre><h2 id="2-1-inline模式"><a href="#2-1-inline模式" class="headerlink" title="2.1 inline模式"></a>2.1 inline模式</h2><p>官方给出的实例中有一个属性inline: true,这个属性指的是<strong>在当前的容器中进行图片展示。</strong>推荐根据情况进行开启。</p><p><img src="/image/v2-40a418dc45c96d9d51910555c8dc7c3e_720w.png" srcset="/img/loading.gif" alt="img"></p><p><code>inline: true</code></p><p><img src="/image/v2-dc6e7ac0818674df6b673a0bda91a0fa_720w.png" srcset="/img/loading.gif" alt="img"></p><p><code>inline: false</code>时，在全屏范围内进行显示。 </p><h2 id="2-2-缩略图和原图"><a href="#2-2-缩略图和原图" class="headerlink" title="2.2 缩略图和原图"></a>2.2 缩略图和原图</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(image,index) in imageInfo"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">el-card</span> <span class="hljs-attr">:body-style</span>=<span class="hljs-string">"&#123;padding:0&#125;"</span> <span class="hljs-attr">shadow</span>=<span class="hljs-string">"hover"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:data-original</span>=<span class="hljs-string">"image.original"</span></span><span class="hljs-tag">         <span class="hljs-attr">:src</span>=<span class="hljs-string">"image.thumbnail"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin-left: 5px;cursor: zoom-in"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>上面的代码是我在<code>Vue</code>中使用<code>Viewer.js</code>，其中<code>img</code>标签中的<code>src</code>是缩放图的地址，而<code>data-original</code>中是原图的地址。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> viewer = <span class="hljs-keyword">new</span> Viewer(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'images'</span>), &#123;  url: <span class="hljs-string">'data-original'</span>,&#125;);</code></pre><p>在声明时将<code>data-original</code>赋值给<code>url</code>这样点击查看时就会根据原图的地址进行加载原图。 </p><h1 id="3-兼容性"><a href="#3-兼容性" class="headerlink" title="3. 兼容性"></a>3. 兼容性</h1><ul><li>Chrome (最新)</li><li>Firefox (最新)</li><li>Safari (最新)</li><li>Opera (最新)</li><li>Edge (最新)</li><li>Internet Explorer 9+</li></ul><h1 id="4-键盘支持"><a href="#4-键盘支持" class="headerlink" title="4. 键盘支持"></a>4. 键盘支持</h1><ul><li>Esc：退出全屏、关闭查看器、退出模式、停止播放。</li><li>Space：停止播放。</li><li>←：查看上一张图像。</li><li>→：查看下一张图像。</li><li>↑：放大图像。</li><li>↓：缩小图像。</li><li>Ctrl + 0：缩小到初始大小。</li><li>Ctrl + 1：放大至自然大小。</li></ul><h1 id="5-配置参数"><a href="#5-配置参数" class="headerlink" title="5. 配置参数"></a>5. 配置参数</h1><p>配置参数就不详细讲解了，需要用到什么再去找寻就好了，也可以参考下面这篇文章：</p><p><a href="https://segmentfault.com/a/1190000016584946" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016584946</a></p><h1 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h1><p><img src="/image/v2-92538727955d76a616a4d07cde8bb176_720w.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>Viewer.js非常非常的简单易用，简直不需要过多的配置就能集成一个拥有非常多功能的图片查看器，最关键的是该图片查看器还支持移动端，如果是自己想要写出一个这样的图片查看器，还是需要花费大量功夫。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Viewer.js</tag>
      
      <tag>图片查看器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/打字机效果插件Typed.js</title>
    <link href="/2020/06/15/web%E5%BC%80%E5%8F%91/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6Typed.js/"/>
    <url>/2020/06/15/web%E5%BC%80%E5%8F%91/%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6Typed.js/</url>
    
    <content type="html"><![CDATA[<p>打字机效果是非常酷的文字显示效果，视觉表现极佳，而通过<code>Typed.js</code>可以很简单的在web开发中实现打字机效果。</p><h1 id="1-官网"><a href="#1-官网" class="headerlink" title="1. 官网"></a>1. 官网</h1><p><a href="https://mattboldt.com/demos/typed-js/" target="_blank" rel="noopener">JavaScript Animated Typing with Typed.jsmattboldt</a></p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><pre><code class="hljs powershell"><span class="hljs-comment"># With NPM</span>npm install typed.js<span class="hljs-comment"># With Yarn</span>yarn add typed.js<span class="hljs-comment"># With Bower</span>bower install typed.js</code></pre><h2 id="2-1-CDN"><a href="#2-1-CDN" class="headerlink" title="2.1 CDN"></a>2.1 CDN</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/typed.js@2.0.11"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><h2 id="3-1-HTML部分"><a href="#3-1-HTML部分" class="headerlink" title="3.1 HTML部分"></a>3.1 HTML部分</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"typed"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"white-space: pre-wrap;line-height: 30px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p><strong>经过测试文字放在<code>span</code>标签里面，输入的光标才会正常显示。</strong></p><h2 id="3-2-JavaScript部分"><a href="#3-2-JavaScript部分" class="headerlink" title="3.2 JavaScript部分"></a>3.2 JavaScript部分</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;  strings: [    <span class="hljs-string">'First test.'</span>,    <span class="hljs-string">'Second test, \nit will pause for three seconds. ^3000'</span>,    <span class="hljs-string">"Second test, \nthe last sentence will go back to 'Second test, ', \noh no, this is the third test. ^1000"</span>,    <span class="hljs-string">"It's going to start repeating."</span>,  ],  typeSpeed: <span class="hljs-number">50</span>, <span class="hljs-comment">// 打印速度</span>  startDelay: <span class="hljs-number">300</span>, <span class="hljs-comment">// 开始之前的延迟300毫秒</span>  loop: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否循环</span>&#125;;<span class="hljs-keyword">const</span> typed = <span class="hljs-keyword">new</span> Typed(<span class="hljs-string">'#typed'</span>, options);</code></pre><h2 id="3-3-更多参数"><a href="#3-3-更多参数" class="headerlink" title="3.3 更多参数"></a>3.3 更多参数</h2><p>该插件可以配置很多参数，具体的参数可以参考官方文档，或者参考下面的文章：</p><p><a href="https://blog.csdn.net/weixin_41000111/article/details/78725784" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41000111/article/details/78725784</a></p><h1 id="4-vue中的使用"><a href="#4-vue中的使用" class="headerlink" title="4. vue中的使用"></a>4. vue中的使用</h1><p>该插件对<code>vue</code>做了一次封装：</p><p><a href="hhttps://github.com/Orlandster/vue-typed-js">vue-typed-jsgithub</a></p><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><pre><code class="hljs powershell">npm install -<span class="hljs-literal">-save</span> vue<span class="hljs-literal">-typed</span><span class="hljs-literal">-js</span></code></pre><h2 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h2><p>非常简单，按照文档一步一步集成就可以了。</p><p><strong>注意：<code>vue-typed-js</code>没有声明文件，所以在<code>TypeScript</code>中使用会报错，而<code>Typed.js</code>是有声明文件的，可以直接在TypeScript中使用。</strong></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>总而言之使用<code>Typed.js</code>实现打字机效果非常的简单，简单到不需要用太多语言去进行描述。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动画</tag>
      
      <tag>Web 开发</tag>
      
      <tag>打字机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/HTML中的瀑布流masonry在Vue中应用</title>
    <link href="/2020/06/12/web%E5%BC%80%E5%8F%91/HTML%E4%B8%AD%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81masonry%E5%9C%A8Vue%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/12/web%E5%BC%80%E5%8F%91/HTML%E4%B8%AD%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81masonry%E5%9C%A8Vue%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。</p></blockquote><p><img src="/image/v2-8d270acaf37a1f3a1a5a31a2152d55b8_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以说作为图片的一种展示风格，是非常的好看了，那么在HTML中怎么进行实现呢？</p><h1 id="纯CSS实现"><a href="#纯CSS实现" class="headerlink" title="纯CSS实现"></a>纯CSS实现</h1><p><a href="https://www.bilibili.com/video/BV1xa4y147JP?t=164" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xa4y147JP?t=164</a></p><p>好吧，我就是看了这个视频后，才知道了原来这种排版叫做<strong>瀑布流</strong>，如果想要实现简单的瀑布流，根据这个视频中提供的思路，直接用CSS加上几行代码就能轻松实现瀑布流。所以这里就不再赘述，直接下一项。</p><h1 id="masonry"><a href="#masonry" class="headerlink" title="masonry"></a>masonry</h1><p>既然有现成的，为什么还要自己写呢，现在主要讲一讲如何在Vue中使用masonry。</p><p><strong>引入</strong></p><p>引入的方式有两种，一种通过CDN引入</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- or --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>一种是通过包管理的方式引入，即我们平时用的Vue,react框架，一般都是通过这种方式进行引入。</p><pre><code class="hljs ps1con">npm: npm install masonry-layout --saveBower: bower install masonry-layout --save</code></pre><p><strong>使用</strong></p><p>先将HTML结构创建出来：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>注：</p><ul><li>.grid即是所有图片的容器</li><li>.grid-item是单张图片的容器</li></ul><p>创建后，就开始准备引入js</p><p>1、通过jQuery引入</p><pre><code class="hljs js">$(<span class="hljs-string">'.grid'</span>).masonry(&#123;  <span class="hljs-comment">// options...</span>  itemSelector: <span class="hljs-string">'.grid-item'</span>,  columnWidth: <span class="hljs-number">200</span>&#125;);</code></pre><p>2、<strong>普通方式引入（Vue就是这样引入）</strong></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Masonry <span class="hljs-keyword">from</span> <span class="hljs-string">"masonry-layout"</span>; <span class="hljs-comment">// Vue项目的引入方式</span>updated() &#123;  <span class="hljs-keyword">var</span> grid = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".grid"</span>);  <span class="hljs-keyword">var</span> msnry = <span class="hljs-keyword">new</span> Masonry(grid, &#123;    <span class="hljs-comment">// options...</span>    itemSelector: <span class="hljs-string">".grid-item"</span>,    columnWidth: <span class="hljs-number">300</span>,  &#125;);&#125;</code></pre><p>经过多次测试，发现放在<strong>updated</strong>中是最保险的，最开始我将初始化放在了<strong>mounted</strong>这个生命周期里面，虽然静态的HTML没有出现问题，但是你如果想要使用v-for的方式进行渲染，那么初始化就不会起作用。</p><p>3、HTML通过data方式引入</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span> <span class="hljs-attr">data-masonry</span>=<span class="hljs-string">'&#123; "itemSelector": ".grid-item", "columnWidth": 200 &#125;'</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h1 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h1><p><img src="/image/v2-324d03d4675ddb378a4658fc0e3fe10b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-d6c0ee583c7b4d24d3ef1c9ae3329010_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>响应式</p><p><strong>可以看出来masonry通过少量的配置就可以达到惊人的效果。</strong></p><p>至于更多的配置内容，可以参考下面这篇文章</p><p><a href="https://blog.csdn.net/a419419/article/details/83858984" target="_blank" rel="noopener">https://blog.csdn.net/a419419/article/details/83858984</a></p><p>有条件的话，也可以直接到masonry官网进行查看</p><p><a href="https://masonry.desandro.com/" target="_blank" rel="noopener">masonry</a></p><hr><h1 id="6-12更新"><a href="#6-12更新" class="headerlink" title="6.12更新"></a>6.12更新</h1><p>最近做项目时想要用瀑布流，但是发现一个BUG，当图片数据已经被获取，但是图片未加载完时，可能会出现图片重叠的现象，这种现象经过测试往往出现在刷新浏览器的时候。</p><p><img src="/image/v2-7d1215a22efd4c2cf5ac5b8c2532a2ef_b.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>引入第三方库</p><p><a href="https://github.com/desandro/imagesloaded" target="_blank" rel="noopener">imagesloadedgithub.com</a></p><p>这个库会判断元素中的图片是否已经加载完成，并且在加载完成后调用回调函数。</p><p>所以改一下上面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> imagesloaded <span class="hljs-keyword">from</span> <span class="hljs-string">'imagesloaded'</span>; <span class="hljs-comment">// 引入imagesloaded库</span>updated() &#123;  <span class="hljs-keyword">let</span> grid = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grid'</span>);  <span class="hljs-keyword">let</span> msnry = <span class="hljs-keyword">new</span> Masonry(grid, &#123;    <span class="hljs-comment">// options...</span>    itemSelector: <span class="hljs-string">'.grid-item'</span>,    columnWidth: <span class="hljs-number">300</span>,  &#125;);  imagesloaded(<span class="hljs-string">'.grid-item'</span>, () =&gt; &#123;    msnry.layout(); <span class="hljs-comment">// 图片加载完成后重新绘制。</span>  &#125;);&#125;</code></pre><p><img src="/image/v2-eee714c047801bc6f9eba8ef9bc84ff2_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以看到当图片加载完成后会进行重新排版</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://segmentfault.com/a/1190000013675077" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013675077</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS系统越狱后的自用插件分享</title>
    <link href="/2020/06/11/IOS%E7%B3%BB%E7%BB%9F%E8%B6%8A%E7%8B%B1%E5%90%8E%E7%9A%84%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    <url>/2020/06/11/IOS%E7%B3%BB%E7%BB%9F%E8%B6%8A%E7%8B%B1%E5%90%8E%E7%9A%84%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要越狱？"><a href="#为什么要越狱？" class="headerlink" title="为什么要越狱？"></a>为什么要越狱？</h1><p>众所周知，IOS系统的封闭性要远远高于安卓，虽然现在安卓的很多衍生系统都已经不支持Root了。</p><p>正因为IOS的封闭性，所以IOS比起安卓来讲要安全很多，不会因为在滑动APP界面时点到广告就开始下载软件（以前我在用安卓时，那个年代流量还只有不到1G/月时，点到贴吧上面的广告瞬间开始下载软件，花掉不少流量…这个故事告诉我们，4G的速度还是挺快的）。</p><p>总之，越狱是为了实现IOS不具备的某些功能，但是<strong>越狱同时会造成安全性降低，同时越狱后微信和支付宝不支持指纹支付！</strong></p><p><strong>注意：某些插件我并不是用的作者源而是从第三方源（比如Cydia贴吧源、多米诺骨牌源）下载，大家酌情参考。</strong></p><p><strong>我的系统环境：IOS 12.4</strong></p><h1 id="1-Aerial-Rus"><a href="#1-Aerial-Rus" class="headerlink" title="1. Aerial Rus"></a>1. Aerial Rus</h1><p>源地址：<a href="http://rejail.earial/" target="_blank" rel="noopener">http://rejail.earial/</a></p><p>切换状态栏图标的颜色，因为切换后显得特别的花哨，所以这个插件已经被我放弃使用。</p><h2 id="2-AppStore快速切换账号"><a href="#2-AppStore快速切换账号" class="headerlink" title="2. AppStore快速切换账号"></a>2. AppStore快速切换账号</h2><p>源地址：<a href="http://apt.cydiaba.cn/" target="_blank" rel="noopener">http://apt.cydiaba.cn/</a>  Cydia贴吧源</p><p><img src="/image/v2-76c2bf8c74fe3d3f881b55332eed6583_720w.png" srcset="/img/loading.gif" alt="img"></p><p>有时候会有多个苹果ID需要来回切换，这显得很麻烦，安装该插件后，就会在AppStore里的个人信息处多出一个切换账号的按钮，曾经你登陆过的账号都可以快速进行切换，省去输入账号密码的烦恼。 </p><h2 id="3-AppStore"><a href="#3-AppStore" class="headerlink" title="3. AppStore++"></a>3. AppStore++</h2><p>源地址：<a href="http://cokepokes.github.io/" target="_blank" rel="noopener">http://cokepokes.github.io/</a></p><p><img src="/image/v2-e245957d4ff1075c5ef47eda6d357ba4_720w.png" srcset="/img/loading.gif" alt="img"></p><p>可以下载APP过去的版本，实用方法是按住右边的下载或者打开按钮，就会弹出来一个对话框。可以选择升级、降级、手动安装、禁止更新。</p><h2 id="4-NiceCaller-电话助手"><a href="#4-NiceCaller-电话助手" class="headerlink" title="4. NiceCaller 电话助手"></a>4. NiceCaller 电话助手</h2><p>源地址：<a href="http://apt.htv123.com/" target="_blank" rel="noopener">http://apt.htv123.com/</a></p><p><img src="/image/v2-8a856a64392b05ab0a2cc09895b279b6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>如果你被骚扰电话所困扰，该插件是你不二的选择，说起来，我最初越狱的目的就是为了找到一款可以拦截骚扰电话的插件，结果找了很多插件都无法正常进行拦截，直到使用了该插件，该插件需要配合腾讯手机管家使用。</p><p>当对方电话被腾讯手机管家标记过后，该插件会自动拒绝他们的电话，甚至还有拒接所有陌生电话的功能。</p><h2 id="5-KillX-Pro-Rus"><a href="#5-KillX-Pro-Rus" class="headerlink" title="5. KillX Pro Rus"></a>5. KillX Pro Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><img src="/image/v2-3c1b74b750379a404e424acf523dca8c_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>一键清理后台程序，安装后在后台界面向下滑动或者点击X，可以关闭掉所有打开的程序，非常实用的一个插件。</p><h2 id="6-DLEasy-Rus"><a href="#6-DLEasy-Rus" class="headerlink" title="6. DLEasy Rus"></a>6. DLEasy Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><strong>越狱后的神器之一。</strong>可以说是必装插件。可以下载YouTube视频，Instagram的图片等等。</p><p>同时还有一个附加功能：可以直接屏蔽YouTube客户端的广告，甚至还能打开YouTube的后台播放功能。当然，经济条件允许还是请购买YouTube会员。</p><h2 id="7-Prysm-控制中心美化"><a href="#7-Prysm-控制中心美化" class="headerlink" title="7. Prysm 控制中心美化"></a>7. Prysm 控制中心美化</h2><p>源地址：<a href="http://apt.wxhbts.com/" target="_blank" rel="noopener">http://apt.wxhbts.com/</a>  多米诺骨牌源</p><p><img src="/image/v2-f2f177b3929ca43334dd2877e4231370_720w.png" srcset="/img/loading.gif" alt="img"></p><p>顾名思义，就是美化控制中心的插件，我个人是不太习惯捣鼓这些样式上的东西。</p><h2 id="8-Liberty-Lite"><a href="#8-Liberty-Lite" class="headerlink" title="8. Liberty Lite"></a>8. Liberty Lite</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p>屏蔽越狱检测，因为有些软件在越狱环境下无法使用或者某些功能无法使用，比如支付宝的指纹支付，就可以使用这个软件屏蔽支付宝的越狱检测。</p><p>注意：<strong>使用该插件可能有封号的风险，贴吧中不少人使用这个插件屏蔽微信后导致微信号被封。</strong></p><h2 id="9-Selector-Rus"><a href="#9-Selector-Rus" class="headerlink" title="9. Selector Rus"></a>9. Selector Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><img src="/image/v2-be2dbf6ec1bdea185711837ffa92835e_720w.png" srcset="/img/loading.gif" alt="img"></p><p>选中后会弹出翻译选项。</p><h2 id="10-CCVPN"><a href="#10-CCVPN" class="headerlink" title="10. CCVPN"></a>10. CCVPN</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>  (BigBoss)</p><p><img src="/image/v2-430f36fe097ad16abd6f868e0f7b8adf_720w.png" srcset="/img/loading.gif" alt="img"></p><p>在控制中心会出现一个开启或者关闭VPN的按钮，可以方便的开启或者关闭最后一次使用的VPN。</p><h2 id="11-Flex-3"><a href="#11-Flex-3" class="headerlink" title="11. Flex 3"></a>11. Flex 3</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-9402913985b9988d7db509cc76c84d2e_720w.png" srcset="/img/loading.gif" alt="img"></p><p>IOS越狱后的神器级插件，可以做到破解软件VIP，修改游戏数据，去除APP广告等等功能，插件内就提供了很多大家编辑上传的脚本，但是需要注意的是，<strong>由于APP在不停的更新，所以这些脚本不一定有用。</strong></p><h2 id="12-FLEXible"><a href="#12-FLEXible" class="headerlink" title="12. FLEXible"></a>12. FLEXible</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-4a544a9fcc438aed7c65b5f9ff1cb720_720w.png" srcset="/img/loading.gif" alt="img"></p><p>配合Flex 3的神器之一，可以抓取界面元素，定位到控制元素的函数，从而使用Flex 3禁止该元素的启动。</p><h2 id="13-ios12状态栏（仿IOS10-For-4-7）"><a href="#13-ios12状态栏（仿IOS10-For-4-7）" class="headerlink" title="13. ios12状态栏（仿IOS10 For 4.7）"></a>13. ios12状态栏（仿IOS10 For 4.7）</h2><p>源地址：<a href="http://apt.wxhbts.com/" target="_blank" rel="noopener">http://apt.wxhbts.com/</a></p><p><img src="/image/v2-4e1305d1258ac992a3eaa1ae61b619b2_720w.png" srcset="/img/loading.gif" alt="img"></p><p>将ios12状态栏的信号图标变成小圆点，虽然通过替换系统文件也可以做到，但是该插件实现了一键替换。</p><p>注意：<strong>使用有风险！请酌情使用。</strong></p><h2 id="14-ReProvision"><a href="#14-ReProvision" class="headerlink" title="14. ReProvision"></a>14. ReProvision</h2><p>源地址：<a href="http://repo.incendo.ws/" target="_blank" rel="noopener">http://repo.incendo.ws/</a></p><p><img src="/image/v2-ab3673749ab55ccee107cc405a97ef77_720w.png" srcset="/img/loading.gif" alt="img"></p><p>自动签名程序，作者之前宣布不再维护该项目，但是在某一天大家发现0.5.2~EOL这个版本又可以开始自签了。</p><h2 id="15-RealCC"><a href="#15-RealCC" class="headerlink" title="15. RealCC"></a>15. RealCC</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-d3b0a4af60f8fd73a2a7a32068c3e383_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>可以直接在控制中心关闭掉WiFi和蓝牙，不再像没有越狱之前仅仅是断开WiFi和蓝牙，本质上是没有关闭。</p>]]></content>
    
    
    <categories>
      
      <category>IOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>越狱</tag>
      
      <tag>IOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/用Vue做一个播放器</title>
    <link href="/2020/06/06/web%E5%BC%80%E5%8F%91/%E7%94%A8Vue%E5%81%9A%E4%B8%80%E4%B8%AA%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2020/06/06/web%E5%BC%80%E5%8F%91/%E7%94%A8Vue%E5%81%9A%E4%B8%80%E4%B8%AA%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>之前在B站上面看到一个视频：</p><p><a href="https://www.bilibili.com/video/BV1Yz411z7An?t=16" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yz411z7An?t=16</a></p><p>感觉它的这个播放器挺好看的，原作者是用的PPT制作。</p><p>我的设计灵感一向很差，叫我自己设计UI一般会非常难看，于是就准备仿照他这个，用Vue通过web的形式，参照他的界面，做一款播放器玩玩。</p><p><img src="/image/v2-c2842ce2a93229a97f26d7499f07be37_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>制作一个简单的播放器，<strong>拥有播放，暂停，上一首，下一首，歌曲列表等功能。</strong>音乐数据就通过<code>axios</code>从我的后端服务器上面取得。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>既然有了目标，那么首先就需要创建一个Vue工程：</p><pre><code class="hljs powershell">vue create music_player</code></pre><p><strong>注意：Vue的工程名称不能包含大写，但是可以有下划线。</strong></p><p>因为是复刻嘛，想要做到完全一样难度还是比较大的，所以就大概相似就差不多了，我就使用Vant作为UI。</p><p><a href="https://link.zhihu.com/?target=https%3A//youzan.github.io/vant/%23/zh-CN/quickstart">Vant UI - 快速上手youzan.github.io</a></p><p>该工程一看就是一个手机版的播放器，所以我还引入了<code>rem</code>文件：</p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, win</span>) </span>&#123;  <span class="hljs-keyword">const</span> docEl = doc.documentElement;  <span class="hljs-keyword">const</span> resizeEvt = <span class="hljs-string">'orientationchange'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> ? <span class="hljs-string">'orientationchange'</span> : <span class="hljs-string">'resize'</span>;  <span class="hljs-keyword">const</span> recalc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> &#123; clientWidth &#125; = docEl;    <span class="hljs-keyword">if</span> (!clientWidth) <span class="hljs-keyword">return</span>;    docEl.style.fontSize = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-number">100</span> * (clientWidth <span class="hljs-regexp">/ 375)&#125;px`;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  &#125;;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  if (!doc.addEventListener) return;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  win.addEventListener(resizeEvt, recalc, false);</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  doc.addEventListener('DOMContentLoaded', recalc, false);</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">&#125;(document, window));</span></span></span></code></pre><p>该文件是为了使页面自适应。该文件的意思是<code>100px</code>为<code>0.1rem</code>，所以我们之后使用的所有<code>px</code>都要换算成为<code>rem</code>。</p><h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h1><p><img src="/image/v2-476cdd2f4ee590750b8a137136de203f_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>因为主要是做的移动端的项目，所以需要将浏览器的调试模式设置为iPhone 6/7/8，这也是现在移动端开发最为主流的分辨率。但是后面我将模式切换到了iPhone X…因为iPhone 6模式下整个界面显得有点拥挤。</p><h1 id="搭建界面"><a href="#搭建界面" class="headerlink" title="搭建界面"></a>搭建界面</h1><p>搭建界面几乎没有什么难度，CSS样式需要一点点的慢慢调整，最后调整到合适的样式。</p><p><img src="/image/v2-85706fa734c160d17d36a38392ec6683_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-99c57b3026a297d66546b0a143d0f0fc_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>先简单的搭出一个界面，等到跑通业务逻辑后，我们再来进行微调。</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>这种播放器之间的数据传递还是需要使用Vuex如果单靠组件之间的单向传递，那可是太麻烦了。</p><p><img src="/image/v2-767a1ad70ed58c3ef3f11511bb1fe093_b.webp" srcset="/img/loading.gif" alt="img"></p><p>从这里开始我将调试模式改为了iPhone X</p><p>我放入Vuex管理的数据有：</p><pre><code class="hljs js">state: &#123;  <span class="hljs-comment">/* 歌曲列表 */</span>  musicList: [&#123;    id: <span class="hljs-number">0</span>, <span class="hljs-comment">// 歌曲id</span>    musicName: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲名字</span>    musicSinger: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌手名字</span>    musicImg: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲图片</span>    musicUrl: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲地址</span>  &#125;],  <span class="hljs-comment">/* 音乐是否在播放 */</span>  musicStatus: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 当前播放的音乐</span>  musicIndex: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 管理音乐</span>  music: &#123;    play: <span class="hljs-built_in">Function</span>,    pause: <span class="hljs-built_in">Function</span>,  &#125;,&#125;,</code></pre><p>可以看到，集成Vuex后这些数据进行了正常显示，并且点击右下角的播放按钮，歌曲也能进行播放。</p><p>放到Vuex进行管理有个最大的好处就是，所有数据都只存在一份，如果一旦一个地方改变了数据，那么其它引用该数据的地方都会进行改变，比如：</p><p><img src="/image/v2-5c315e6f5b43783487df4204ef81f6c4_b.webp" srcset="/img/loading.gif" alt="img"></p><p>可以看到，在第二个界面改变了数据后，第一个界面也发生了变化</p><p>剩下的就是播放动画了。</p><p><strong>音乐频率图</strong></p><p><img src="/image/v2-fe08aa541c7913240d6cb12ca76d774b_b.webp" srcset="/img/loading.gif" alt="img"></p><p>由于最开始创建项目的时候我勾选了sass，所以这个音乐频率图用sass来做是十分快捷的。</p><pre><code class="hljs css"><span class="hljs-comment">/* 声明动画 */</span><span class="hljs-keyword">@keyframes</span> move &#123;  <span class="hljs-selector-tag">from</span> &#123;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-selector-tag">to</span> &#123;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">50px</span>);  &#125;&#125;<span class="hljs-comment">/* 因为上面有70个div所以这里就用sass的循环，如果是css就只有一个一个的添加 */</span><span class="hljs-keyword">@for</span> $i from <span class="hljs-number">1</span> through <span class="hljs-number">70</span> &#123;  &amp;:nth-child(#&#123;$i&#125;) &#123;    <span class="hljs-comment">/* 使用随机数声明 */</span>    animation: move linear 0.5s ((random(1000)-500)/1000+s) infinite alternate;  &#125;&#125;</code></pre><h1 id="最后微调"><a href="#最后微调" class="headerlink" title="最后微调"></a>最后微调</h1><p>最主要是将开始的字体，行距，居中显示这些内容进行优化，因为开始只是大概的搭了一个界面后就先去做业务逻辑部分了，所以页面中还是有很多需要优化的地方。</p><p><img src="/image/v2-42b6917203ed198c8f5a4eb6db50d1b5_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>进度条优化</strong></p><p>根据音乐当前播放时间和总时间，计算出音乐进度，将小于这个值的进度条都附加上一个更换背景颜色的类。</p><pre><code class="hljs js">&lt;div v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(i,index) in 40"</span> :key=<span class="hljs-string">"index"</span>     :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"`hight $&#123;musicPlay?'anima':''&#125; $&#123;progress&gt;index?'progress':''&#125;`"</span>&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">.progress &#123;</span><span class="hljs-regexp">  background: #123a70;</span><span class="hljs-regexp">&#125;</span></code></pre><h1 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h1><pre><code class="hljs js"><span class="hljs-keyword">this</span>.timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">this</span>.progress = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-keyword">this</span>.musicTime / <span class="hljs-keyword">this</span>.music) * <span class="hljs-number">40</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.progress);&#125;, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 页面销毁后销毁定时器</span>destroyed() &#123;  clearInterval(<span class="hljs-keyword">this</span>.timer);&#125;,</code></pre><p>因为播放进度是通过<code>setInterval</code>每秒钟进行计算，所以计时器一定要在页面被销毁的时候一起给销毁掉，不然计时器会越来越多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个播放器的制作不难，难点在于Vuex的使用，该项目里面可能会有很多隐藏的BUG，或者体验不佳的地方，因为只做了个大概，没有太在意细节部分，如果一个项目要上线还是要经过不断的测试优化。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity3d</tag>
      
      <tag>播放器</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/GSAP（GreenSock）：最健全的web动画库之一</title>
    <link href="/2020/06/03/web%E5%BC%80%E5%8F%91/GSAP%EF%BC%88GreenSock%EF%BC%89%EF%BC%9A%E6%9C%80%E5%81%A5%E5%85%A8%E7%9A%84web%E5%8A%A8%E7%94%BB%E5%BA%93%E4%B9%8B%E4%B8%80/"/>
    <url>/2020/06/03/web%E5%BC%80%E5%8F%91/GSAP%EF%BC%88GreenSock%EF%BC%89%EF%BC%9A%E6%9C%80%E5%81%A5%E5%85%A8%E7%9A%84web%E5%8A%A8%E7%94%BB%E5%BA%93%E4%B9%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="官方的介绍"><a href="#官方的介绍" class="headerlink" title="官方的介绍"></a>官方的介绍</h1><blockquote><p>GreenSock动画平台（GSAP）可以对JavaScript可以操作的所有内容进行动画处理（CSS属性，SVG，React，画布，通用对象等），同时解决了不同浏览器上存在的兼容性问题，而且速度极快（比jQuery 快20倍）。大约有1000万个站点和许多主要品牌都使用 GSAP。</p></blockquote><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://link.zhihu.com/?target=https%3A//greensock.com/">https://greensock.com/greensock.com</a></p><p>动画其实是每秒多次改变元素属性值，元素看起来就仿佛在动一样，比如淡入淡出，旋转，移动等。而GSAP捕捉一个起始值和一个结束值，然后每秒在它们之间插值60次。</p><p>如果从技术上面来讲，GSAP其实应该被称为“GreenSock属性操纵器”（GSPM）。</p><h1 id="可以添加动画的元素"><a href="#可以添加动画的元素" class="headerlink" title="可以添加动画的元素"></a>可以添加动画的元素</h1><p>GSAP非常的灵活，几乎可以处理所有页面上可以通过JS进行改变的元素，例如：</p><ul><li>CSS：2D和3D变换，颜色，<code>width</code>，<code>opacity</code>，<code>border-radius</code>，<code>margin</code>，和几乎所有CSS值。</li><li>SVG属性：<code>viewBox</code>，<code>width</code>，<code>height</code>，<code>fill</code>，<code>stroke</code>，<code>cx</code>，<code>r</code>，<code>opacity</code>，等插件，像MorphSVG和DrawSVG可用于高级特效。</li><li>任何数值，例如，呈现为的对象<code>&lt;canvas&gt;</code>。对3D场景中的相机位置进行动画处理或过滤值。GSAP通常与Three.js和Pixi.js一起使用。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载直接引入"><a href="#下载直接引入" class="headerlink" title="下载直接引入"></a>下载直接引入</h2><p><a href="https://link.zhihu.com/?target=https%3A//greensock.com/files/file/20-gsap-3-public-files/%3Fdo%3Ddownload%26csrfKey%3D15944fce35b951ce3142b11661536cdd">greensock Version 3.3.0greensock.com</a></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>官网上提供的CDN非常的多，可以按照自己的需要进行引入。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/CSSRulePlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/Draggable.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/EaselPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/MotionPathPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/PixiPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/TextPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/ScrollToPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/ScrollTrigger.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>NPM</p><pre><code class="hljs shell">npm install gsapyarn add gsap</code></pre><h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h2><p><code>gsap.to(targets,vars)</code>：从开始的位置到结束的位置。</p><ul><li><code>targets</code> - 你需要添加动画的对象，可以是<code>object</code>,<code>array</code>和选择器<code>&quot;.myClass&quot;</code>。</li><li><code>vars</code> - 一个对象，里面包含你想要改变的属性，延时，已经回调函数等。</li></ul><p><a href="https://greensock.com/docs/v3/GSAP/Tween/vars" target="_blank" rel="noopener">vars所有的参数</a></p><p><code>gsap.from(targets,vars)</code>：与上面的<code>gsap.to</code>相反，这个是从结束的位置到开始的位置。</p><p><code>Easing</code>：运动状态。属于<code>vars</code>中的一个属性。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.from(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">5</span>,    x: <span class="hljs-number">500</span>,    ease:<span class="hljs-string">"elastic.in(1,1)"</span> <span class="hljs-comment">// 运动状态</span>&#125;);Draggable.create(<span class="hljs-string">"#app"</span>);</code></pre><p><a href="https://greensock.com/docs/v3/Eases" target="_blank" rel="noopener">https://greensock.com/docs/v3/Eases</a></p><p>官网上面对于ease属性给出了很多值，如果有需要的话可以参考官网的属性。</p><p><img src="/image/v2-6adaec0fbbd60764e60aa2d389a1a829_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>只需要点一点，就直观的体验</p><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><ul><li><strong>onComplete</strong>：动画完成时调用。</li><li><strong>onStart</strong>：动画开始时调用</li><li><strong>onUpdate</strong>：每次动画更新时调用（在动画处于活动状态时每帧调用）。</li><li><strong>onRepeat</strong>：每次动画重复时调用一次。</li><li><strong>onReverseComplete</strong>：动画反转后再次到达其起点时调用。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.from(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">5</span>,    x: <span class="hljs-number">500</span>,    ease:<span class="hljs-string">"elastic.in(1,1)"</span>,    onComplete:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 动画播放完成时调用</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"111"</span>);    &#125;&#125;);</code></pre><p>回调参数</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    x: <span class="hljs-number">100</span>,    onComplete: tweenComplete,    onCompleteParams: [<span class="hljs-string">"done!"</span>]&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tweenComplete</span>(<span class="hljs-params">message</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(message);&#125;</code></pre><p>使用上面这种方式调用回调函数时，<strong>如果需要传递参数，必须以数组方式传递，即使只有一个参数。</strong></p><h1 id="控制动画"><a href="#控制动画" class="headerlink" title="控制动画"></a>控制动画</h1><ul><li><code>tween.pause();</code> 暂停</li><li><code>tween.resume();</code>恢复</li><li><code>tween.reverse();</code>反向播放</li><li><code>tween.seek(0.5);</code> 跳到0.5s</li><li><code>tween.progress(0.25);</code> 跳到4分之1处</li><li><code>tween.timeScale(0.5);</code> 速度减慢</li><li><code>tween.timeScale(2);</code>速度翻倍</li><li><code>tween.kill();</code> 删除动画</li></ul><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><ul><li>从整体上控制一组动画。</li><li>在不使用很多<code>delay</code>的情况下构建一个动画序列。（如果对前一个动画进行时间调整后一个动画的触发时间也会改变，从而大大简化了实验和维护工作）。</li><li>对动画进行模块化。</li><li>可以进行非常复杂的动画编排。</li><li>要基于一组动画触发回调（例如“在完成所有这些动画之后，调用<code>myFunction()</code>”）。</li></ul><p>生命时间线变量<code>var t1 = gsap.timeline();</code></p><p>然后将需要依次触发的动画添加入时间线里即可，例如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tl = gsap.timeline();tl.add(gsap.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    delay: <span class="hljs-number">1</span>,    x: <span class="hljs-number">500</span>,&#125;));tl.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    y: <span class="hljs-number">500</span>,&#125;);</code></pre><p><img src="/image/v2-c2ee2519115a9bceb5623f5b3674fad4_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>时间轴的特殊属性：</p><ul><li><code>repeat</code>：动画重复的次数。</li><li><code>repeatDelay</code>：两次重复之间的间隔时间（以秒为单位）。</li><li><code>yoyo</code>：如果为<code>true</code>，则每次重复播放都会前后交替进行。</li><li><code>delay</code>：时间轴开始之前的延迟（以秒为单位）。</li><li><code>onComplete</code>：时间线播放完毕后调用的函数。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> tl = gsap.timeline(&#123;  repeat: <span class="hljs-number">1</span>,   yoyo: <span class="hljs-literal">true</span>,   onRepeat: onRepeatHandler,  onComplete: onCompleteHandler&#125;);</code></pre><p><strong>Getter / Setter 方法</strong></p><ul><li><code>time()</code> 播放头的本地位置（当前时间，以秒为单位），不包括任何重复或repeatDelays。</li><li><code>progress()</code> 它是介于0和1之间的值，指示播放头的位置，其中0处在开始位置，0.5处在中途完成，1处在结束位置。</li><li><code>duration()</code> 动画的持续时间（以秒为单位），不包括任何重复或repeatDelays。</li><li><code>delay()</code> 动画的初始延迟（动画开始之前的时间长度，以秒为单位）。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GSAP的功能可远远不止上面这些，它几乎可以做到你想要的任何动画，包括DOM的拖动，滚动触发，运动路径插件等等，唯一的缺点就是它包含可以实现的动画实在是太多了，需要花费一定的时间进行学习，不像<code>Animate.css</code>和<code>Anime.js</code>这些动画库一样简单易用，不过如果你的网页需要大量动画，<code>GSAP</code>不失为一个很好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>HTML5</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/利用background制作拉窗帘效果</title>
    <link href="/2020/06/02/web%E5%BC%80%E5%8F%91/%E5%88%A9%E7%94%A8background%E5%88%B6%E4%BD%9C%E6%8B%89%E7%AA%97%E5%B8%98%E6%95%88%E6%9E%9C/"/>
    <url>/2020/06/02/web%E5%BC%80%E5%8F%91/%E5%88%A9%E7%94%A8background%E5%88%B6%E4%BD%9C%E6%8B%89%E7%AA%97%E5%B8%98%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>往往利用CSS可以做出一些意想不到的效果，比如说下面的这个示例：</p><p><img src="/image/v2-1c842c67816442adf6c8ba34c6b7411a_b.webp" srcset="/img/loading.gif" alt="img"></p><p>为了演示随手做的，官网并不是这样</p><p>滚动鼠标滚轮，就有一种背景图被覆盖的错觉，之所以说是错觉，并不是背景图真的被覆盖了，其实背景图所在的盒子是跟着下面的图片一起在滚动，只是图片和窗口之间相对没有移动造成的错觉。</p><p>可能听起来比较复杂，但是实际上只需要一个属性就能做出这种效果，那就是<code>background-attachment: fixed;</code></p><p>还是同一个案例，我们将背景图片去掉，看看效果就明白了。</p><p><img src="/image/v2-0b2fa904729127861768553783f16c26_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h1><p>CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><ul><li><code>fixed</code>此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</li><li><code>local</code>此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</li><li><code>scroll</code>此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。</li></ul><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web 开发</tag>
      
      <tag>HTML+CSS</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/全屏滚动插件fullpage.js</title>
    <link href="/2020/06/01/web%E5%BC%80%E5%8F%91/%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullpage.js/"/>
    <url>/2020/06/01/web%E5%BC%80%E5%8F%91/%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullpage.js/</url>
    
    <content type="html"><![CDATA[<p>随着前端的飞速发展，现在制作界面时出现了非常多的好看的样式，比如说全屏滚动效果，能够带来很舒服的视觉体验。先来看一下什么是全屏滚动：</p><p><img src="/image/v2-432af4e9a4a61d6a7d615dca0b11e98c_b.webp" srcset="/img/loading.gif" alt="img"></p><p>这是<code>fullpage.js</code>的官网，只需要滑动一下滚轮，就能实现翻页的效果。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="noopener">fullPage.js中文文档github</a></p><p>如何安装其实文档上面已经说得很清楚了，即：</p><pre><code class="hljs powershell">// 使用 bowerbower install fullpage.js// 使用 npmnpm install fullpage.js</code></pre><p>包含文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"fullpage.css"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 以下行是可选的。 只有在使用选项 css3:false ，并且您希望使用其他缓动效果，而非 linear 、 swing 或 easeInOutCubic 时才有必要。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"vendors/easings.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- 以下行仅在使用选项 scrollOverflow:true 的情况下是必需的 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"vendors/scrolloverflow.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fullpage.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>因为现在的单页面应用几乎都是使用的webpack打包工具，所以直接看一下webpack怎么引入，如果有使用其它工具，可以直接到下面的网址进行查看如何引入。</p><p><a href="https://github.com/alvarotrigo/fullPage.js/wiki/Use-module-loaders-for-fullPage.js" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js/wiki/Use-module-loaders-for-fullPage.js</a></p><pre><code class="hljs js"><span class="hljs-comment">// Optional. When using fullPage extensions</span><span class="hljs-comment">//import scrollHorizontally from './fullpage.scrollHorizontally.min';</span><span class="hljs-comment">// Optional. When using scrollOverflow:true</span><span class="hljs-comment">//import IScroll from 'fullpage.js/vendors/scrolloverflow';</span><span class="hljs-comment">// Importing fullpage.js</span><span class="hljs-keyword">import</span> fullpage <span class="hljs-keyword">from</span> <span class="hljs-string">'fullpage.js'</span>;<span class="hljs-comment">// When using fullPage extensions replace the previous import</span><span class="hljs-comment">// of fullpage.js for this file</span><span class="hljs-comment">//import fullpage from 'fullpage.js/dist/fullpage.extensions.min';</span><span class="hljs-comment">// Initializing it</span><span class="hljs-keyword">var</span> fullPageInstance = <span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#myFullpage'</span>, &#123;    navigation: <span class="hljs-literal">true</span>,    sectionsColor:[<span class="hljs-string">'#ff5f45'</span>, <span class="hljs-string">'#0798ec'</span>, <span class="hljs-string">'#fc6c7c'</span>, <span class="hljs-string">'grey'</span>]&#125;);</code></pre><h1 id="应用于React"><a href="#应用于React" class="headerlink" title="应用于React"></a>应用于React</h1><p>根据上面的方法，我们很容易就可以在React中进行使用<code>fullpage.js</code>，只需要创建：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myFullpage"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>componentDidMount() &#123;  let fullPageInstance = new fullpage('#myFullpage', &#123;    navigation: true,    sectionsColor:['#ff5f45', '#0798ec', '#fc6c7c', 'grey']  &#125;);&#125;</code></pre><p><img src="/image/v2-a5cb4934a0e9c2bc6ea72850bf96f494_b.webp" srcset="/img/loading.gif" alt="img"></p><p>可以看到通过上面的集成后，初步效果已经出来了，剩下的就是填充自己的内容，并且根据需要进行配置。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> myFullpage = <span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;<span class="hljs-comment">//导航</span>menu: <span class="hljs-string">'#menu'</span>,lockAnchors: <span class="hljs-literal">false</span>,anchors:[<span class="hljs-string">'firstPage'</span>, <span class="hljs-string">'secondPage'</span>],navigation: <span class="hljs-literal">false</span>,navigationPosition: <span class="hljs-string">'right'</span>,navigationTooltips: [<span class="hljs-string">'firstSlide'</span>, <span class="hljs-string">'secondSlide'</span>],showActiveTooltip: <span class="hljs-literal">false</span>,slidesNavigation: <span class="hljs-literal">false</span>,slidesNavPosition: <span class="hljs-string">'bottom'</span>,<span class="hljs-comment">//滚动</span>css3: <span class="hljs-literal">true</span>,scrollingSpeed: <span class="hljs-number">700</span>,autoScrolling: <span class="hljs-literal">true</span>,fitToSection: <span class="hljs-literal">true</span>,fitToSectionDelay: <span class="hljs-number">1000</span>,scrollBar: <span class="hljs-literal">false</span>,easing: <span class="hljs-string">'easeInOutCubic'</span>,easingcss3: <span class="hljs-string">'ease'</span>,loopBottom: <span class="hljs-literal">false</span>,loopTop: <span class="hljs-literal">false</span>,loopHorizontal: <span class="hljs-literal">true</span>,continuousVertical: <span class="hljs-literal">false</span>,continuousHorizontal: <span class="hljs-literal">false</span>,scrollHorizontally: <span class="hljs-literal">false</span>,interlockedSlides: <span class="hljs-literal">false</span>,dragAndMove: <span class="hljs-literal">false</span>,offsetSections: <span class="hljs-literal">false</span>,resetSliders: <span class="hljs-literal">false</span>,fadingEffect: <span class="hljs-literal">false</span>,normalScrollElements: <span class="hljs-string">'#element1, .element2'</span>,scrollOverflow: <span class="hljs-literal">false</span>,scrollOverflowReset: <span class="hljs-literal">false</span>,scrollOverflowOptions: <span class="hljs-literal">null</span>,touchSensitivity: <span class="hljs-number">15</span>,bigSectionsDestination: <span class="hljs-literal">null</span>,<span class="hljs-comment">//可访问</span>keyboardScrolling: <span class="hljs-literal">true</span>,animateAnchor: <span class="hljs-literal">true</span>,recordHistory: <span class="hljs-literal">true</span>,<span class="hljs-comment">//布局</span>controlArrows: <span class="hljs-literal">true</span>,verticalCentered: <span class="hljs-literal">true</span>,sectionsColor : [<span class="hljs-string">'#ccc'</span>, <span class="hljs-string">'#fff'</span>],paddingTop: <span class="hljs-string">'3em'</span>,paddingBottom: <span class="hljs-string">'10px'</span>,fixedElements: <span class="hljs-string">'#header, .footer'</span>,responsiveWidth: <span class="hljs-number">0</span>,responsiveHeight: <span class="hljs-number">0</span>,responsiveSlides: <span class="hljs-literal">false</span>,parallax: <span class="hljs-literal">false</span>,parallaxOptions: &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">'reveal'</span>, <span class="hljs-attr">percentage</span>: <span class="hljs-number">62</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">'translate'</span>&#125;,cards: <span class="hljs-literal">false</span>,cardsOptions: &#123;<span class="hljs-attr">perspective</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">fadeContent</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">fadeBackground</span>: <span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">//自定义选择器</span>sectionSelector: <span class="hljs-string">'.section'</span>,slideSelector: <span class="hljs-string">'.slide'</span>,lazyLoading: <span class="hljs-literal">true</span>,<span class="hljs-comment">//事件</span>onLeave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">origin, destination, direction</span>)</span>&#123;&#125;,afterLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">origin, destination, direction</span>)</span>&#123;&#125;,afterRender: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,afterResize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height</span>)</span>&#123;&#125;,afterReBuild: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,afterResponsive: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isResponsive</span>)</span>&#123;&#125;,afterSlideLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">section, origin, destination, direction</span>)</span>&#123;&#125;,onSlideLeave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">section, origin, destination, direction</span>)</span>&#123;&#125;&#125;);</code></pre><p><strong>如果你想将一个页面设置为默认页，只需要给它添加<code>active</code>类，例如<code>&lt;div class=&quot;section active&quot;&gt;Some section&lt;/div&gt;</code>。</strong></p><h1 id="导航小圆点"><a href="#导航小圆点" class="headerlink" title="导航小圆点"></a>导航小圆点</h1><p><img src="/image/v2-f5d2b9a8deb690dc4c796bdb2182484a_b.webp" srcset="/img/loading.gif" alt="img"></p><p>这种导航小圆点是非常实用的一个功能，引入也很简单，</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'fullpage.js/dist/fullpage.min.css'</span>; <span class="hljs-comment">//引入CSS样式，如果不引入是无法显示小圆点。</span><span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;  navigation:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启小圆点</span>&#125;);</code></pre><h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p>通常我们都需要一些锚点，点击锚点直接进行切换页面：</p><p>根据官方文档，如果要使用锚点功能只需要在HTML标签中使用属性<code>data-anchor</code>，例：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"section"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide1"</span>&gt;</span> slide 1 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide2"</span>&gt;</span> slide 2 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide3"</span>&gt;</span> slide 3 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide4"</span>&gt;</span> slide 4 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>或者也可以直接在声明时进行初始化：</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;anchors:[<span class="hljs-string">'firstPage'</span>, <span class="hljs-string">'secondPage'</span>, <span class="hljs-string">'thirdPage'</span>]&#125;);</code></pre><p>但是我发现了一个新问题：在<code>react-router</code>的<code>HashRouter</code>中会把<code>#</code>当做是hash来处理。也就是说<strong>锚点在<code>HashRouter</code>中无法使用。</strong><code>HashRouter</code>即地址栏中包含<code>#</code>的模式，例如：<code>https://www.xxx.cn/#/</code>这种地址，既然这种地址这么丑，为什么还要使用呢？</p><p>因为项目部署到服务器后，如果没有后端进行转发或者重定向，不使用<code>HashRouter</code>模式就可能存在你<strong>刷新一下页面会出现页面未找到的情况，但是我没有找到太好的解决办法。</strong>目前仅想到了使用<code>fullpage_api.moveTo();</code>方法来进行控制，但是远远没有锚点方便。</p><h1 id="react-fullpage"><a href="#react-fullpage" class="headerlink" title="react-fullpage"></a>react-fullpage</h1><p>都写到这里了，我才发现原来这个插件有React版本的，不仅有React版本，甚至还有Vue和Angular，不过应该仅仅是在该插件的基础上做了封装。</p><p><a href="https://github.com/alvarotrigo/react-fullpage" target="_blank" rel="noopener">react-fullpagegithub</a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs powershell">npm install @fullpage/react<span class="hljs-literal">-fullpage</span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用方法大体相同，如果将上面的例子改为<code>react-fullpage</code>写法即为：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactFullpage <span class="hljs-keyword">from</span> <span class="hljs-string">'@fullpage/react-fullpage'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;ReactFullpage        <span class="hljs-comment">//上面的参数设置都写在这里，不用再写在构造函数里面</span>        navigation=&#123;<span class="hljs-literal">true</span>&#125;        sectionsColor=&#123;[<span class="hljs-string">'#ff5f45'</span>, <span class="hljs-string">'#0798ec'</span>, <span class="hljs-string">'#fc6c7c'</span>, <span class="hljs-string">'grey'</span>]&#125;        render=&#123;(&#123;state, fullpageApi&#125;) =&gt; &#123;          <span class="hljs-keyword">return</span> (            &lt;ReactFullpage.Wrapper&gt;              &lt;div className=<span class="hljs-string">"section"</span>&gt;Some section&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">              &lt;div className="section"&gt;Some section&lt;/</span>div&gt;              &lt;div className=<span class="hljs-string">"section"</span>&gt;Some section&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">              &lt;div className="section"&gt;Some section&lt;/</span>div&gt;            &lt;<span class="hljs-regexp">/ReactFullpage.Wrapper&gt;</span><span class="hljs-regexp">          );</span><span class="hljs-regexp">        &#125;&#125;</span><span class="hljs-regexp">      /</span>&gt;    );  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Test;</code></pre><h1 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h1><p><a href="https://www.bilibili.com/video/BV1Xx411d7rc" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Xx411d7rc</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
      <tag>网页设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强大的油猴Tampermonkey：简单的脚本制作</title>
    <link href="/2020/05/28/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%B2%B9%E7%8C%B4Tampermonkey%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/"/>
    <url>/2020/05/28/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%B2%B9%E7%8C%B4Tampermonkey%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="油猴是什么？"><a href="#油猴是什么？" class="headerlink" title="油猴是什么？"></a>油猴是什么？</h1><p>可以让你在网页上使用脚本，同时它拥有非常多的其他用户开放出来提供下载的脚本，如果你会JavaScript，你甚至可以自行编写脚本实现你想要实现的事情。</p><h1 id="油猴和Chrome扩展应用"><a href="#油猴和Chrome扩展应用" class="headerlink" title="油猴和Chrome扩展应用"></a>油猴和Chrome扩展应用</h1><p>Chrome扩展应用本质上是<code>HTML+CSS+JavaScript</code>而油猴脚本仅仅是一个<code>JavaScript</code>文件，而且谷歌对于扩展应用的审核比较严格，甚至还需要缴纳审核费用。而油猴脚本其实是简化的Chrome插件，它没有上面的那些限制。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果是能科学上网，就直接进入到Chrome应用商店安装。</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>如何下载第三方脚本在这里就不提了，这里只说一下如何创建一个新的油猴脚本文件。</p><p><img src="/image/v2-4ae5c4cc1df050759e13bfbd48764dcd_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>点击后可以看到下面的代码：</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         New Userscript  //脚本名字</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/ //脚本命名空间</span><span class="hljs-comment">// @version      0.1 //版本</span><span class="hljs-comment">// @description  try to take over the world! //描诉</span><span class="hljs-comment">// @author       You //作者名字</span><span class="hljs-comment">// @match        https://www.tampermonkey.net/index.php?ext=dhdg //应用在哪个网站上</span><span class="hljs-comment">// @grant        none //添加油猴的API</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    'use strict'</span>; <span class="hljs-comment">// 严格模式</span>    <span class="hljs-comment">// 从这里开始写代码</span>&#125;)();</code></pre><p>我们先来编写一个脚本练练手，脚本的目标是当访问bilibili主页时，会弹出”Hello World!”</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         Hello World!</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    'use strict'</span>;    alert(<span class="hljs-string">"Hello World!"</span>);&#125;)();</code></pre><p><img src="/image/v2-77fdbe51956f0aa735764caebb2055d7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>经过上面的简单的测试后，下面来看一下如何用油猴脚本将B站打开的网页图片放在一个方框中进行显示，然后点击可以直接进行预览。</p><p><img src="/image/v2-134f4d56dc979fcc5d4dadb7775f4f38_b.webp" srcset="/img/loading.gif" alt="img"></p><p>最终效果</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>引入jQuery</li><li>引入Bootstrap</li><li>引入Vue</li></ul><p>需要准备以上的3样东西，jQuery是用来操作DOM，Vue是用来创建页面，而Bootstrap是用来丰富样式。这里这3个库的使用方法就省略了，如果有兴趣可以看一下相关的文章。</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         B站图片爬取</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/*</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// @resource     customCSS https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/vue</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">  "use strict"</span>;  $(<span class="hljs-string">"head"</span>).append($(<span class="hljs-string">`&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css"&gt;`</span>));&#125;)();</code></pre><p>引入了这三个库后就可以为所欲为了。</p><h1 id="外部引入脚本"><a href="#外部引入脚本" class="headerlink" title="外部引入脚本"></a>外部引入脚本</h1><p>由于油猴编辑器太难用，如果在外部编辑器编辑好了再复制到油猴脚本里面，这个过程就比较繁琐，所以我们可以<strong>让油猴插件引用外部文件。</strong></p><p>在扩展里面找到油猴插件点击<code>详细信息-允许访问文件网址</code></p><p><img src="/image/v2-e79a68dae8f50f075a296eb75dc423dc_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-0228dbdc2cad802583147263f0d0891f_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>剩下的在脚本中编写：</p><pre><code class="hljs js"><span class="hljs-comment">// @require      file://E:\study\tampermonkey\test.js(脚本的地址)</span></code></pre><p>到这一步就万事俱备，只差代码了！由于代码的编写过程与本篇幅无关，所以直接贴上最后的代码。</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         B站图片爬取</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/*</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// @resource     customCSS https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/vue</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">  "use strict"</span>;  $(<span class="hljs-string">"head"</span>).append($(<span class="hljs-string">`&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css"&gt;`</span>));  <span class="hljs-keyword">var</span> divApp = $(    <span class="hljs-string">`</span><span class="hljs-string">&lt;div style="position:fixed; z-index:1000;top: 80vh;left: 5vw" id="myPlan"&gt;</span><span class="hljs-string">  &lt;div v-if="showMassage" style="position: fixed;z-index: -1;width: 100vw;height: 100vh;top: 0;right:0;background-color:rgba(0,0,0,0.5);"&gt;&lt;/div&gt;</span><span class="hljs-string">  &lt;button class="btn btn-primary" @click="showM"&gt;提取图片&lt;/button&gt;</span><span class="hljs-string">  &lt;div v-if="showMassage"</span><span class="hljs-string">       class="container"</span><span class="hljs-string">       style="position:fixed;background-color:rgba(0,0,0,0.5);;display: flex;flex-wrap: wrap;overflow: auto;width: 600px;height: 500px;top: 50%;left: 50%;transform: translate(-50%, -50%);"&gt;</span><span class="hljs-string">       &lt;div  v-for="(image,index) in images"  :key="index"&gt;</span><span class="hljs-string"></span><span class="hljs-string">       &lt;a :href="image.src" target="frame1"&gt;&lt;img :src="image.src" class="rounded float-left" style="min-width: 100px;margin: 10px;height: 80px" alt=""&gt;&lt;/a&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/li&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/div&gt;`</span>  );  $(<span class="hljs-string">"#app"</span>).append(divApp);  <span class="hljs-comment">/*Vue操作*/</span>  <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">"#myPlan"</span>,    data: &#123;      showMassage: <span class="hljs-literal">false</span>,      images: []    &#125;, <span class="hljs-attr">methods</span>: &#123;      showM() &#123;        <span class="hljs-keyword">this</span>.showMassage = !<span class="hljs-keyword">this</span>.showMassage;        <span class="hljs-keyword">this</span>.images = $(<span class="hljs-string">"img"</span>);      &#125;    &#125;  &#125;);&#125;)();</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bootstrap其实不引入也可以，没有怎么用到，Tampermonkey如果会用的话，还是非常好用的，甚至还可以当做爬虫使用，油猴对于前端来说使用起来几乎没有任何门槛，但是对于没有编程经验的人如果想要自行编写脚本，那还是具有一定的难度。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>油猴脚本</tag>
      
      <tag>浏览器插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js的替代品—Deno初体验</title>
    <link href="/2020/05/27/Node.js%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94Deno%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2020/05/27/Node.js%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94Deno%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Deno是什么"><a href="#Deno是什么" class="headerlink" title="Deno是什么"></a>Deno是什么</h1><p>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly，说简单点就是Node.js的一个替代品。</p><p><a href="https://deno.land/" target="_blank" rel="noopener">Deno — A secure runtime for JavaScript and TypeScript.deno.land</a></p><h1 id="为什么会出现Deno"><a href="#为什么会出现Deno" class="headerlink" title="为什么会出现Deno"></a>为什么会出现Deno</h1><ol><li><code>Node.js</code>自己的模块格式<code>CommonJS</code>与<code>ES</code>模块不兼容。</li><li><code>node_modules</code>和的<code>package.json</code>在项目越来越大后变得难以管理。</li><li><code>Node.js</code>并不完善的功能，导致外部工具层出不穷。</li></ol><p>由于上面这些原因，Ryan Dahl决定放弃Node.js，从头写一个替代品，彻底解决这些问题。</p><p>deno这个名字就是来自Node的字母重新组合（Node = no + de）表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>使用TypeScript或者JavaScript</li><li>支持ES模块</li><li>安全控制（权限管理）</li><li>全局await</li><li>去中心化Packages</li><li>内置测试</li><li>标准库</li><li>浏览器兼容的API</li><li>Modern Js</li><li>执行Wasm二进制文件</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>开发工具选择：VScode</p><p><img src="/image/v2-6178dcee1166f01b959813c45bb4f7dd_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>官网提供了很多种安装方法，这里只说一下我是怎么安装的。</p><p>使用WIN（即Ctrl右边的键）+R组合键打开运行窗口，输入powershell，回车即可。</p><p>然后在新弹出的窗口中输入下面的命令。</p><pre><code class="hljs powershell">iwr https://deno.land/x/install/install.ps1 <span class="hljs-literal">-useb</span> | iex</code></pre><p><img src="/image/v2-bd054d423981c16c17ba7d68e5e45214_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果看到这个界面，就说明已经安装成功。</p><h1 id="去中心化packages"><a href="#去中心化packages" class="headerlink" title="去中心化packages"></a>去中心化packages</h1><p>用过<code>Node.js</code>后都知道，如果随着项目的增长，<code>package.json</code>文件会变得越来越臃肿，而且运行<code>npm install</code>时还会有几率出现未知的错误。</p><p>Deno为了解决这个痛点，同时还支持了ES模块，所以可以直接通过<code>import XXX from (URL地址)</code>的形式来导入包。</p><h1 id="标准库模块"><a href="#标准库模块" class="headerlink" title="标准库模块"></a>标准库模块</h1><p>Deno官方提供的模块可以直接在官网上面进行查看。</p><p><a href="https://deno.land/std" target="_blank" rel="noopener">https://deno.land/std</a></p><h1 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h1><p><strong>在读取脚本的时候必须使用参数，显式打开权限，不然会报错</strong>，这一点跟Node.js完全不同，可能才入手Deno时会很不习惯。如：<code>deno run --allow-read index.ts</code></p><pre><code class="hljs text">--allow-read：打开读权限，可以指定可读的目录，比如--allow-read&#x3D;&#x2F;temp。--allow-write：打开写权限。--allow-net&#x3D;google.com：允许网络通信，可以指定可请求的域，比如--allow-net&#x3D;google.com。--allow-env：允许读取环境变量。</code></pre><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>不管你愿不愿意，TypeScript的广泛应用的确是未来前端语言的趋势，现在Vue3.0也使用了TypeScript，而且如果你拥有一种后端语言的基础，上手TypeScript是非常简单的，所以还不赶紧学一波TypeScript。</p><h1 id="全局await"><a href="#全局await" class="headerlink" title="全局await"></a>全局await</h1><p>await不用再捆绑在async函数中，可以直接在全局进行使用。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> TextEncoder();<span class="hljs-keyword">const</span> greetText = encoder.encode(<span class="hljs-string">"Hello World"</span>);<span class="hljs-keyword">await</span> Deno.writeFile(<span class="hljs-string">"Hello.txt"</span>, greetText);</code></pre><p>上面的代码完成了一个文件写入的操作，可以看到，就算不在async函数中，同样可以使用await。</p><h1 id="创建简单服务器"><a href="#创建简单服务器" class="headerlink" title="创建简单服务器"></a>创建简单服务器</h1><p>根据官方的提示，我们用Deno来创建一个简单的服务器。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; serve &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"https://deno.land/std/http/server.ts"</span>;<span class="hljs-keyword">const</span> s = serve(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8000</span> &#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"http://localhost:8000/"</span>);<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> req <span class="hljs-keyword">of</span> s) &#123;  req.respond(&#123; <span class="hljs-attr">body</span>: <span class="hljs-string">"Hello World\n"</span> &#125;);&#125;</code></pre><p>运行</p><pre><code class="hljs powershell">deno run -<span class="hljs-literal">-allow</span><span class="hljs-literal">-net</span> index.ts</code></pre><p>记得一定要加上<code>--allow-net</code>权限，不然会直接报错。</p><p>运行成功后通过浏览器打开<code>localhost:8000</code> 可以看到<code>Hello World</code>说明我们的服务器已经打开成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Deno从体验上来说非常不错，自身就支持<code>TypeScript</code>解析，而且解决了<code>package</code>这个痛点，但是现在作用于生产环境还是太早，因为它的社区还相对不成熟，肯定比不过经过了多年沉淀的<code>Node.js</code>，也许多年后会替代<code>Node.js</code>，但肯定不是现在。</p><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2020/01/deno-intro.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：C++入门</title>
    <link href="/2020/05/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1. IDE"></a><strong>1. IDE</strong></h1><h2 id="1-1-Visual-Studio"><a href="#1-1-Visual-Studio" class="headerlink" title="1.1 Visual Studio"></a><strong>1.1 Visual Studio</strong></h2><p><img src="/image/v2-265ce98a09b8b29727a4c13fc8ddada8_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="1-2-CLion"><a href="#1-2-CLion" class="headerlink" title="1.2 CLion"></a><strong>1.2 CLion</strong></h2><p>我最后还是选择了 <strong>CLion</strong> 因为之前一直用的JetBrains公司开发的IDE工具，换成Visual Studio突然还不习惯，虽然Visual Studio是我接触的第一款IDE，但是用它来编写C++代码提示居然默认不选中，编写C#的时候都可以，网上搜索发现Visual Studio编写C++代码就是这么设计的！（黑人问号？）</p><p>当然IDE这种东西还是自己顺手就好，如果你喜欢，你完全可以用记事本来写程序。</p><h3 id="1-2-1-CLion-运行环境"><a href="#1-2-1-CLion-运行环境" class="headerlink" title="1.2.1 CLion 运行环境"></a><strong>1.2.1 CLion 运行环境</strong></h3><p>因为我安装了Visual Studio所以可以直接导入Visual Studio的运行环境。</p><h3 id="1-2-2-中文乱码"><a href="#1-2-2-中文乱码" class="headerlink" title="1.2.2 中文乱码"></a><strong>1.2.2 中文乱码</strong></h3><p><img src="/image/v2-d81e1dd047d2de11c6472a4d1bb73032_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>图中的设置部分换成<code>UTF-8</code>，然后右下角控制台格式切换为<code>GBK</code></p><p><img src="/image/v2-5ef6f95e5ee2cc295c8fed2b35cfe396_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a><strong>2. 入门</strong></h1><h2 id="2-1-Hello-World"><a href="#2-1-Hello-World" class="headerlink" title="2.1 Hello, World!"></a><strong>2.1 Hello, World!</strong></h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, World!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-2-控制台打印"><a href="#2-2-控制台打印" class="headerlink" title="2.2 控制台打印"></a><strong>2.2 控制台打印</strong></h2><p>需要引入<code>using namespace std;</code>，然后通过<code>cout &lt;&lt; XXX &lt;&lt; endl;</code>打印，不得不说学过高级语言后觉得这实在很难用。</p><p>虽然可以用C语言的<code>printf()</code>但是你如果要打印一个变量需要给出类型，比如：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, a);<span class="hljs-comment">// 必须指定类型，不然会报错</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-3-清除控制台"><a href="#2-3-清除控制台" class="headerlink" title="2.3 清除控制台"></a><strong>2.3 清除控制台</strong></h2><pre><code class="hljs abnf">system(<span class="hljs-string">"cls"</span>)<span class="hljs-comment">;</span></code></pre><h2 id="2-4-保留关键字"><a href="#2-4-保留关键字" class="headerlink" title="2.4 保留关键字"></a><strong>2.4 保留关键字</strong></h2><p>C++中预先保留的单词，<strong>在定义变量或者常量时候，不要用关键字</strong></p><p><img src="/image/v2-24cc250da7e38eb4e1399bd71d8e7d57_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a><strong>3. 数据类型</strong></h1><h2 id="3-1-整形"><a href="#3-1-整形" class="headerlink" title="3.1 整形"></a><strong>3.1 整形</strong></h2><p><img src="/image/v2-aef5c9ea7a02946a2d07f4d86769f74d_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a><strong>3.2 浮点型</strong></h2><p>用于表示小数</p><p>浮点型变量分为两种：</p><ol><li>单精度float</li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><p><img src="/image/v2-542adae633ed058045b4c73885156ae4_720w.png" srcset="/img/loading.gif" alt="img"></p><p><strong>一般情况下<code>float</code>就足够了，如果不够用再定义<code>double</code>。</strong></p><h2 id="3-3-字符"><a href="#3-3-字符" class="headerlink" title="3.3 字符"></a><strong>3.3 字符</strong></h2><p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p><ul><li>C和C++中字符型变量只占用<code>1个字节</code>。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元。</li></ul><h2 id="3-4-字符串"><a href="#3-4-字符串" class="headerlink" title="3.4 字符串"></a><strong>3.4 字符串</strong></h2><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p><p><strong>C++风格字符串</strong>： <code>string 变量名 = &quot;字符串值&quot;</code> 需要加入头文件<code>#include&lt;string&gt;</code></p><h2 id="3-5-布尔类型-bool"><a href="#3-5-布尔类型-bool" class="headerlink" title="3.5 布尔类型 bool"></a><strong>3.5 布尔类型 bool</strong></h2><ul><li>true — 真（本质是1）</li><li>false — 假（本质是0）</li><li><strong>bool类型占1个字节大小</strong></li></ul><h2 id="3-6-转义字符"><a href="#3-6-转义字符" class="headerlink" title="3.6 转义字符"></a><strong>3.6 转义字符</strong></h2><p><img src="/image/v2-e34ba010b952bd041443d31ffe36d0e7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a><strong>4. 运算符</strong></h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a><strong>4.1 算术运算符</strong></h2><p><img src="/image/v2-ac1efde1442f83c97ea9e6745fbd39eb_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2 赋值运算符"></a><strong>4.2 赋值运算符</strong></h2><p><img src="/image/v2-b4b0e321fd55b5826c379c584528497a_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a><strong>4.3 比较运算符</strong></h2><p><img src="/image/v2-312d5675c66472b892bc77f7a454b5d6_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a><strong>4.4 逻辑运算符</strong></h2><p><img src="/image/v2-86186573378281763a342b4f13d8876b_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a><strong>5. 流程控制</strong></h1><h2 id="5-1-if语句（常用）"><a href="#5-1-if语句（常用）" class="headerlink" title="5.1 if语句（常用）"></a><strong>5.1 if语句（常用）</strong></h2><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(条件)</span></span>&#123; 条件满足执行的语句 &#125;</code></pre><p><img src="/image/v2-65f99327170787901b8b4f2639d9bb3b_720w.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//选择结构-单行if语句</span>    <span class="hljs-comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span>    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入一个分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"您输入的分数为： "</span> &lt;&lt; score &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//if语句</span>    <span class="hljs-comment">//注意事项，在if判断语句后面，不要加分号</span>    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学！！！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>多行格式if语句</strong>：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code></p><p><img src="/image/v2-098fbb7e36ce51d49281509de4769ff4_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>多条件的if语句</strong>：<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></p><p><img src="/image/v2-551948e98def630e5e86c56df0f51d6d_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了二本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了三本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上本科"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">700</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了北大"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">650</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了清华"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了人大"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了二本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了三本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上本科"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-2-三目运算符"><a href="#5-2-三目运算符" class="headerlink" title="5.2 三目运算符"></a><strong>5.2 三目运算符</strong></h2><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;    c = a &gt; b ? a : b;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//C++中三目运算符返回的是变量,可以继续赋值</span>    (a &gt; b ? a : b) = <span class="hljs-number">100</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-3-switch语句"><a href="#5-3-switch语句" class="headerlink" title="5.3 switch语句"></a><strong>5.3 switch语句</strong></h2><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(表达式)&#123;            <span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>：执行语句;<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>：执行语句;<span class="hljs-keyword">break</span>;    ...    <span class="hljs-keyword">default</span>:执行语句;<span class="hljs-keyword">break</span>;&#125;</code></pre><h2 id="5-4-循环结构"><a href="#5-4-循环结构" class="headerlink" title="5.4 循环结构"></a><strong>5.4 循环结构</strong></h2><h3 id="5-4-1-while循环语句（常用）"><a href="#5-4-1-while循环语句（常用）" class="headerlink" title="5.4.1 while循环语句（常用）"></a><strong>5.4.1 while循环语句（常用）</strong></h3><p><strong>语法：</strong><code>while(循环条件){ 循环语句 }</code></p><p><img src="/image/v2-12272cc189f8a1a6aac721cb5b4ca42f_720w.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;        num++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="5-4-2-do…while循环语句"><a href="#5-4-2-do…while循环语句" class="headerlink" title="5.4.2 do…while循环语句"></a><strong>5.4.2 do…while循环语句</strong></h3><p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p><p><strong>注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;        num++;    &#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>);    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="5-4-3-for循环语句（常用）"><a href="#5-4-3-for循环语句（常用）" class="headerlink" title="5.4.3 for循环语句（常用）"></a><strong>5.4.3 for循环语句（常用）</strong></h3><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a><strong>5.5 跳转语句</strong></h2><h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a><strong>5.5.1 break语句</strong></h3><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><h3 id="5-5-2-continue语句"><a href="#5-5-2-continue语句" class="headerlink" title="5.5.2 continue语句"></a><strong>5.5.2 continue语句</strong></h3><p><strong>作用：</strong>在<strong>循环语句</strong>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><h3 id="5-5-3-goto语句（慎用）"><a href="#5-5-3-goto语句（慎用）" class="headerlink" title="5.5.3 goto语句（慎用）"></a><strong>5.5.3 goto语句（慎用）</strong></h3><p><strong>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</strong></p><h1 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a><strong>6. 数组</strong></h1><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><h2 id="6-1-一维数组"><a href="#6-1-一维数组" class="headerlink" title="6.1 一维数组"></a><strong>6.1 一维数组</strong></h2><ol><li><code>数据类型 数组名[ 数组长度 ];</code></li><li><code>数据类型 数组名[ 数组长度 ] = { 值1，值2 ...};</code></li><li><code>数据类型 数组名[ ] = { 值1，值2 ...};</code></li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//定义方式1</span>    <span class="hljs-comment">//数据类型 数组名[元素个数];</span>    <span class="hljs-keyword">int</span> score[<span class="hljs-number">10</span>];    <span class="hljs-comment">//利用下标赋值</span>    score[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;    score[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;    score[<span class="hljs-number">2</span>] = <span class="hljs-number">85</span>;    <span class="hljs-comment">//利用下标输出</span>    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//第二种定义方式</span>    <span class="hljs-comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span>    <span class="hljs-comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span>    <span class="hljs-keyword">int</span> score2[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">//逐个输出</span>    <span class="hljs-comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span>    <span class="hljs-comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span>    <span class="hljs-comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; score2[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//定义方式3</span>    <span class="hljs-comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span>    <span class="hljs-keyword">int</span> score3[] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; score3[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="6-2-二维数组"><a href="#6-2-二维数组" class="headerlink" title="6.2 二维数组"></a><strong>6.2 二维数组</strong></h2><p>二维数组定义的四种方式：</p><ol><li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li><li><code>数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li></ol><blockquote><p>建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性</p></blockquote><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//方式1  </span>    <span class="hljs-comment">//数组类型 数组名 [行数][列数]</span>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];    arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;    arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">" "</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//方式2 </span>    <span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span>    <span class="hljs-keyword">int</span> arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =            &#123;                    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,                    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;            &#125;;    <span class="hljs-comment">//方式3</span>    <span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span>    <span class="hljs-keyword">int</span> arr3[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;    <span class="hljs-comment">//方式4 </span>    <span class="hljs-comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span>    <span class="hljs-keyword">int</span> arr4[][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="7-函数（重要）"><a href="#7-函数（重要）" class="headerlink" title="7. 函数（重要）"></a><strong>7. 函数（重要）</strong></h1><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a><strong>7.1 定义</strong></h2><pre><code class="hljs cpp">返回值类型 函数名 （参数列表）&#123;       函数体语句       <span class="hljs-keyword">return</span>表达式&#125;</code></pre><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><h2 id="7-2-值传递"><a href="#7-2-值传递" class="headerlink" title="7.2 值传递"></a><strong>7.2 值传递</strong></h2><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，如果形参发生，并不会影响实参</li></ul><h2 id="7-3-函数的声明"><a href="#7-3-函数的声明" class="headerlink" title="7.3 函数的声明"></a><strong>7.3 函数的声明</strong></h2><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><h2 id="7-4-分文件编写"><a href="#7-4-分文件编写" class="headerlink" title="7.4 分文件编写"></a><strong>7.4 分文件编写</strong></h2><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol><li>创建后缀名为.h的头文件</li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//swap.h文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//实现两个数字交换的函数声明</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-comment">//swap.cpp文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"swap.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//main函数文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"swap.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">200</span>;    swap(a, b);    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="8-指针-重要"><a href="#8-指针-重要" class="headerlink" title="8. 指针(重要)"></a><strong>8. 指针(重要)</strong></h1><p><strong>几乎所有的编程语言都存在着指针，但是C++中的指针真是我学过的语言中最复杂的。其它语言最多只了解一下值类型和引用类型需要理解指针，但是C++却需要操作指针。</strong></p><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a><strong>8.1 概念</strong></h2><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><p><strong>指针变量定义</strong>语法： <code>数据类型 * 变量名；</code></p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><h2 id="8-2-指针所占内存"><a href="#8-2-指针所占内存" class="headerlink" title="8.2 指针所占内存"></a><strong>8.2 指针所占内存</strong></h2><p>所有指针类型在32位操作系统下是4个字节</p><h2 id="8-3-空指针和野指针"><a href="#8-3-空指针和野指针" class="headerlink" title="8.3 空指针和野指针"></a><strong>8.3 空指针和野指针</strong></h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0的空间</span>    <span class="hljs-keyword">int</span> * p = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//访问空指针报错 </span>    <span class="hljs-comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span>    <span class="hljs-keyword">int</span> * p = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x1100</span>;    <span class="hljs-comment">//访问野指针报错 </span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>空指针和野指针都不是我们申请的空间，因此不要访问。</strong></p><h2 id="8-4-const修饰指针"><a href="#8-4-const修饰指针" class="headerlink" title="8.4 const修饰指针"></a><strong>8.4 const修饰指针</strong></h2><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><h1 id="9-结构体"><a href="#9-结构体" class="headerlink" title="9. 结构体"></a><strong>9. 结构体</strong></h1><p>结构体属于用户<strong>自定义的数据类型</strong>，允许用户存储不同的数据类型</p><p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><h2 id="9-1-指针"><a href="#9-1-指针" class="headerlink" title="9.1 指针"></a><strong>9.1 指针</strong></h2><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li></ul><h1 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a><strong>10. 参考资料</strong></h1><p>视频：<a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1et411b73Z</a></p><p>笔记：<a href="https://github.com/AnkerLeng/Cpp-0-1-Resource" target="_blank" rel="noopener">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>集成开发环境</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用JavaScript爬取豆瓣电影TOP250</title>
    <link href="/2020/05/21/%E7%94%A8JavaScript%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/"/>
    <url>/2020/05/21/%E7%94%A8JavaScript%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/</url>
    
    <content type="html"><![CDATA[<p>突然之间看到了一个网站，源代码是用JavaScript实现爬虫相关的功能，瞬间打开新世界的大门。稍加研究，准备用JavaScript制作爬虫练练手，<strong>爬取豆瓣榜单TOP250</strong>。</p><p>这里就不得不提一下，豆瓣榜单TOP250真是初学爬虫非常好的练手项目之一，非常简单，而且也不会有反爬措施，一爬一个准，如果爬不动，只能说是姿势不对，翻翻百度涨涨知识，回头再战。</p><p>随着现代网络技术的飞速发展，网络上有非常多的有用的数据，如果单单靠人工去收集这些数据，效率低下不说，而且工作重复性非常高，这时爬虫就是不二的选择。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p>由于运行环境是Node，所以需要先进行安装。</p><ul><li>axiso</li><li>cheerio</li><li>xlsx(sheetjs)</li></ul><h1 id="爬取的网址"><a href="#爬取的网址" class="headerlink" title="爬取的网址"></a>爬取的网址</h1><p><a href="https://movie.douban.com/top250" target="_blank" rel="noopener">https://movie.douban.com/top250</a></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先需要创建一个Nodejs项目，打开<code>cmd</code>使用命令<code>npm init</code>进行初始化，初始化完毕后需要导入上面的3个库。</p><pre><code class="hljs text">npm install axios cheerio xlsx --save</code></pre><p><code>cheerio</code>相当于一个精简的jQuery，几乎实现了所有的jQuery的API，同时对DOM的操作更加快速与强大。</p><p><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a></p><p><code>axios</code>是一个基于Promise的HTTP 库，可以用在浏览器和node.js中。也可以使用更好上手的<code>request</code> 。</p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>代码很简单</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;  axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());    &#125;);  &#125;);&#125;</code></pre><p>调用<code>axios.get</code>方法会返回一个Promise，所以我们可以直接通过<code>.then</code>获取返回的数据。</p><p>这里主要说一下选择器的思路。</p><p><img src="/image/v2-fa21a625e9957785561a151efd3557cf_b.webp" srcset="/img/loading.gif" alt="img"></p><p>直接通过浏览器的检索功能，找到含有文字内容的容器。</p><p>可以看到这个容器有一个类<code>info</code> ，我们可以单单选择这个类，然后输出一下试试</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);axios.get(<span class="hljs-string">`https://movie.douban.com/top250`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);  <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">".info"</span>).text());&#125;);</code></pre><p><img src="/image/v2-ba2d648a66775e0dc44d1982132ed59e_720w.jpg" srcset="/img/loading.gif" alt="img">输出结果太长，仅仅贴了一部分</p><p>往下翻了翻确定就是需要爬取的内容，然后完善代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);axios.get(<span class="hljs-string">`https://movie.douban.com/top250`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);  $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());  &#125;);&#125;);</code></pre><p>到这里，第一页的内容已经全部提取出来了，那么后面的内容怎么办呢，这时我们进到这个网站翻到第二页看看。</p><p>可以看到第二页的地址是：<code>https://movie.douban.com/top250?start=25&amp;filter=</code></p><p>第三页的地址是： <code>https://movie.douban.com/top250?start=50&amp;filter=</code></p><p>那么测试一下第一页的地址<code>https://movie.douban.com/top250?start=0&amp;filter=</code> ，测试结果发现能够正常打开首页。</p><p>这里就可以得出结论，后一页的地址仅仅改变前一页地址中的<code>start=</code> 后面的数字，并且比前一页多25。</p><p>那么到这里就可以写出完整代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;  axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());    &#125;);  &#125;);&#125;</code></pre><p>运行上面的代码，就可以将豆瓣TOP250的标题，评分，以及简介爬下来，但是现在问题来了，这种爬虫爬下来的数据既无法保存，也不方便查看，那么爬下来的意义又在哪里？如果能够将它保存为Excel，并且通过Excel打开就好了。</p><h1 id="保存为Excel"><a href="#保存为Excel" class="headerlink" title="保存为Excel"></a>保存为Excel</h1><p>上面的代码仅仅是爬取了数据，但是并没有将它导出为Excel，这个时候一个强大的库<code>sheetjs</code>就上场了。</p><p><code>sheetjs</code>能够将获取的数据通过Excel的形式导出。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/SheetJS/sheetjs">https://github.com/SheetJS/sheetjsgithub.com</a></p><p>但是<code>sheetjs</code>只能处理二维数组，所以我们需要将上面爬虫爬到的数据保存为二维数组的形式，再将它用<code>sheetjs</code>存储起来。</p><p>我们直接将上面的代码修改一下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">const</span> xlsx = <span class="hljs-built_in">require</span>(<span class="hljs-string">"xlsx"</span>);<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> arr = [];  arr[<span class="hljs-number">0</span>] = [<span class="hljs-string">"标题"</span>, <span class="hljs-string">"评分"</span>, <span class="hljs-string">"评论"</span>]; <span class="hljs-comment">// 表格的第一行</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>);    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 从第二行开始写入</span>      arr[index + i + <span class="hljs-number">1</span>] = [];      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = $(f).find(<span class="hljs-string">".title"</span>).text();      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = $(f).find(<span class="hljs-string">".rating_num"</span>).text();      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = $(f).find(<span class="hljs-string">".inq"</span>).text();    &#125;);  &#125;  <span class="hljs-keyword">let</span> filename = <span class="hljs-string">"top250.xlsx"</span>; <span class="hljs-comment">// 导出表格名称</span>  <span class="hljs-keyword">let</span> ws_name = <span class="hljs-string">"Sheet1"</span>; <span class="hljs-comment">// Excel第一个sheet的名称</span>  <span class="hljs-keyword">let</span> wb = xlsx.utils.book_new(), ws = xlsx.utils.aoa_to_sheet(arr);  xlsx.utils.book_append_sheet(wb, ws, ws_name);  <span class="hljs-comment">// 将数据添加到工作薄</span>  xlsx.writeFile(wb, filename); <span class="hljs-comment">// 导出Excel</span>&#125;main();<span class="hljs-comment">// 运行函数</span></code></pre><p>这里直接引入了<code>async</code>，<code>await</code>，简单的讲就是因为axiso获取页面内容为异步获取，如果使用Promise的<code>.then</code>的方式调用也是可以的，但是不如直接使用async，await简洁明了。</p><p>运行上面的代码后会在当前文件夹下面生成一个<code>top250.xlsx</code>文件，打开就可以看到我们爬取的数据。</p><p><img src="/image/v2-3b3cea67002ce1c3b7f79356133e2cec_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="在网页上面展示"><a href="#在网页上面展示" class="headerlink" title="在网页上面展示"></a>在网页上面展示</h1><p>经过测试，爬虫代码直接在浏览器上面跑会出现跨域问题，没有太好的方法解决，不过可以用<code>Nodejs</code>搭建后端，爬虫在后端爬取数据后返回前端。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我对于爬虫来说也是一个小白，如果说用Python爬取数据和JavaScript爬取数据有什么特别大的区别，我觉得在爬取数据量不是特别大的情况下，想用哪个用哪个，如果是需要大量爬取数据，还是推荐Python。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页抓取</tag>
      
      <tag>网页爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不用写代码就可以制作游戏的引擎：虚幻4</title>
    <link href="/2020/05/19/%E4%B8%8D%E7%94%A8%E5%86%99%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%9A%E8%99%9A%E5%B9%BB4/"/>
    <url>/2020/05/19/%E4%B8%8D%E7%94%A8%E5%86%99%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%9A%E8%99%9A%E5%B9%BB4/</url>
    
    <content type="html"><![CDATA[<p>最近两年虚幻4引擎名声大振，由于之前使用过Unity3D和Cocos Creator这两个游戏引擎。鉴于看到网上很多人说虚幻4是非常适合不会编程的人制作游戏的一款引擎，于是就准备尝试一番。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.unrealengine.com/zh-CN/?sessionInvalidated=true" target="_blank" rel="noopener">https://www.unrealengine.com/zh-CN/?sessionInvalidated=true</a></p><p>需要到虚幻4官网上面下载<code>Epic Games Launcher</code>，然后再通过这个启动器安装虚幻4引擎，安装的过程还是很顺利的，唯一不顺利的是虚幻4引擎也太大了吧，光下载包都快达到12G，而硬盘需要预留的空间接近40G。</p><h1 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h1><p>虚幻4非常吃配置，如果玩绝地求生都不太流畅的电脑，还是不要轻易尝试虚幻4引擎，这可能也是虚幻4这么多年，在国内一直被Unity和Cocos压一头的原因之一吧。</p><h1 id="商店"><a href="#商店" class="headerlink" title="商店"></a>商店</h1><p><img src="/image/v2-cbe1573fb42382c50134cbb01556e986_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>虚幻4提供了一个商店功能，这一点对比于Unity简直好了太多了，Unity独自一人想要制作游戏时基本很难找到整套资源。</p><p>看了一下Epic上面的资源，免费的资源还是比较少的，收费的资源占大多数，如果是一个人制作游戏玩玩的话免费的资源就够了，如果是想要做商用，可能就需要花钱进行购买资源，或者有自己的美术团队。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><img src="/image/v2-a441e743a0deaaaebbbb57b06df94321_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>在创建工程时，UE4会提供众多模板，几乎包含了现在的主流游戏类别，如果没有你心仪的模板，可以直接创建空白模板。</p><p><img src="/image/v2-1862aa257a14ab66107b2d9e115159bb_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>对于新人来说，肯定是选择创建<strong>蓝图</strong>项目，<strong>初学者内容包</strong>也建议选上，当你的项目创建之后，会给你很多基础的材质纹理和特效。</p><h1 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h1><p>从商店里面购买的资源都放在了库里面。需要主动点击添加到工程，<strong>由于当前4.25版本才更新不久，所以很多免费的资源只适配到4.24，这里推荐还是下载4.24版本的UE4。</strong></p><p><img src="/image/v2-7ed7dfef3f6c0ee8400ea5c612b0907b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>添加文件后，在内容管理处找到他们的场景文件，双击后经过漫长的导入，第一次应用时可能等了快10分钟吧。</p><p><img src="/image/v2-df828d200b8be1d2beab3b8c9d66f8b4_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>导入场景完成后，点击上面的运行，就可以进入游戏界面。由于之间创建的是第一人称游戏的模板，所以自带了射击功能。</p><p><img src="/image/v2-75eaa95318b30129878e597991041856_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><p>一般一个游戏的开发除了模型和音乐资源以及UI外，最重要的就是交互，如果没有交互，那就单单是一个静态场景，在Unity3D中需要自己编写<code>C#</code>脚本进行实现对于角色的控制，而在UE4中，它提供了一个蓝图系统，可以让制作游戏的新人学习成本大幅度下降，你可以将重心放在游戏内容和关卡设计上，而不用再去考虑怎么通过代码实现某项功能。</p><p>蓝图里几乎涵盖了游戏中所有可能用到的交互的事件，比如控制角色行走，造成伤害事件，这些如果是放在其它引擎中要自己写代码实现。</p><p>唯一的缺点就是…蓝图提供的API实在是太多了，如果真的要完全靠蓝图来做游戏，那需要比较熟悉这些API，并且根据蓝图制作出的游戏，性能上肯定比不过用C++脚本写出来的游戏。</p><p><img src="/image/v2-d64760a9a40d852cb570ed1fb4f7f5ba_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/image/v2-2ffaa4ecaf9ced492c5467701a3095d2_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>整个体验下来，就我自己感觉而言，相对于Unity3D引擎，优缺点挺明显的。</p><p>优点：</p><ul><li>自带商场里模型众多，独立制作游戏时不用担心翻遍全网而找不到心仪的资源。</li><li>蓝图系统非常强大，可以实现不编写代码，依靠蓝图就能做出一个完整的游戏。</li><li>官方学习文档十分丰富。</li></ul><p>缺点：</p><ul><li>非常消耗硬盘空间，安装时需要预留快40G的磁盘空间。</li><li>对于电脑配置要求较高，如果配置不好，可能在测试游戏时会非常卡顿。</li><li>自带商场里免费资源还是比较少的，大部分收费资源都不便宜。</li><li>国内使用UE4较少，如果遇到问题可能光百度还无法解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单易用的制作博客的框架：Hexo</title>
    <link href="/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/"/>
    <url>/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/</url>
    
    <content type="html"><![CDATA[<p>学习一项技术的最好方法就是写博客，博客不光可以分享你学到的知识，而且如果你的学习中有什么错误或者纰漏，偶尔也会被路过的大神指出。</p><p>使用Vue或者React搭建一个静态博客是非常简单的事情，但是如果想要搭建一个像知乎这种具有动态更新，还带有评论系统，并且界面还具有自适应，这些就显得不是那么容易。毕竟一个人的精力有限，如果需要面面俱到就需要花上很长的时间。</p><p>很多公司意识到了这些事情，所以推出了非常多的快速搭建博客的框架，大致看了一下，非常多的人都推荐使用Hexo，所以我也想尝试一下使用Hexo搭建博客，是不是真的那么方便。</p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>这两个软件是运行环境，必须要进行安装。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>装好了上面两个运行环境后，直接按住键盘上的<code>Ctrl右边的键</code>+<code>r</code> ，在打开的运行窗口中输入<code>cmd</code>，再在新弹出的窗口中输入<code>npm install -g hexo-cli</code>等待安装完成即可。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>到你需要创建项目的文件夹中，打开<code>cmd</code></p><p><img src="/image/v2-b0fca0c8dc063705e70cda5b6aa1e26d_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>在弹出的窗口中输入<code>hexo init 你需要创建的博客名</code>。</p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>创建完成后，进入到你创建的文件夹，会看到下面的目录样式。</p><pre><code class="hljs text">.├── _config.yml 网站的配置信息，您可以在此配置大部分的参数。├── package.json 应用程序的信息，如果需要更改需要对node有一定了解├── scaffolds 文章存放的文件夹。├── source 资源文件夹|   ├── _drafts|   └── _posts└── themes 主题文件夹。</code></pre><p>这时还需要再像上面一样打开<code>cmd</code> 输入<code>npm install</code> 回车运行，安装依赖包。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>刚才提到的<code>_config.yml</code>文件中，可以配置大部分的信息，比如网站的标题，描述，关键字。如果有需要的话，可以直接参考官方给出的配置文档。</p><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置hexo</a></p><p>如果按照上面的步骤，顺利走到了这里，那么继续按照上面的方法打开<code>cmd</code></p><p>输入<code>hexo server</code>，会看到如下图所示</p><p><img src="/image/v2-d7193f1d9bb78df6065e869b2d03f6b6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>将框起来的那部分在浏览器地址栏上进行输入。</p><p><img src="/image/v2-8d39b1b6dd060c0c038e99154a7ff28c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果看到这个界面，恭喜，你的博客框架已经大体搭建完成</p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>官方自带的主题不是很符合胃口，我认为使用Hexo搭建博客如果还需要自行敲代码不如直接使用Vue或者React搭建了，所以可以直接使用人家开源出的主题。</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>下载完成后直接放在<code>themes</code>文件夹中</p><p><img src="/image/v2-a0b4cfe339bea903b23195102534a226_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>要进行应用需要修改项目根目录中的<code>_config.yml</code>文件中的<code>theme</code>属性，修改为刚才下载的主题文件夹名。</p><p>例如：<code>theme: hexo-theme-fluid</code></p><p>再通过<code>hexo serve</code>运行项目，就可以查看到效果。</p><p><img src="/image/v2-847e34e46aee11dc944de56d5a07a235_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果需要对主题进行修改，可以直接进入主题文件夹中找到 <code>_config.yml</code> 文件，修改里面的参数。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>在项目文件中打开<code>cmd</code>输入命令<code>hexo generate</code> 会看见多出来一个<code>public</code>文件夹，将里面的内容直接发布到自己的服务器上面即可。如果没有自己的服务器，也可以使用GitHub Pages，但是GitHub Pages由于特殊原因，在国内访问速度会比较慢。</p><p>至于GitHub Pages是什么，以及怎么用，可以看这篇~</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Using_Github_pages" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Using_Github_pages</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>如果你仅仅只需要使用主题搭建自己的博客，不需要做太多的个性化修改，那么使用Hexo确实是一个非常好的选择，几乎不需要太多的编程知识就可以搭建出一个还不错的博客界面，但是如果你想搭建高度自定义的博客界面，那还是不太推荐使用Hexo框架，主要是EJS这玩意…现在几乎已经不用了。</p><hr><h1 id="6月24日-再更新"><a href="#6月24日-再更新" class="headerlink" title="6月24日 再更新"></a>6月24日 再更新</h1><p>我自己尝试做网站的时候遇到了客户端渲染和服务器渲染的问题，简单的说Vue和React搭建出的单页面应用都为客户端渲染，不利于SEO，而Hexo就完全打包成了一个静态页面…有利于SEO，至于使用Vue的服务器渲染可以看这篇：</p><p><a href="https://zhuanlan.zhihu.com/p/149981401" target="_blank" rel="noopener">Vue服务器渲染优秀项目</a></p><p>总的来说，如果你想将博客布置到GitHub Pages那么Hexo优于使用Vue搭建的页面，因为它更加利于SEO。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客非常好用的评论开源项目：Gitalk</title>
    <link href="/2020/05/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E8%AF%84%E8%AE%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AGitalk/"/>
    <url>/2020/05/17/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%94%A8%E7%9A%84%E8%AF%84%E8%AE%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%EF%BC%9AGitalk/</url>
    
    <content type="html"><![CDATA[<p>我的个人博客想要开通一个留言或者评论功能。因为我对后端并不是太了解，所以如果让我用Java开发一个留言板的功能，也许能够做到，不过就是太花时间，而且可能会有很多BUG，于是最近我发现了一个简单好用，并且拥有着高颜值的现成的开源项目Gitalk。</p><h1 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h1><p><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">gitalk/gitalkgithub</a></p><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>使用 GitHub 登录</li><li>支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru]</li><li>支持个人或组织</li><li>无干扰模式（设置 distractionFreeMode 为 true 开启）</li><li>快捷键提交评论 （cmd|ctrl + enter）</li></ul><p>其实至于如何使用Gitalk文档上面已经有了很详细的说明，然而我根据官网的文档集成Gitalk的过程并不是太顺利，所以这篇文章就描诉一下我遇到的问题，以及最后是如何解决的。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>两种方式</p><ul><li>直接引入</li></ul><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- or --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/gitalk/dist/gitalk.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><ul><li>npm 安装</li></ul><pre><code class="hljs ps1con">npm i --save gitalk</code></pre><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'gitalk/dist/gitalk.css'</span><span class="hljs-keyword">import</span> Gitalk <span class="hljs-keyword">from</span> <span class="hljs-string">'gitalk'</span></code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>首先，您需要选择一个公共GitHub存储库（已存在或创建一个新的github存储库）用于存储评论。</p><p>然后需要创建 <strong>GitHub Application</strong>，如果没有可以点击下面的网址进行注册：</p><p><a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a></p><p><img src="/image/v2-1573c22526a5460dad8c09ba62ebdfcd_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><p>注册成功后会跳转到一个界面，记录下下图中所示的两项：</p><p><img src="/image/v2-360a2a23d70528d9b90d583dc630f634_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果说手快关闭了界面，可以点击右上角的头像<code>Settings-Developer settings-OAuth Apps</code> 就能找到刚才创建的应用。</p><p>最后, 您可以选择如下的其中一种方式应用到页面：</p><h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>添加一个容器：</p><pre><code class="hljs text">&lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</code></pre><p>用下面的 Javascript 代码来生成 Gitalk插件：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> gitalk = <span class="hljs-keyword">new</span> Gitalk(&#123;  clientID: <span class="hljs-string">'刚才记录的client ID'</span>,  clientSecret: <span class="hljs-string">'刚才记录的client Secret'</span>,  repo: <span class="hljs-string">'博客域名'</span>,  owner: <span class="hljs-string">'管理者的github账号'</span>,  admin: <span class="hljs-string">'管理者的github账号'</span>,  id: location.pathname,      <span class="hljs-comment">// 如果要每篇文章都使用独立评论 需要改为id: location.hash</span>                              <span class="hljs-comment">// 或者id: md5(location.hash)注意md5包需要单独引入</span>  distractionFreeMode: <span class="hljs-literal">false</span>  <span class="hljs-comment">// 无干扰模式</span>&#125;)gitalk.render(<span class="hljs-string">'gitalk-container'</span>)</code></pre><h2 id="方式2：在React使用"><a href="#方式2：在React使用" class="headerlink" title="方式2：在React使用"></a>方式2：在React使用</h2><p>使用以下代码引入Gitalk组件</p><pre><code class="hljs text">import GitalkComponent from &quot;gitalk&#x2F;dist&#x2F;gitalk-component&quot;;</code></pre><p>按以下方式在React中使用Gitalk组件</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">GitalkComponent</span> <span class="hljs-attr">options</span>=<span class="hljs-string">&#123;&#123;</span></span><span class="hljs-tag">  <span class="hljs-attr">clientID:</span> "<span class="hljs-attr">...</span>",</span><span class="hljs-tag">  // <span class="hljs-attr">...</span></span><span class="hljs-tag">  // 设置项</span><span class="hljs-tag">&#125;&#125; /&gt;</span></code></pre><p>方式3：在Vue中使用</p><p>我的项目是Vue搭建的，可是官方并没有告诉我们在Vue中的使用方法</p><p>不过还是可以用方法1的方式自己封装出一个组件</p><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"gitalk-container"</span>&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">mounted() &#123;</span><span class="hljs-regexp">  const gitalk = new Gitalk(&#123;</span><span class="hljs-regexp">    clientID: '刚才记录的client ID',</span><span class="hljs-regexp">    clientSecret: '刚才记录的client Secret',</span><span class="hljs-regexp">    repo: '主页域名',</span><span class="hljs-regexp">    owner: '管理者的github账号',</span><span class="hljs-regexp">    admin: '管理者的github账号',</span><span class="hljs-regexp">    id: location.pathname,      /</span><span class="hljs-regexp">/ 如果要每篇文章都使用独立评论 需要改为 location.hash</span><span class="hljs-regexp">                                /</span><span class="hljs-regexp">/ 或者md5(location.hash)注意md5包需要单独引入</span><span class="hljs-regexp">    distractionFreeMode: false  /</span><span class="hljs-regexp">/ 无干扰模式</span><span class="hljs-regexp">  &#125;);</span><span class="hljs-regexp">  gitalk.render("gitalk-container");</span><span class="hljs-regexp">&#125;</span></code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>项目没有部署上线在本地测试时，点击登陆会直接跳到主页，并且会报错，经过几番折腾，我发现必须部署上线后才能使用GitHub登陆。</p><h1 id="repo填写错误"><a href="#repo填写错误" class="headerlink" title="repo填写错误"></a>repo填写错误</h1><p><img src="/image/v2-278e409865b9e53524e26e966521f64e_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>上图为我的repo填写错误而报错：<code>Error:Not Found.</code></p><p>后来经过测试，我改成了我的<code>GitHub pages</code>域名后，测试正常。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p><img src="/image/v2-12cd22a815ef4fdf65e26cffb2dbe52c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果每篇文章使用了不同的评论页，就需要登陆设置的管理员GitHub账号，每篇文章都要点击一下进行初始化。如果觉得手动一篇一篇的点击初始化太麻烦，可以看看网络上已经有的自动初始化脚本的文章。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>开源项目</tag>
      
      <tag>独立博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公众号自定义样式，令人惊叹的文章编辑器</title>
    <link href="/2020/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2020/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>最近在弄自己的公众号，虽然关注的人就只有我自己…都是眼泪啊！</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h1><p>众所周知，一些比较大的公众号推送的文章都是花里胡哨的。尤其是一些介绍自己产品的公众号，比如说分割线样式：</p><p><img src="/image/v2-7996702b242cba19da35ef902f957c98_720w.png" srcset="/img/loading.gif" alt="img"></p><p>再比如说这种背景和边框：</p><p><img src="/image/v2-2ad064822e44e65f74d2a35d610c93db_720w.png" srcset="/img/loading.gif" alt="img"></p><p>再比如：</p><p><img src="/image/v2-5bcf323d6ebcd5bb26b1f2e9f80461e0_720w.png" srcset="/img/loading.gif" alt="img"></p><p>这种一眼看上去就有很强的视觉冲击的文字，而我自己的文章呢？</p><p><img src="/image/v2-48b8452c1274b5502bdae90df7c9a177_720w.png" srcset="/img/loading.gif" alt="img"></p><p>我的天，黑白的性冷风，突然感觉low爆了，不过我的文章主要是想以内容为主，如果太过于花哨反而会影响阅读体验。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a><strong>实践</strong></h1><p>为了实现上面的那些分割线效果，我还专门去搜索了下这些样式是怎么制作的，结果搜出来的结果都是讲的如何<strong>用编辑器制作样式！然而我想知道的是编辑器具体是怎么制作样式的。</strong></p><p>没有办法搜索不到就只有自己动手研究了，首先用我们强大的Chrome浏览器，来到公众号文章编辑界面，随便从其他的地方复制一个样式：</p><p><img src="/image/v2-7ec49146c4134663c96fd9d87b4ddd01_720w.png" srcset="/img/loading.gif" alt="img"></p><p>就用它开刀好了，按F12打开开发者模式，选中这玩意。</p><p><img src="/image/v2-067e8083ba2e2ec27512c7d6769b9816_720w.png" srcset="/img/loading.gif" alt="img"></p><p>发现开发者工具上面有个<code>section</code>标签，等会，你难道不是一个普通的文字编辑器？</p><p><img src="/image/v2-b0efb1b79920a5f6cfddf318f9324969_720w.png" srcset="/img/loading.gif" alt="img"></p><p>还真不是，它居然是用<code>iframe</code>从外面引入的。</p><p>那么接下来尝试复制一下上面的那个<code>section</code>标签试试</p><p><img src="/image/v2-b9b48deb59c3e7e578e48b568e924554_720w.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-ed3e2a322f405140c7c152f4fa47f4a6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>变成两个了！谜题解开了，样式的制作就是通过section标签，然后加上<strong>行内样式</strong>，就能制作出这种效果，那么知道原理后，我们自己动手实现上面的那个样式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://mmbiz.qpic.cn/sz_mmbiz_png/YMeJJzp9Dn2IxGfxCmDyY0OLaLbWkAUk37JCybKOFoPx52vfAia1RocLNOX31c0icJgGbUOica990Hox44QI9pSCA/?wx_fmt=png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background-color: red;height: 40px;line-height: 40px;padding-left: 10px;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 0;"</span>&gt;</span>这里是一些文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>再往浏览器上面一抛</p><p><img src="/image/v2-69085662ffb4e23561b7fea6316497d2_720w.png" srcset="/img/loading.gif" alt="img"></p><p>选中标签右键点击<code>Edit as HTML</code>就可以直接对网页上的标签进行编辑了。</p><p><img src="/image/v2-1ec352622828e38d089ecf3d3add117b_720w.png" srcset="/img/loading.gif" alt="img"></p><p>好了，可以看出样式正确的显示出来了，然后尝试保存后再进去看一下，没问题，样式还在，根据这种方法，就可以实现样式的自定义了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a><strong>写在最后</strong></h1><p>什么？你看到这里然后你说从那个性冷淡风下面开始你就不知道我在讲什么了？你问我iframe，section是啥，还有后面那段代码为什么能改变样式？</p><p>这些属于前端开发的内容了，一两句也说不清楚，如果有兴趣可以去学习一下前端开发相关的知识。</p><p>研究了这么多，还是推荐直接使用市面上现有的编辑器，毕竟自己制作样式，还是挺麻烦的，而且辛苦制作出的样式，还不一定有别人的好看。</p><ul><li>135编辑器</li><li>新媒体管家</li></ul>]]></content>
    
    
    <categories>
      
      <category>微信公众号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/使用Taro开发微信养花小程序</title>
    <link href="/2020/05/07/web%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Taro%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%BB%E8%8A%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/05/07/web%E5%BC%80%E5%8F%91/%E4%BD%BF%E7%94%A8Taro%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%BB%E8%8A%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Taro简介"><a href="#Taro简介" class="headerlink" title="Taro简介"></a>Taro简介</h1><p>Taro是一套遵循 React 语法规范的<strong>多端开发</strong>解决方案。</p><p>使用Taro，只需要书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信 / 京东 / 百度 / 支付宝 / 字节跳动 小程序、快应用、H5、React-Native 等）运行的代码。</p><p>注意：<strong>如果不需要进行多端开发并且需要对小程序深度定制，建议还是直接使用原生开发。</strong></p><h1 id="安装Taro"><a href="#安装Taro" class="headerlink" title="安装Taro"></a>安装Taro</h1><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @tarojs/cli</code></pre><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><pre><code class="hljs ebnf"><span class="hljs-attribute">taro init myApp</span></code></pre><p>模板拉取完毕后会给你一些选项，根据自身喜好选择就行了，我这里使用TypeScript。</p><p><img src="/image/v2-6f735d69e4c55ab67eb0ab09edc0f877_b.png" srcset="/img/loading.gif" alt="img"></p><p>其中因为node-sass的原因，运行npm install时可能会报错。这个时候就将npm换成淘宝镜像应该就可以解决。</p><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span></code></pre><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>经过漫长的等待后，你还需要准备微信开发者工具，因为必须要通过开发者工具进行预览。</p><p>打开工程目录下的package.json，可以看到下面的命令就是构建不同平台的小程序。使用方法是在前面加上npm run或者yarn比如预览微信小程序就是npm run dev:weapp </p><pre><code class="hljs 1c"><span class="hljs-string">"scripts"</span>: &#123;  <span class="hljs-string">"build:weapp"</span>: <span class="hljs-string">"taro build --type weapp"</span>,  <span class="hljs-string">"build:swan"</span>: <span class="hljs-string">"taro build --type swan"</span>,  <span class="hljs-string">"build:alipay"</span>: <span class="hljs-string">"taro build --type alipay"</span>,  <span class="hljs-string">"build:tt"</span>: <span class="hljs-string">"taro build --type tt"</span>,  <span class="hljs-string">"build:h5"</span>: <span class="hljs-string">"taro build --type h5"</span>,  <span class="hljs-string">"build:rn"</span>: <span class="hljs-string">"taro build --type rn"</span>,  <span class="hljs-string">"build:qq"</span>: <span class="hljs-string">"taro build --type qq"</span>,  <span class="hljs-string">"build:quickapp"</span>: <span class="hljs-string">"taro build --type quickapp"</span>,  <span class="hljs-string">"dev:weapp"</span>: <span class="hljs-string">"npm run build:weapp -- --watch"</span>,  <span class="hljs-string">"dev:swan"</span>: <span class="hljs-string">"npm run build:swan -- --watch"</span>,  <span class="hljs-string">"dev:alipay"</span>: <span class="hljs-string">"npm run build:alipay -- --watch"</span>,  <span class="hljs-string">"dev:tt"</span>: <span class="hljs-string">"npm run build:tt -- --watch"</span>,  <span class="hljs-string">"dev:h5"</span>: <span class="hljs-string">"npm run build:h5 -- --watch"</span>,  <span class="hljs-string">"dev:rn"</span>: <span class="hljs-string">"npm run build:rn -- --watch"</span>,  <span class="hljs-string">"dev:qq"</span>: <span class="hljs-string">"npm run build:qq -- --watch"</span>,  <span class="hljs-string">"dev:quickapp"</span>: <span class="hljs-string">"npm run build:quickapp -- --watch"</span>&#125;,</code></pre><p>编译完成后会出现一个dist文件夹，我们将工程文件夹导入到微信开发者工具中。 如果导入成功就会看到下面的界面：</p><p><img src="/image/v2-9f95a15fefdb30dc3a45d66d2953d83e_b.png" srcset="/img/loading.gif" alt="img"></p><p>我们再次引入Taro-ui。这个是UI组件库，有些组件如果自己去写的话不仅非常消耗时间，而且可能会有BUG，所以这个时候就需要选用UI组件库。</p><p><a href="https://github.com/NervJS/taro-uigithub.com" target="_blank" rel="noopener">https://github.com/NervJS/taro-uigithub.com</a></p><p>引入</p><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> taro-ui</code></pre><h1 id="正式开发"><a href="#正式开发" class="headerlink" title="正式开发"></a>正式开发</h1><p>由于想要开发的代码逻辑还是比较多的，所以这里就不一步一步的讲解代码。</p><p><img src="/image/v2-9dad95b98abfa221827866e965591e11_b.png" srcset="/img/loading.gif" alt="img"></p><h1 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h1><p>先简单的搭出这样一个界面，其中植物有3种状态，一种是<strong>需要浇水</strong>，一种是<strong>正在成长</strong>，最后一种是<strong>已经枯萎</strong>。同时还设计了一个添加植物的按钮，通过这个按钮，能够新增植物。并且植物的数据是从数据库中进行读取，以保证下次打开小程序后这些数据仍然存在。</p><p><img src="/image/v2-502cdcdd83bfd5c6091b600f3e246d99_b.gif" srcset="/img/loading.gif" alt="img"></p><p>搭建中的界面</p><h1 id="植物管理"><a href="#植物管理" class="headerlink" title="植物管理"></a>植物管理</h1><p>由于我这里使用了TypeScript我就直接创建了一个植物类。</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> Flower &#123;  flowerName: <span class="hljs-built_in">string</span>  <span class="hljs-comment">// 植物名字</span>  overTime: <span class="hljs-built_in">number</span>    <span class="hljs-comment">// 浇水间隔</span>  imgUrl: <span class="hljs-built_in">string</span>      <span class="hljs-comment">// 植物图片地址</span>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">flowerName: <span class="hljs-built_in">string</span>, overTime: <span class="hljs-built_in">number</span>, imgUrl: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-keyword">this</span>.flowerName = flowerName    <span class="hljs-keyword">this</span>.overTime = overTime    <span class="hljs-keyword">this</span>.imgUrl = imgUrl  &#125;&#125;</code></pre><p>然后实例化这个类，并且存到数组中供页面调用。</p><pre><code class="hljs routeros">import Flower <span class="hljs-keyword">from</span> <span class="hljs-string">'./Flower'</span>const flowers: Flower[] = []flowers.push(new Flower(<span class="hljs-string">'栀子花'</span>, 3600, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'丁香花'</span>, 1200, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'茉莉花'</span>, 2400, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'仙人掌'</span>, 3600, <span class="hljs-string">'图片地址'</span>))<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>flowers</code></pre><h1 id="后端和数据库"><a href="#后端和数据库" class="headerlink" title="后端和数据库"></a>后端和数据库</h1><p>由于我本人对后端内容不是太熟悉，所以大体搭建了一个数据库，意思一下。</p><p>这里我选用的Spring boot搭建后端，mySql作为数据库。如果是前端搭建数据库，还是推荐更适合前端的Nodejs和MongoDB。</p><p>首先我们需要一个数据表：已经添加的植物表。那么它应该就具有：名称，添加时间，上次浇水时间，浇水间隔时间这些属性。</p><h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>Taro对小程序的网络请求API进行了Promise封装，具体可以参考官方文档：</p><p><a href="https://nervjs.github.io/taro/docs/apis/network/request/request/nervjs.github.io" target="_blank" rel="noopener">https://nervjs.github.io/taro/docs/apis/network/request/request/nervjs.github.io</a></p><p>这里我们再次将Taro提供的api进行封装，封装的原因是因为如果我们想要引入其他的网络请求库，就不用再去页面中用到的地方一个一个的更改api，直接修改封装文件中的api就可以了。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Taro <span class="hljs-keyword">from</span> <span class="hljs-string">"@tarojs/taro"</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">url = <span class="hljs-string">""</span>, params = &#123;&#125;, type = <span class="hljs-string">"GET"</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> promise;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (type.toUpperCase() === <span class="hljs-string">"GET"</span>) &#123;      <span class="hljs-keyword">let</span> paramsStr = <span class="hljs-string">""</span>;      <span class="hljs-built_in">Object</span>.keys(params).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;        paramsStr += key + <span class="hljs-string">"="</span> + params[key] + <span class="hljs-string">"&amp;"</span>;      &#125;);      <span class="hljs-keyword">if</span> (paramsStr) &#123;        paramsStr = paramsStr.substr(<span class="hljs-number">0</span>, paramsStr.lastIndexOf(<span class="hljs-string">"&amp;"</span>));      &#125;      url += <span class="hljs-string">"?"</span> + paramsStr;      <span class="hljs-comment">//发起GET请求</span>      promise = Taro.request(&#123;        url: url,        header: &#123;<span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>&#125;,      &#125;);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.toUpperCase() === <span class="hljs-string">"POST"</span>) &#123;      promise = Taro.request(&#123;        method: <span class="hljs-string">"POST"</span>,        url: url,        data: params,        header: &#123;<span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>&#125;      &#125;);    &#125;    promise.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;      resolve(response.data);    &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;      reject(error);    &#125;);  &#125;);&#125;</code></pre><p>到这一步，我们已经完成了数据库和后端的配置，剩下的就是需要在前端进行调用这些接口。</p><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>虽然组件之间的参数传递并不复杂，但是我这里为了方便，还是使用redux和redux-thunk。</p><p>使用 Redux | Taro 文档nervjs.github.io</p><p><a href="https://github.com/reduxjs/redux-thunkgithub.com" target="_blank" rel="noopener">https://github.com/reduxjs/redux-thunkgithub.com</a></p><p>由于我对redux-thunk不是很熟，所以又去翻找了一下资料，在redux和后端数据这里花费了不少时间。</p><p><img src="/image/v2-fc800fd70f2bfc6b700e6b4b09aa0d31_b.gif" srcset="/img/loading.gif" alt="img"></p><p>从上面的图可以看到，这里已经可以添加花了，但是由于每次点击添加不仅要向后端发送请求将点击的花添加到数据库，并且还需要将花的列表进行重新请求。</p><p>剩下的就是实现浇花功能了，该功能的实现必须也要后端配合实现，实现过程就是当你<strong>点击浇水的时候，将数据库中对应的花的上一次浇水时间改成当前时间。</strong>这个的实现几乎全是由后端实现，跟前端没啥关系，最多只是调用一下接口将点击浇水的花的ID传送过去。</p><p>最后增加删除枯萎的花的功能，也是需要后端提供接口。</p><p><img src="/image/v2-de5dfd4f7d2d85936c7094d65e37ec6c_b.gif" srcset="/img/loading.gif" alt="img"></p><p>到这里基本上小程序就已经开发完成了，但是不知道是因为我的后端传输数据很慢还是其它的原因，可以看到点击删除后会卡一会。</p><p>之后我调整了一下代码格式，因为Taro创建工程的时候会自动集成ESLint代码检测，再次尝试添加删除植物，发现这次没有上面那么卡顿了，所以也不知道之前是哪儿出现了问题。</p><p><img src="/image/v2-dd399d409804cc37c9b76e53c745a946_b.gif" srcset="/img/loading.gif" alt="img"></p><p>可以看到，还是比较流畅</p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="/image/v2-b679caf5c262af8a528ebeac5a38d42f_720w.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个项目的难点在于redux之间的数据传递，还有时间的换算，除此之外也没有什么难点了，虽然看似简单的一个小程序，但是可以很好的理解redux。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taro</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：充满玄学的this指向，真的有点难</title>
    <link href="/2020/05/07/JavaScript%EF%BC%9A%E5%85%85%E6%BB%A1%E7%8E%84%E5%AD%A6%E7%9A%84this%E6%8C%87%E5%90%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%9C%89%E7%82%B9%E9%9A%BE/"/>
    <url>/2020/05/07/JavaScript%EF%BC%9A%E5%85%85%E6%BB%A1%E7%8E%84%E5%AD%A6%E7%9A%84this%E6%8C%87%E5%90%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%9C%89%E7%82%B9%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript中的this可能是当年设计的时候存在着设计缺陷，在ES6中能使用<code>()=&gt;</code>这个高端的箭头函数就尽量使用箭头函数，箭头函数在其他语言中还有个高大上的名字<code>Lambda</code>表达式。</p><p><strong>PS：</strong><code>nodejs</code>环境中没有<code>window</code>对象</p><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>对于this的指向，我的理解就是记住一句话，<strong>如果没有使用apply和call还有箭头函数的情况下，this指向最后一次调用它的对象，如果最后一次调用它的是函数，则在严格模式指向<code>undefined</code>非严格模式下指向全局变量<code>window</code></strong>。</p><p>下面的例子全部为非严格模式</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span></code></pre><p>上面的例子应该很清晰，因为最后一次调用<code>b</code>方法的是<code>obj</code>这个对象，而对象<code>obj</code>里面a的值为2，所以这个例子会输出2。</p><p>那么我们加大一下难度看下面的例子</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-keyword">var</span> t = obj.b;<span class="hljs-built_in">console</span>.log(t());<span class="hljs-built_in">console</span>.log(obj.b());<span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-built_in">console</span>.log(t === obj.b);</code></pre><p>这个时候我们新加入一个变量<code>t</code>，将<code>b</code>方法赋值给<code>t</code>，大家思考一下这个时候函数<code>t</code>会输出什么。</p><p>神奇的事情发生了</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(t()); <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(t === obj.b); <span class="hljs-comment">//true</span></code></pre><p>函数<code>t</code>输出的结果是1。</p><p>因为这次调用方法的是函数<code>t</code>而他的对象为<code>window</code>，因为对象<code>window</code>上的<code>a</code>值为1，故<code>t</code>的最后输出结果为1。</p><p>下面这个例子也同样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;    <span class="hljs-built_in">console</span>.log(fun());  &#125;&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>因为调用<code>fun</code>方法的是方法<code>b</code>，这时最后一次调用<code>fun</code>的不为对象，则this指向全局变量<code>window</code></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul><li>箭头函数会捕获其所在上下文的 <code>this</code> 值，作为自己的 <code>this</code> 值</li><li>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 <code>undefined</code>。</li></ul><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>在<code>ES5</code>语法中使用this有时候会很难以预测this的指向，从而产生bug，这个问题到了现在框架时代大量通过类进行封装时变得尤为明显。如果学习过react，就会发现将父组件的函数传递给子组件使用时，this指向总是个头疼的问题。</p><p>虽然使用call,apply,bind可以解决这部分痛点，但是需要额外的代码，不仅增大了工作量，而且增加了维护成本。</p><h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//1</span></code></pre><p>因为b是通过箭头函数进行声明，则它的this就指向了<code>obj</code>的this，而<code>obj</code>的this就是全局变量<code>window</code></p><h2 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><p>因为箭头函数会找上下文的this，所以这里找到的上文就是方法<code>b</code>的this，即为对象<code>obj</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>箭头函数是没有this的，这个时候方法<code>fun</code>就逐层寻找this，最终找到的是对象<code>obj</code>的this</p><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h1><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><ol><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p></li><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p></li><li><p>bind除了返回是函数以外，它的参数和call一样。</p></li></ol><h2 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>this是不能改变的，所以对箭头函数使用call,apply,bind是没有效果的</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun.call(a));  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;<span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">3</span>,&#125;;obj.b.call(obj1); <span class="hljs-comment">//3</span></code></pre><p>箭头函数的this虽然不能被改变，但是可以改变它上下文的this。</p><h1 id="一大堆题"><a href="#一大堆题" class="headerlink" title="一大堆题"></a>一大堆题</h1><p>既然上面都讲了那么多，那么我们来看一下下面的题：</p><p>不知道是哪个大神想的题目，反正就是不让人好过。┓( ´∀` )┏</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person = &#123;  age: <span class="hljs-number">20</span>,  getAge() &#123;    <span class="hljs-keyword">var</span> age = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; <span class="hljs-comment">//20</span>  &#125;&#125;;<span class="hljs-built_in">console</span>.log(age, age * <span class="hljs-number">2</span>); <span class="hljs-comment">//10 20</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-keyword">var</span> b = person.getAge;<span class="hljs-built_in">console</span>.log(b()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge.bind(person))()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((person.getAge, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((person.getAge = person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call(person)); <span class="hljs-comment">//20</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">40</span>;  <span class="hljs-built_in">console</span>.log(person.getAge());&#125;getAge2(); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//node环境和浏览器环境不一样，因为浏览器环境中有window对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">50</span>;  <span class="hljs-keyword">this</span>.getAge4 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//50</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge3().getAge4());<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge4</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">60</span>;  <span class="hljs-keyword">this</span>.getAge5 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//60</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge4().getAge5()); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-keyword">var</span> age2 = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person2 = &#123;  age2: <span class="hljs-number">20</span>,  getAge2: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> age2 = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age2;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(person2.getAge2.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person2.getAge2.call(person2)); <span class="hljs-comment">//10</span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看了很多篇文章，对那些文章进行了总结，我也不能说我百分百懂了this，如果有错误的地方，欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>this指针</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老生常谈的this</title>
    <link href="/2020/05/07/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84this/"/>
    <url>/2020/05/07/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84this/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript中的this可能是当年设计的时候存在着设计缺陷，在ES6中能使用<code>()=&gt;</code>这个高端的箭头函数就尽量使用箭头函数，箭头函数在其他语言中还有个高大上的名字<code>Lambda</code>表达式。</p><p><strong>PS：</strong><code>nodejs</code>环境中没有<code>window</code>对象</p><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>对于this的指向，我的理解就是记住一句话，<strong>如果没有使用apply和call还有箭头函数的情况下，this指向最后一次调用它的对象，如果最后一次调用它的是函数，则在严格模式指向<code>undefined</code>非严格模式下指向全局变量<code>window</code></strong>。</p><p>下面的例子全部为非严格模式</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span></code></pre><p>上面的例子应该很清晰，因为最后一次调用<code>b</code>方法的是<code>obj</code>这个对象，而对象<code>obj</code>里面a的值为2，所以这个例子会输出2。</p><p>那么我们加大一下难度看下面的例子</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-keyword">var</span> t = obj.b;<span class="hljs-built_in">console</span>.log(t());<span class="hljs-built_in">console</span>.log(obj.b());<span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-built_in">console</span>.log(t === obj.b);</code></pre><p>这个时候我们新加入一个变量<code>t</code>，将<code>b</code>方法赋值给<code>t</code>，大家思考一下这个时候函数<code>t</code>会输出什么。</p><p>神奇的事情发生了</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(t()); <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(t === obj.b); <span class="hljs-comment">//true</span></code></pre><p>函数<code>t</code>输出的结果是1。</p><p>因为这次调用方法的是函数<code>t</code>而他的对象为<code>window</code>，因为对象<code>window</code>上的<code>a</code>值为1，故<code>t</code>的最后输出结果为1。</p><p>下面这个例子也同样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;    <span class="hljs-built_in">console</span>.log(fun());  &#125;&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>因为调用<code>fun</code>方法的是方法<code>b</code>，这时最后一次调用<code>fun</code>的不为对象，则this指向全局变量<code>window</code></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul><li>箭头函数会捕获其所在上下文的 <code>this</code> 值，作为自己的 <code>this</code> 值</li><li>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 <code>undefined</code>。</li></ul><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>在<code>ES5</code>语法中使用this有时候会很难以预测this的指向，从而产生bug，这个问题到了现在框架时代大量通过类进行封装时变得尤为明显。如果学习过react，就会发现将父组件的函数传递给子组件使用时，this指向总是个头疼的问题。</p><p>虽然使用call,apply,bind可以解决这部分痛点，但是需要额外的代码，不仅增大了工作量，而且增加了维护成本。</p><h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//1</span></code></pre><p>因为b是通过箭头函数进行声明，则它的this就指向了<code>obj</code>的this，而<code>obj</code>的this就是全局变量<code>window</code></p><h2 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><p>因为箭头函数会找上下文的this，所以这里找到的上文就是方法<code>b</code>的this，即为对象<code>obj</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>箭头函数是没有this的，这个时候方法<code>fun</code>就逐层寻找this，最终找到的是对象<code>obj</code>的this</p><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h1><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><ol><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p></li><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p></li><li><p>bind除了返回是函数以外，它的参数和call一样。</p></li></ol><h2 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>this是不能改变的，所以对箭头函数使用call,apply,bind是没有效果的</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun.call(a));  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;<span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">3</span>,&#125;;obj.b.call(obj1); <span class="hljs-comment">//3</span></code></pre><p>箭头函数的this虽然不能被改变，但是可以改变它上下文的this。</p><h1 id="一大堆题"><a href="#一大堆题" class="headerlink" title="一大堆题"></a>一大堆题</h1><p>既然上面都讲了那么多，那么我们来看一下下面的题：</p><p>不知道是哪个大神想的题目，反正就是不让人好过。┓( ´∀` )┏</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person = &#123;  age: <span class="hljs-number">20</span>,  getAge() &#123;    <span class="hljs-keyword">var</span> age = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; <span class="hljs-comment">//20</span>  &#125;&#125;;<span class="hljs-built_in">console</span>.log(age, age * <span class="hljs-number">2</span>); <span class="hljs-comment">//10 20</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-keyword">var</span> b = person.getAge;<span class="hljs-built_in">console</span>.log(b()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge.bind(person))()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((person.getAge, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((person.getAge = person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call(person)); <span class="hljs-comment">//20</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">40</span>;  <span class="hljs-built_in">console</span>.log(person.getAge());&#125;getAge2(); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//node环境和浏览器环境不一样，因为浏览器环境中有window对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">50</span>;  <span class="hljs-keyword">this</span>.getAge4 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//50</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge3().getAge4());<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge4</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">60</span>;  <span class="hljs-keyword">this</span>.getAge5 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//60</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge4().getAge5()); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-keyword">var</span> age2 = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person2 = &#123;  age2: <span class="hljs-number">20</span>,  getAge2: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> age2 = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age2;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(person2.getAge2.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person2.getAge2.call(person2)); <span class="hljs-comment">//10</span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看了很多篇文章，对那些文章进行了总结，我也不能说我百分百懂了this，如果有错误的地方，欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>this指针</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发/心血来潮：做一个网页游戏，飞机大战</title>
    <link href="/2020/05/04/web%E5%BC%80%E5%8F%91/%E5%BF%83%E8%A1%80%E6%9D%A5%E6%BD%AE%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%EF%BC%8C%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"/>
    <url>/2020/05/04/web%E5%BC%80%E5%8F%91/%E5%BF%83%E8%A1%80%E6%9D%A5%E6%BD%AE%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%EF%BC%8C%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>体验地址：<a href="https://qflyb.github.io/airplanewar/" target="_blank" rel="noopener">https://qflyb.github.io/airplanewar/</a></p><p>飞机大战小游戏主体还是比较简单的，但是看似简单的外壳下面有着很多细节。如果要将细节做到极致，那需要花大量的功夫，我这里只是大体实现了飞机大战。</p><h2 id="体验地址"><a href="#体验地址" class="headerlink" title="体验地址"></a><strong>体验地址</strong></h2><p>整个游戏是使用cocos实现，先看一下游戏画面截图：</p><p><img src="/image/v2-925afa52377468925f88c892cccf7a54_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>这篇文章不准备针对所有代码去讲解，只挑选制作过程中印象比较深的踩坑之处，代码都是用的TypeScript，TypeScript在JavaScript的基础上面加了很多限制，那么为什么还要使用TypeScript？因为TypeScript的类，更像Java，C#这种语言，用着更顺手一些。</p><h2 id="飞机的移动"><a href="#飞机的移动" class="headerlink" title="飞机的移动"></a><strong>飞机的移动</strong></h2><h2 id="玩家飞机"><a href="#玩家飞机" class="headerlink" title="玩家飞机"></a><strong>玩家飞机</strong></h2><p>玩家飞机操控根据上图也能看出来，是依据触摸屏幕的点进行判断，cocos里面提供了一个<code>cc.Node.EventType.TOUCH_MOVE</code>方法，可以在监听玩家手指在屏幕上面滑动。同时还提供了<code>getPreviousLocation</code>可以获取到上一帧手指所在的位置，而<code>getLocation</code>可以获取到当前帧手指所在的位置，然后通过两帧位置的差值，再将飞机的位置减去这个差值，就可以实现飞机的移动。</p><pre><code class="hljs cs"><span class="hljs-comment">// 控制</span><span class="hljs-keyword">this</span>.node.<span class="hljs-keyword">on</span>(  cc.Node.EventType.TOUCH_MOVE,  function (<span class="hljs-keyword">event</span>) &#123;    <span class="hljs-keyword">if</span> (GameMode.gameOver) &#123;      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">this</span>.player.x -= <span class="hljs-keyword">event</span>.getPreviousLocation().x - <span class="hljs-keyword">event</span>.getLocation().x;    <span class="hljs-keyword">this</span>.player.y -= <span class="hljs-keyword">event</span>.getPreviousLocation().y - <span class="hljs-keyword">event</span>.getLocation().y;  &#125;,  <span class="hljs-keyword">this</span>);</code></pre><h2 id="敌方飞机"><a href="#敌方飞机" class="headerlink" title="敌方飞机"></a><strong>敌方飞机</strong></h2><p>敌方飞机的生成是使用一个随机数，让它在屏幕外面随机生成，同时不断的改变飞机的y轴值就可以实现一直向下移动。</p><pre><code class="hljs typescript">creatEnemy(enemyCount: <span class="hljs-built_in">number</span>, enemyList: <span class="hljs-built_in">Array</span>&lt;cc.Node&gt;, hp: <span class="hljs-built_in">number</span>) &#123;  <span class="hljs-keyword">let</span> enemy = enemyList[enemyCount];  <span class="hljs-keyword">let</span> enemyS: Enemy = enemy.getComponent(<span class="hljs-string">"Enemy"</span>);  enemyS.death = <span class="hljs-literal">false</span>;  enemyS.hp = hp;  enemy.setPosition(    <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">570</span> - <span class="hljs-number">285</span>), <span class="hljs-comment">// 位置随机</span>    <span class="hljs-keyword">this</span>.enemyPos.getPosition().y  );  enemy.active = <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a><strong>动画系统</strong></h2><p>飞机的爆炸都是通过cocos的动画系统来实现，在飞机判断死亡时，就开始播放动画，等到动画结束，就将敌方飞机的<strong>渲染关闭</strong>。这里使用的是关闭渲染而不是进行销毁对象，因为对象的动态创建是非常消耗性能的，所以我选择在游戏加载的时候就将敌方的几十架飞机全部创建，然后要使用时对它们进行初始化。</p><pre><code class="hljs reasonml">init<span class="hljs-constructor">Enemy(<span class="hljs-params">enemyList</span>: Array&lt;<span class="hljs-params">cc</span>.Node&gt;, <span class="hljs-params">enemy</span>: <span class="hljs-params">cc</span>.Node, <span class="hljs-params">count</span>: <span class="hljs-params">number</span>)</span> &#123;  <span class="hljs-comment">//生成敌人</span>  for (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;    <span class="hljs-keyword">let</span> ene = cc.instantiate(enemy);    this.node.add<span class="hljs-constructor">Child(<span class="hljs-params">ene</span>)</span>;    ene.active = <span class="hljs-literal">false</span>;    enemyList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = ene;  &#125;&#125;</code></pre><h2 id="击中目标"><a href="#击中目标" class="headerlink" title="击中目标"></a><strong>击中目标</strong></h2><p>cocos自带了碰撞功能，只需要在初始化时开启碰撞，并且在组件上面添加了碰撞盒子，就可以通过<code>onCollisionEnter</code>方法监听到碰撞。</p><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">manager</span> = cc.director.getCollisionManager();manager.<span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>; // 开启碰撞</code></pre><p><img src="/image/v2-52a8b33cdc7502577843ab7fa6a6b6ab_720w.png" srcset="/img/loading.gif" alt="img"></p><h2 id="细节部分"><a href="#细节部分" class="headerlink" title="细节部分"></a><strong>细节部分</strong></h2><h2 id="重新开始"><a href="#重新开始" class="headerlink" title="重新开始"></a><strong>重新开始</strong></h2><p>使用cocos提供的方法<code>cc.director.loadScene(&quot;Game&quot;);</code>就可以重置场景，但是这里我遇到了一个坑，不管是通过该方法提供的回调函数，还是直接写在下面，重置时都无法再次拿到当前脚本上的对象。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>生成不同等级的敌方飞机这是一个非常需要考虑细节的地方。制作游戏的时候你需要考虑再加入一种类型的飞机，那么需要怎么加才最方便，而不是需要加一种敌方飞机，就又重新全部写一次代码。当然，因为偷懒，所以这部分我基本没有怎么考虑了。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Cocos Creator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-element-admin npm install报错</title>
    <link href="/2020/05/04/vue-element-admin%20npm%20install%E6%8A%A5%E9%94%99/"/>
    <url>/2020/05/04/vue-element-admin%20npm%20install%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到<a href="http://panjiachen.github.io/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a>后台模板不错，于是准备研究一下，结果进去就吃了个闭门羹，npm install各种报错。</p></blockquote><h1 id="我遇到的错误"><a href="#我遇到的错误" class="headerlink" title="我遇到的错误"></a>我遇到的错误</h1><p><code>enoent undefined ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.git</code></p><p><img src="/image/v2-daea995e8644bf9c9e37fc65e754b916_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs shell">npm ERR! code ENOENTnpm ERR! syscall spawn gitnpm ERR! path gitnpm ERR! errno -4058npm ERR! enoent Error while executing:npm ERR! enoent undefined ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.gitnpm ERR! enoentnpm ERR! enoentnpm ERR! enoent spawn git ENOENTnpm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoent</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>需要安装git，并且配置环境变量<code>C:\Program Files\Git\bin</code>（具体根据自身电脑上的git安装目录确定）。</p><h1 id="官方提到的错误"><a href="#官方提到的错误" class="headerlink" title="官方提到的错误"></a>官方提到的错误</h1><p><img src="/image/v2-7964f6c2416a7cccd1fc956b971fbe52_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs shell">npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-sass@4.14.0 postinstall: `node scripts/build.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-sass@4.14.0 postinstall script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2020-05-04T08_05_47_402Z-debug.log</code></pre><ul><li><p>官方提出的错误，node-sass经常性报错，经尝试使用淘宝源可以成功安装</p></li><li><p>之前在自己的项目中使用node-sass的时候使用yarn也能成功进行安装</p></li></ul><p>永久更换淘宝源</p><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unity3D复刻保卫萝卜</title>
    <link href="/2020/05/04/unity3D%E5%A4%8D%E5%88%BB%E4%BF%9D%E5%8D%AB%E8%90%9D%E5%8D%9C/"/>
    <url>/2020/05/04/unity3D%E5%A4%8D%E5%88%BB%E4%BF%9D%E5%8D%AB%E8%90%9D%E5%8D%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上次那个快乐鸟-html版似乎反响还不错，看来大家对游戏制作还蛮感兴趣的…那么这次我要搬出我前年用unity3D复刻的保卫萝卜。</p><p>因为年份太过于久远了，所以具体代码就不进行分析了，主要是我忘了（狗头），研究前端后就再也没有碰过unity3D。</p></blockquote><p>视频在这里：</p><p><a href="https://www.bilibili.com/video/BV1HW411d7DMwww.bilibili.com" target="_blank" rel="noopener">unity3D复刻保卫萝卜</a></p><p>当时参照了siki学院的思路，然后自己独立进行一些加工将它完成了，如果有兴趣的朋友可以直接在siki学院上面搜索一下…</p><p>大概说一下自己当时独立加工的点的实现方式：</p><p><img src="/image/v2-678267ad3758d59e1021cd1fd19056b3_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="地图编辑器"><a href="#地图编辑器" class="headerlink" title="地图编辑器"></a>地图编辑器</h1><p>将屏幕分为 8*12 个格子，判断鼠标点击时最近的格子，通过视频上面也可以看出即使是没有点在格子的正中部分，依然可以将那一格进行点亮。当地图编辑完毕时点击保存，就将该地图信息，记录在CSV中，通过CSV进行导入。</p><p>CSV有个最大的好处就是可以通过Excel打开，如果是用json存取数据，就没有CSV展现的数据那么清晰。</p><h1 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h1><p>通过计算出每个格子中心点的坐标，让怪物沿着已经设定好的路径点通过 Translat 进行移动，如果当怪物离某个路径点的距离小于某值，则让它朝着下一个点进行移动，如果已经达到终点，则将怪物的渲染关闭。搜寻怪物逻辑即将所有怪物放在一个数组中，先遍历这个数组，然后判断怪物是否在塔的攻击范围中，如果在塔的攻击范围中，则将炮塔的目标设置为当前怪物。</p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>unity生成和销毁实例跟前端生成Dom一样，是十分消耗性能的，所以这就涉及到实例的复用。意思就是当怪物“死亡”时，其实不进行销毁，而仅仅是将怪物的渲染关闭，如果下次需要使用，则对这些事例重新进行初始化。就跟前端将<code>display</code>设置为<code>none</code>一样。</p><p>整个项目的实现难度并不难，但是里面包含的点非常多，包括UI，动画，对象池，数据的本地存取等，很适合作为初学者项目。</p>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
      <tag>unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习C++时遇到的与其它编程语言中的不同与难点</title>
    <link href="/2020/05/04/%E5%AD%A6%E4%B9%A0C++%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8E%E5%85%B6%E5%AE%83%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B8%8E%E9%9A%BE%E7%82%B9/"/>
    <url>/2020/05/04/%E5%AD%A6%E4%B9%A0C++%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8E%E5%85%B6%E5%AE%83%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B8%8E%E9%9A%BE%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>C++是目前公认的比较难学的一门编程语言，因为其中的知识点过于复杂和繁琐，连谷歌设计Golang的时候，都将目标设定为：“不要像C++。”</p><p>那么既然这么难学，为什么还要学它呢，是因为它在某些领域拥有非常大的优势：</p><ol><li>游戏服务端开发</li><li>游戏开发</li><li>数字图像处理</li><li>科学计算</li><li>网络软件</li><li>分布式应用</li><li>操作系统</li><li>嵌入式系统</li><li>教育与科研</li><li>…</li></ol><p>尤其是现在<strong>虚幻引擎</strong>在世界范围内逐渐升温，<strong>Cocos2d-x</strong>也需要使用C++进行开发。所以C++的应用范围非常的广泛，其实编程语言没有什么孰好孰坏之分，只有合适与不合适的区别。</p><p><strong>本文的运行环境为32位操作系统，C++开发默认运行环境即为32位操作系统，下面文章中所提到的占用内存空间统统都指的32位运行环境。</strong></p><h1 id="1-指针（非常重要）"><a href="#1-指针（非常重要）" class="headerlink" title="1. 指针（非常重要）"></a><strong>1. 指针（非常重要）</strong></h1><p>目前学习C++时遇到的和其它编程语言最大的不同点，就是指针。指针可能单独作为一部分来看并不难，<strong>难点是后面的值传递，地址传递，引用传递，深拷贝，浅拷贝这些知识点使用到指针的时候，就感觉突然从<code>1+1=2</code>的题目上升到微积分。</strong></p><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><p><strong>指针变量定义</strong>语法： <code>数据类型 * 变量名；</code></p><ul><li><strong>普通变量存放的是数据,指针变量存放的是地址</strong></li><li><strong>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</strong></li></ul><h2 id="1-1-指针所占内存"><a href="#1-1-指针所占内存" class="headerlink" title="1.1 指针所占内存"></a><strong>1.1 指针所占内存</strong></h2><p>在不同的系统下指针所占的内存不同，一般情况下<strong>所有指针类型在32位操作系统下是4个字节，在64位系统下使8个字节。</strong></p><h2 id="1-2-空指针和野指针"><a href="#1-2-空指针和野指针" class="headerlink" title="1.2 空指针和野指针"></a><strong>1.2 空指针和野指针</strong></h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为00000000的空间</span>    <span class="hljs-keyword">int</span> * p = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">//访问空指针报错 </span>    <span class="hljs-comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>野指针</strong>：指针变量指向非法的内存空间即指向了系统占用内存空间。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span>    <span class="hljs-keyword">int</span> * p = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x1100</span>;    <span class="hljs-comment">//访问野指针报错 </span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>空指针和野指针都不是我们申请的空间，因此不要访问。</strong></p><h2 id="1-3-const修饰指针"><a href="#1-3-const修饰指针" class="headerlink" title="1.3 const修饰指针"></a><strong>1.3 const修饰指针</strong></h2><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    <span class="hljs-comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p1 = &amp;a;    p1 = &amp;b; <span class="hljs-comment">//正确</span>    <span class="hljs-comment">//*p1 = 100;  报错</span>    <span class="hljs-comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span>    <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p2 = &amp;a;    <span class="hljs-comment">//p2 = &amp;b; //错误</span>    *p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span>    <span class="hljs-comment">//const既修饰指针又修饰常量</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = &amp;a;    <span class="hljs-comment">//p3 = &amp;b; //错误</span>    <span class="hljs-comment">//*p3 = 100; //错误</span>    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="1-4-指针和数组"><a href="#1-4-指针和数组" class="headerlink" title="1.4 指针和数组"></a><strong>1.4 指针和数组</strong></h2><p>因为数组在内存上面开辟的是一块连续的运行空间，而数组的变量也储存的数组所在内存的地址，所以我们可以通过指针来遍历数组。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">int</span> *p = arr;  <span class="hljs-comment">//指向数组的指针</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"第一个元素： "</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-comment">//利用指针遍历数组</span>        <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;        p++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>又因为数组的变量名记录的是它的地址，那么问题又来了。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;        arr[i] = <span class="hljs-number">10</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;    change(arr);<span class="hljs-comment">//调用改变函数</span>    <span class="hljs-keyword">int</span> *p = arr;  <span class="hljs-comment">//指向数组的指针</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"第一个元素： "</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-comment">//利用指针遍历数组</span>        <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;        p++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果我们在函数change中改变了arr的值，那么在main函数中遍历会输出什么结果？</p><pre><code class="hljs cpp">第一个元素： <span class="hljs-number">10</span>指针访问第一个元素： <span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span></code></pre><p>可以看到，在change函数中改变了arr中的值，main函数中的arr也发生了改变。</p><h2 id="1-5-指针和函数-非常重要"><a href="#1-5-指针和函数-非常重要" class="headerlink" title="1.5 指针和函数(非常重要)"></a><strong>1.5 指针和函数(非常重要)</strong></h2><p>这个在其它编程语言中使用时出现的情况也非常的多，虽然其它编程语言中不操作指针，但是涉及到值传递和引用传递，原理上和C++的指针一样。</p><p>在一般情况下，形参是不能修饰实参的。例如：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;    a = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"change函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    change(a);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"main函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>那么这个函数里的a和函数外的a输出分别是多少？</p><pre><code class="hljs cpp"><span class="hljs-comment">//change函数里的a值为1000</span><span class="hljs-comment">//main函数里的a值为100</span></code></pre><p>可以看到，即便在change函数里面修改了a的值，但main函数中的a值不会发生改变。</p><p>那么下面的例子change函数里的a和main函数里的a输出分别又是多少？</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a)</span> </span>&#123;    *a = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"change函数里的*a值为"</span> &lt;&lt; *a &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    change(&amp;a);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"main函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>可以看到上面只将主函数中的变量a的地址传入到change函数中，那么运行后主函数中a的值又是多少？</p><pre><code class="hljs cpp">change函数里的*a值为<span class="hljs-number">1000</span>main函数里的a值为<span class="hljs-number">1000</span></code></pre><p>可以看到main函数里的a值被改变了。</p><p><strong>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递。</strong></p><h2 id="1-6-指针总结"><a href="#1-6-指针总结" class="headerlink" title="1.6 指针总结"></a><strong>1.6 指针总结</strong></h2><p>无论在哪门编程语言中，指针的指向都是非常重要必须要进行理解的，建议多看看相关类型的资料，因为对于初学者而言，指针并不是那么容易理解，必须在经过大量的练习后，才能融会贯通。</p><h1 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a><strong>2. 引用</strong></h1><p>通过引用可以给变量起别名。</p><p>语法：<code>数据类型 &amp;别名 = 原名</code></p><h2 id="2-1-注意事项"><a href="#2-1-注意事项" class="headerlink" title="2.1 注意事项"></a><strong>2.1 注意事项</strong></h2><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><h2 id="2-2-引用做函数参数"><a href="#2-2-引用做函数参数" class="headerlink" title="2.2 引用做函数参数"></a><strong>2.2 引用做函数参数</strong></h2><p>上文也提到过参数有3种传递方式：</p><ol><li>值传递</li><li>地址传递</li><li>引用传递</li></ol><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><pre><code class="hljs cpp"><span class="hljs-comment">//1. 值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-comment">//2. 地址传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-comment">//3. 引用传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    mySwap01(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap02(&amp;a, &amp;b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap03(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</strong></p><h2 id="2-3-引用做函数返回值"><a href="#2-3-引用做函数返回值" class="headerlink" title="2.3 引用做函数返回值"></a><strong>2.3 引用做函数返回值</strong></h2><p>注意：<strong>不要返回局部变量引用</strong>，因为局部变量引用会在函数结束调用后进行销毁。</p><p>用法：函数调用作为左值</p><h2 id="2-4-引用的本质"><a href="#2-4-引用的本质" class="headerlink" title="2.4 引用的本质"></a><strong>2.4 引用的本质</strong></h2><pre><code class="hljs cpp"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; ref)</span></span>&#123;    ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span>    <span class="hljs-keyword">int</span>&amp; ref = a;     ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ref:"</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;        func(a);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>引用的本质在c++内部实现是一个指针常量.</strong></p><h2 id="2-5-常量引用"><a href="#2-5-常量引用" class="headerlink" title="2.5 常量引用"></a><strong>2.5 常量引用</strong></h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加<strong>const修饰形参</strong>，防止形参改变实参，例如：<code>const int&amp; ref = 10;</code></p><h1 id="3-函数声明"><a href="#3-函数声明" class="headerlink" title="3. 函数声明"></a><strong>3. 函数声明</strong></h1><h2 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a><strong>3.1 函数默认参数</strong></h2><p>C++中，函数的形参列表中的形参可以拥有默认值。</p><p>语法：<code>返回值类型 函数名 （参数= 默认值）{}</code></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ret = "</span> &lt;&lt; func(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ret = "</span> &lt;&lt; func(<span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-2-占位参数"><a href="#3-2-占位参数" class="headerlink" title="3.2 占位参数"></a><strong>3.2 占位参数</strong></h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p><p>主要用在类的多态。</p><pre><code class="hljs cpp"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>)</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"this is func"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span>    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-3-函数的重载"><a href="#3-3-函数的重载" class="headerlink" title="3.3 函数的重载"></a><strong>3.3 函数的重载</strong></h2><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (int a) 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (double a)的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">double</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (int a ,double b) 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a ,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (double a ,int b)的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><span class="hljs-comment">//int func(double a, int b)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//  cout &lt;&lt; "func (double a ,int b)的调用！" &lt;&lt; endl;</span><span class="hljs-comment">//&#125;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func();    func(<span class="hljs-number">10</span>);    func(<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);        system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-4-注意"><a href="#3-4-注意" class="headerlink" title="3.4 注意"></a><strong>3.4 注意</strong></h2><p>尽量不要出现二义性：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func2(int a, int b = 10) 调用"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func2(int a) 调用"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p>上面这个函数重载就具有二义性，编译器不知道应该调用哪个函数。</p><h1 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4. 类和对象"></a><strong>4. 类和对象</strong></h1><p>面向对象的三大特性：</p><ol><li>封装</li><li>继承</li><li>多态</li></ol><h2 id="4-1-访问权限"><a href="#4-1-访问权限" class="headerlink" title="4.1 访问权限"></a><strong>4.1 访问权限</strong></h2><ol><li><code>public</code> 公共权限 类内可以访问 类外可以访问</li><li><code>protected</code> 保护权限 类内可以访问 类外不可以访问</li><li><code>private</code> 私有权限 类内可以访问 类外不可以访问</li></ol><h2 id="4-2-struct和class的区别"><a href="#4-2-struct和class的区别" class="headerlink" title="4.2 struct和class的区别"></a><strong>4.2 struct和class的区别</strong></h2><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><h2 id="4-3-构造函数和析构函数"><a href="#4-3-构造函数和析构函数" class="headerlink" title="4.3 构造函数和析构函数"></a><strong>4.3 构造函数和析构函数</strong></h2><p>在其它高级编程语言中，构造函数经常使用，析构函数很少会用到，因为其它高级编程语言中自带垃圾回收机制（GC），而C++中则没有自动垃圾回收机制，所以需要通过析构函数进行销毁对象、变量。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><h3 id="4-3-1-析构函数"><a href="#4-3-1-析构函数" class="headerlink" title="4.3.1 析构函数"></a><strong>4.3.1 析构函数</strong></h3><p><strong>析构函数语法：</strong> <code>~类名(){}</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><h3 id="4-3-2-构造函数"><a href="#4-3-2-构造函数" class="headerlink" title="4.3.2 构造函数"></a><strong>4.3.2 构造函数</strong></h3><p>在C++中自带普通构造函数和拷贝构造函数。</p><p>拷贝构造函数调用：</p><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><h3 id="4-3-3-总结"><a href="#4-3-3-总结" class="headerlink" title="4.3.3 总结"></a><strong>4.3.3 总结</strong></h3><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其它构造函数</li></ul><h2 id="4-4-深拷贝和浅拷贝（重点）"><a href="#4-4-深拷贝和浅拷贝（重点）" class="headerlink" title="4.4 深拷贝和浅拷贝（重点）"></a><strong>4.4 深拷贝和浅拷贝（重点）</strong></h2><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p><h2 id="4-5-初始化列表"><a href="#4-5-初始化列表" class="headerlink" title="4.5 初始化列表"></a><strong>4.5 初始化列表</strong></h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">////传统方式初始化</span>    <span class="hljs-comment">//Person(int a, int b, int c) &#123;</span>    <span class="hljs-comment">//  m_A = a;</span>    <span class="hljs-comment">//  m_B = b;</span>    <span class="hljs-comment">//  m_C = c;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-comment">//初始化列表方式初始化</span>    Person(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mA:"</span> &lt;&lt; m_A &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mB:"</span> &lt;&lt; m_B &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mC:"</span> &lt;&lt; m_C &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">int</span> m_B;    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;    p.PrintPerson();    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p><h2 id="4-6-常函数和常对象"><a href="#4-6-常函数和常对象" class="headerlink" title="4.6 常函数和常对象"></a><strong>4.6 常函数和常对象</strong></h2><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;        m_A = <span class="hljs-number">0</span>;        m_B = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span>    <span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//const Type* const pointer;</span>        <span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span>        <span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span>        <span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span>        <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//mA = 10000;</span>    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span>&#125;;<span class="hljs-comment">//const修饰对象  常对象</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">const</span> Person person; <span class="hljs-comment">//常量对象  </span>    <span class="hljs-built_in">cout</span> &lt;&lt; person.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span>    person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span>    <span class="hljs-comment">//常对象访问成员函数</span>    person.MyFunc(); <span class="hljs-comment">//常对象不能调用const的函数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="4-7-友元"><a href="#4-7-友元" class="headerlink" title="4.7 友元"></a><strong>4.7 友元</strong></h2><p>私有属性(Private) 也想让类外特殊的一些函数或者类进行访问，就需要用到友元（friend）</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h2 id="4-8-运算符重载"><a href="#4-8-运算符重载" class="headerlink" title="4.8 运算符重载"></a><strong>4.8 运算符重载</strong></h2><pre><code class="hljs cpp">函数名 <span class="hljs-keyword">operator</span>运算符()</code></pre><p>例如：<code>Person operator+(const Person&amp; p)</code></p><p>几乎所有的运算符都能进行重载。</p><h2 id="4-9-多继承（慎用）"><a href="#4-9-多继承（慎用）" class="headerlink" title="4.9 多继承（慎用）"></a><strong>4.9 多继承（慎用）</strong></h2><p>其它编程语言中一般为单继承，但是在C++中允许多继承。</p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><h2 id="4-10-菱形继承（了解）"><a href="#4-10-菱形继承（了解）" class="headerlink" title="4.10 菱形继承（了解）"></a><strong>4.10 菱形继承（了解）</strong></h2><p>两个派生类继承同一个基类</p><p>又有某个类同时继承者两个派生类</p><p>这种继承被称为菱形继承，或者钻石继承</p><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用<strong>虚继承</strong>可以解决菱形继承问题</li></ul><h2 id="4-11-多态"><a href="#4-11-多态" class="headerlink" title="4.11 多态"></a><strong>4.11 多态</strong></h2><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数（函数前面加上virtual关键字）实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h3 id="4-11-1-虚函数和抽象类（接口）-重要"><a href="#4-11-1-虚函数和抽象类（接口）-重要" class="headerlink" title="4.11.1 虚函数和抽象类（接口）(重要)"></a><strong>4.11.1 虚函数和抽象类（接口）(重要)</strong></h3><p>C++中没有接口的概念，但是可以用抽象类来实现接口。</p><p>虚函数</p><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><h3 id="4-11-2-虚析构和纯虚析构"><a href="#4-11-2-虚析构和纯虚析构" class="headerlink" title="4.11.2 虚析构和纯虚析构"></a><strong>4.11.2 虚析构和纯虚析构</strong></h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li><strong>都需要有具体的函数实现</strong></li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~类名()&#123;&#125;</code></pre><p>纯虚析构语法：</p><pre><code class="hljs gcode">virtual ~类名<span class="hljs-comment">()</span> = <span class="hljs-number">0</span>;类名::~类名<span class="hljs-comment">()</span>&#123;&#125;</code></pre><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a><strong>5. 参考资料</strong></h1><p>视频：<a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1et411b73Z</a></p><p>笔记：<a href="https://github.com/AnkerLeng/Cpp-0-1-Resource" target="_blank" rel="noopener">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署到Github-Pages上的博客，自定义域名，和免费域名如何申请</title>
    <link href="/2020/05/04/%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%92%8C%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7/"/>
    <url>/2020/05/04/%E9%83%A8%E7%BD%B2%E5%88%B0Github-Pages%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%92%8C%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7/</url>
    
    <content type="html"><![CDATA[<p>之前一篇文章提到了使用Hexo，搭建个人博客。</p><a href="/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/" title="一个简单易用的制作博客的框架：Hexo">一个简单易用的制作博客的框架：Hexo</a><p><br/>后面经过我一段时间的探索，发现有2个缺点。</p><ul><li>没有办法像知乎这样实时写文章发布。</li><li>新增文章后需要重新打包项目重新发布。</li></ul><p>这些问题的产生是因为通过这个工具构建的博客，只有前端，没有后端和数据库。所以无法通过后端将文章保存到数据库中从而达到访问页面的时候可以通过后端取出数据库中的内容，再返回前端。</p><p>说远了…现在来说一说博客建好后，如何部署到Github Pages，因为上一篇文章在这个地方一笔带过。</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>如果想要使用Github Pages，那么就需要一个Github账号。</p><p><img src="/image/v2-9d93b379d174496153cc72aef40576b3_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>因为使用了Chrome自带的翻译，所以显示的是中文</p><p>注册完毕后，登入账号，新建一个仓库。</p><p><img src="/image/v2-6672df7514ec7cd1a0bf884fafa7ff16_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>框起来的地方，必须要输入一致，这里因为我已经创建过了，所以会报错。也就是说仓库的名称必须为<code>你的用户名.github.io</code>。</p><p><img src="/image/v2-372deb950f76f10e7670c58f1c5533b5_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>注意这里的选项，第一个是公开的仓库，第二个是私人仓库，私人的仓库在微软收购了Github后可以免费创建。<strong>但是如果想使用Github Pages，必须将仓库公开，如果确实不想公开，那只有付费。</strong></p><p>创建成功后会看到下面的界面：</p><p><img src="/image/v2-1f0089cb7cae30917f225b71cd355d96_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>先不要关闭这个界面，来到已经构建完毕的博客项目，如果没有构建，在<code>cmd</code>中使用命令<code>hexo g</code>进行构建，构建完毕后会新增一个public文件夹，进入到public文件夹中。</p><p><img src="/image/v2-2fc0adecd00e851847c713b28db9364a_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>右键空白处，打开Git命令窗口。**如果看不见这个选项，可能是因为你没有安装Git，需要先安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>。</p><p>安装完成后，需要设置你的Git用户名：</p><pre><code class="hljs shell">git config --global user.name "Your Name"git config --global user.email "email@example.com"</code></pre><p>接着就可以开始下面的事情：</p><ol><li>首先初始化Git仓库。<code>git init</code></li><li>将文件添加到Git仓库<code>git add .</code> 那个点也需要输入。</li><li>最后找到刚才没有关闭的网页中的有一项为<code>git remote add origin https://github.com/qflyb/xxx.github.io.git</code> 复制到命令窗口后回车。</li><li>最后输入命令<code>git push -u origin master</code>推送到Github仓库中。</li></ol><p>如果成功推送的话，返回刚才的网页刷新一下，就应该可以看到推送的文件，再稍微等待一会，输入xxx(你的Github用户名).<a href="https://link.zhihu.com/?target=http%3A//github.io">http://github.io</a>，应该就可以访问到你的博客网站了。</p><p>如果你觉得<a href="http://xxx.github.io这种域名既难记又难看，那你还得继续看下去进行自定义域名。" target="_blank" rel="noopener">http://xxx.github.io这种域名既难记又难看，那你还得继续看下去进行自定义域名。</a></p><h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p><a href="https://www.freenom.com/zh/index.html?lang=zh" target="_blank" rel="noopener">https://www.freenom.com/zh/index.html?lang=zh</a></p><p>在这个网站中可以申请免费域名，<strong>注意：免费域名仅供学习使用，如果你想要当站长，那还是得去购买收费域名。</strong></p><p><img src="/image/v2-f94e9aca265d206519dc742b8fca1d32_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>在这里输入需要购买的域名。</p><p><img src="/image/v2-fb0c3d243eea3a30fa1597fa0496869c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>会看到一堆免费域名，但是这时如果你点击获取，它就会变成不可用。</p><p>解决方法是搜索域名的时候带上后缀名。</p><p><img src="/image/v2-5bd195e80008b6b78cd659e676b57de5_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>点击完成。这时会跳转到一个界面：</p><p><img src="/image/v2-053598b80da4c645834510df04aba1b0_720w.png" srcset="/img/loading.gif" alt="img"></p><p>选择12个月</p><p>点击继续，会让你填写你的邮件地址。</p><p><img src="/image/v2-67063e1841839467a785eb73e93c0df6_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>填写完毕后会发送一封邮件到你填写的邮箱地址，点击链接后打开。</p><p><img src="/image/v2-5dfc5bacc4803343cb5baf8414cefc53_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>这里推荐还是填美国身份，如果不知道怎么填，还请百度一下。</p><p>如果一切顺利，域名就购买成功了，购买完成后我们还需要解析域名。</p><p><img src="/image/v2-749436fa271a8b5a5e85f2fd0f100125_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>点击如图所示的按钮</p><p><img src="/image/v2-531733c78affec5881689198027b1325_720w.png" srcset="/img/loading.gif" alt="img"></p><p>点击Manage Domain</p><p><img src="/image/v2-491214fb17b729b9228730e53e42bf4a_720w.png" srcset="/img/loading.gif" alt="img"></p><p>点击DNS解析</p><p><img src="/image/v2-7ae8cad84bfd92425ff28574f8fa057e_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如图所示，添加两项配置</p><p>到了这步，基本上完成了，接着只需要找到Github Pages的IP地址，这个好办，打开<code>cmd</code>。</p><p>输入<code>ping xxx.github.io</code>xxx是你的Github用户名。</p><p>找到了IP地址后，再将这个IP地址填入到之前DNS解析的Target里面，点击保存。</p><h1 id="最后一步"><a href="#最后一步" class="headerlink" title="最后一步"></a>最后一步</h1><p>终于到了最后一步了，只需要到刚才的Github仓库中点击Settings。</p><p><img src="/image/v2-dfab6002688ca2ad3e28a61aa250c042_720w.png" srcset="/img/loading.gif" alt="img"></p><p>往下翻会看到一个GitHub Pages的标题。</p><p><img src="/image/v2-f8425dbece6e93fad4fdecf4a578dd33_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>输入刚才申请的域名如<code>www.mikkk.ml</code>，点击保存。下面那个HTTPS证书会在你保存域名后自动帮你申请，不过可能最长需要24小时才能申请成功。</p><p>如果上面的步骤都完成后，等待一会，在浏览器的地址栏输入新增域名，应该就可以跳转到你的博客页面了。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>域名</tag>
      
      <tag>GitHub Pages</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs中module.exports和exports的区别</title>
    <link href="/2019/10/22/nodejs%E4%B8%ADmodule.exports%E5%92%8Cexports%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/22/nodejs%E4%B8%ADmodule.exports%E5%92%8Cexports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>最近在学习nodejs，这篇文章就权当是一篇笔记，如果有什么地方有误，望指出。</p><p>先说说它们之间的区别：</p><ul><li>exports只能使用语法来向外暴露内部变量：如exports.xxx = xxx;</li><li>module.exports既可以通过语法，也可以直接赋值一个对象。</li></ul><p>我们要明白一点，exports和module.exports其实是一个东西，不信我们来输出一下</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.exports === exports);<span class="hljs-comment">//输出结果为：true</span></code></pre><p>输出结果是true其实就说明它们就是一个东西，其实exports = module.exports，因为他们是引用类型的一个变量名，所以当exports再指向一个引用类型的时候，那么他们就不再全等。</p><pre><code class="hljs js">exports = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(exports === <span class="hljs-built_in">module</span>.exports);<span class="hljs-comment">//输出结果为：false</span></code></pre><p>当然，如果直接通过exports.xxx的形式赋值，那么他们依然会指向同一个地址：</p><pre><code class="hljs js">exports.array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(exports === <span class="hljs-built_in">module</span>.exports);<span class="hljs-comment">//输出结果为：true</span></code></pre><p>这个时候要明白module.exports和exports的区别，就要清楚什么是值类型，什么是引用类型。我对值类型和引用类型的理解就是，看它是存储在栈上，还是存储在堆上，值类型就是存储在栈上，引用类型是存储在堆上，但是有个很特殊的情况是，引用类型的名字，是存储在栈上，然后这个名字指向了堆上的一个地址，从而可以直接使用变量名，调用堆上的数据。</p><p><img src="/image/v2-52e9a85deec48e2fe61708b20058dd48_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>这样可能有点难以理解，我们用代码来简单的认识一下值类型：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = a;a = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a的值是："</span> + a);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);</code></pre><p>我们将1赋值为a，然后将a赋值给b，然后我们将2赋值为a那么这个时候a和b分别是多少呢？我们将它运行一下看结果：</p><p><img src="/image/v2-3eb9fd92f22e0c9983cb495fd03118df_720w.png" srcset="/img/loading.gif" alt="img"></p><p>那么为什么a的值是2，b的值为1呢？是因为当将a赋值给b的时候，相当于是将a的值拷贝给了b也就相当于是重新生成了一个b，那么这个b与a就没有什么关系了，如下图所示：</p><p><img src="/image/v2-df0097016e4d9ea1376ed617def5fc1b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以看出，这个时候再去改变变量a的值，那么b的值肯定不会发生变化。</p><p>那么引用类型呢：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<span class="hljs-keyword">let</span> b = a;a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a的值是："</span> + a);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);</code></pre><p>那么问题来了，这个时候的b会输出什么结果，是[1,2]还是[0,2]那么我们来进行输出一下</p><p><img src="/image/v2-a0ccf94fbc537f969c46bb043ff833d3_720w.png" srcset="/img/loading.gif" alt="img"></p><p>这个时候为什么输出的结果是0,2呢？这里就涉及到引用类型了，如下图所示：</p><p><img src="/image/v2-455d624d8c5029570d6dcaa4771b4173_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从图上面看的出来，栈中只是存储了一个变量名字，而数组是存储在堆中。而当将a赋值给b的时候，并不是从堆中拷贝一个数组再让b指向这个数组，而是直接将b指向和a指向的同一个数组。简单来说，可以把变量a看做是银行账户的存折，变量b是银行账户的卡，都是同一个账户，你从存折里面取钱或者存钱，那么卡中的钱也会跟着变多或者变少。</p><p>那么我们回到主题，那么我们再来说为什么module.exports可以赋值一个对象，而exports却不可以。要明白这点，就要从nodejs的模块化说起，当nodejs执行模块中的代码时，它会将模块中的代码，用一个函数进行包裹：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exports, require, module, __filename, __dirname</span>) </span>&#123;&#125;</code></pre><p>这里面的其他参数就在这篇文章中不仔细讲解了，不过可以发现，里面有个熟悉的参数module。这里就要说到exports的本质了，正如上面所说exports = module.exports，也就是说他们指向了堆空间的同一个东西，如果对exports进行赋值，那么exports的指向就不一样了，在另外的文件里面就无法再找到通过exports这个变量传递的东西，而module.exports是在执行模块代码中就将module传入到了函数中，所以即使module.exports的值改变也能够在其他文件中进行调用。</p><p>再写到这里的时候我产生了一个疑问，如果将module.exports的指向改变，那么通过exports.xxx传递的值在其他文件中还能进行调用嘛，于是我尝试了下面的代码：</p><pre><code class="hljs js"><span class="hljs-comment">//Test.js</span>exports.add = <span class="hljs-number">100</span>;<span class="hljs-built_in">module</span>.exports = <span class="hljs-number">1</span>;<span class="hljs-comment">//test1.js文件</span><span class="hljs-keyword">let</span> test = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./Test"</span>);<span class="hljs-keyword">let</span> p = test.add;<span class="hljs-keyword">let</span> b = test;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p的值是："</span> + p);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果是：</span><span class="hljs-comment">p的值是：undefined</span><span class="hljs-comment">b的值是：1</span><span class="hljs-comment">*/</span></code></pre><p>可以看出，改变了module.exports的指向后，exports.xxx的值在其他文件中也无法调用。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Html做一个快乐鸟小游戏</title>
    <link href="/2019/10/21/%E7%94%A8Html%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BF%AB%E4%B9%90%E9%B8%9F%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2019/10/21/%E7%94%A8Html%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BF%AB%E4%B9%90%E9%B8%9F%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>入门学习前端的时候做了这么一个简单的小游戏，为了将自己所学到的知识运用起来。</p><p><img src="/image/v2-c13b0cc0371ffc4725089cd58754cce7_b.webp" srcset="/img/loading.gif" alt="img"></p><p>做这个小游戏用到了：</p><ul><li>html</li><li>css</li><li>jQuery</li></ul><p>然后这个小游戏的图片素材用到了：</p><p><img src="/image/v2-3a6aca1fff7faed32f2c40d64ca258e0_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>其实用原生的js也是可以完成的，但是为什么要用jQuery？因为我直接跳过了原生JS的学习…只有等空余的时候，好好的找本书研究一下原生的js。</p><h1 id="一、-大致流程"><a href="#一、-大致流程" class="headerlink" title="一、 大致流程"></a>一、 大致流程</h1><p>下面是这个小游戏的大致流程：</p><p><img src="/image/v2-65bd207c86e0fac108f4bc74df6f6b37_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>其中鸟和管道应该用面向对象来做，但是我原生JS只学习了最基础的部分，而且JS在ES5的时候还没有类的概念，只能使用构造函数来模拟一个类，在ES6的时候才加入了class这个关键字，但是我知道ES6的时候，已经是在完成这个小游戏之后了。</p><p>从上面的素材图片只有4张可以看得出来，html和CSS的搭建是没有太大难度的。所以本文着重讲解JS的部分。</p><p>这里值得一说的是，我CSS上面是用的子绝父相的定律，来摆放鸟和管道，其中管道的代码如下所示：</p><pre><code class="hljs js"><span class="hljs-comment">/* 上边的管道 */</span>.tubeTop &#123;  width: <span class="hljs-number">90</span>px; height: <span class="hljs-number">420</span>px; background: url(<span class="hljs-regexp">/image/</span>bird/ColumnSprite.png) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>; background-size: cover; transform: rotate(<span class="hljs-number">180</span>deg);&#125;<span class="hljs-comment">/* 下边的管道 */</span>.tubebotton &#123; width: <span class="hljs-number">90</span>px; height: <span class="hljs-number">420</span>px; background: url(<span class="hljs-regexp">/image/</span>bird/ColumnSprite.png) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>; background-size: cover; margin-top: <span class="hljs-number">100</span>px;&#125;.tube &#123; position: absolute; top: <span class="hljs-number">0</span>;&#125;</code></pre><p>可以看得出来，其实上下管道用的是一张图片，只是将它旋转了180度，然后包含在一个div中，这样只要设置父盒子的位置，上下的两根管道的位置就不需要再去设置。</p><h1 id="二、-游戏逻辑"><a href="#二、-游戏逻辑" class="headerlink" title="二、 游戏逻辑"></a>二、 游戏逻辑</h1><p>模型控制：</p><p>其实整个游戏，鸟是没有动的，我是让背景向前移动，这里有一点需要注意背景我并不是拼接了很多张图，而是仅仅用了两张图，一张在可视范围内，一张在可视范围外，当前面的那张移出可视范围的时候，再用JS将它放置到后面那张背景的后面，这样反复，就可以变成一个无限背景。</p><p><img src="/image/v2-c57658b57d9d36d24b977109ad44d91c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>当管道移除可视范围外的时候，我并没有将它进行销毁，而是用JS重新设置它的位置，因为产生和销毁一个物体的时候，是非常的耗费性能的，如果一个物件能够复用，就需要想办法进行复用。</p><p>控制管道和背景的代码，管道的位置控制都是通过css设置它们position：</p><pre><code class="hljs js"><span class="hljs-comment">//控制管道</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tubeControl</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-comment">//背景1</span><span class="hljs-keyword">var</span> bgImg1 = $(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bgImg1 = bgImg1 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, bgImg1);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(bgImg1) &lt; <span class="hljs-number">-1490</span>) &#123;bgImg1 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, bgImg1);&#125;<span class="hljs-comment">//背景2</span><span class="hljs-keyword">var</span> bgImg2 = $(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bgImg2 = bgImg2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, bgImg2);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(bgImg2) &lt; <span class="hljs-number">-1490</span>) &#123;bgImg2 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, bgImg2);&#125;<span class="hljs-comment">//草</span><span class="hljs-keyword">var</span> Green = $(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];Green = Green - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, Green);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(Green) &lt; <span class="hljs-number">-1490</span>) &#123;Green = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, Green);&#125;<span class="hljs-keyword">var</span> Green2 = $(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];Green2 = Green2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, Green2);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(Green2) &lt; <span class="hljs-number">-1490</span>) &#123;Green2 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, Green2);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">-250</span>) &#123;left = <span class="hljs-number">1550</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);tube.eq(i).css(<span class="hljs-string">"top"</span>, top);&#125; <span class="hljs-keyword">else</span> &#123;left -= <span class="hljs-number">1</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);&#125;&#125;&#125;</code></pre><p>当管道已经移出可视范围的时候，给它一个随机数重新设置它的位置：</p><pre><code class="hljs js"><span class="hljs-comment">// 随机数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRondom</span>(<span class="hljs-params">muth</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * muth);&#125;<span class="hljs-comment">//Math.random()是随机生成0~1之间的小数</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">-250</span>) &#123;left = <span class="hljs-number">1550</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);tube.eq(i).css(<span class="hljs-string">"top"</span>, top);&#125; <span class="hljs-keyword">else</span> &#123;left -= <span class="hljs-number">1</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);&#125;&#125;</code></pre><p>控制鸟的方式我是一直让它向下走：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">birdDown</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bird = <span class="hljs-built_in">parseInt</span>(bird) + <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>, bird);&#125;</code></pre><p>然后鸟的动画部分就是让图片来回切换就可以达到动起来的效果，但是开篇的BUG也是在这里产生的，因为这个切换图片设置了延迟，所以在鸟死亡的时候，可能这个图片还没有进行切换：</p><pre><code class="hljs js"><span class="hljs-comment">//让鸟动起来</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">birdAnima</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>);setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.die) &#123;$(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"background-position"</span>,<span class="hljs-string">"-128px 0px"</span>);<span class="hljs-keyword">return</span>;&#125;bird.css(<span class="hljs-string">"background-position"</span>, <span class="hljs-string">"-64px 0px"</span>);setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;bird.css(<span class="hljs-string">"background-position"</span>,<span class="hljs-string">"0px 0px"</span>);&#125;, <span class="hljs-number">250</span>);&#125;, <span class="hljs-number">500</span>);&#125;</code></pre><p>我在怎么判断鸟是否撞到管道然后触发死亡状态的地方卡了一会，最后我是通过鸟的盒子的上下左右的坐标因为他们都是绝对定位，而我给了整个可视窗口相对定位，所以当它们的坐标相同时，它们之间就会重叠，然后和管道的坐标进行一个判断：</p><pre><code class="hljs js"><span class="hljs-comment">//判断鸟的位置</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameControl</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 地面为bottom 100px</span><span class="hljs-keyword">var</span> birdBottom = $(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"bottom"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(birdBottom) &lt;= <span class="hljs-number">80</span>) &#123;death();&#125;<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-keyword">var</span> birdTop = <span class="hljs-built_in">parseInt</span>($(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">var</span> birdLeft = <span class="hljs-built_in">parseInt</span>($(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> top =<span class="hljs-built_in">parseInt</span>(tube.eq(i).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">420</span>;<span class="hljs-keyword">var</span> left = <span class="hljs-built_in">parseInt</span>(tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">if</span> (birdTop &lt; top || birdTop + <span class="hljs-number">34</span> &gt; top + <span class="hljs-number">100</span>) &#123;<span class="hljs-keyword">if</span> (birdLeft + <span class="hljs-number">64</span> &gt; left + <span class="hljs-number">10</span> &amp;&amp;birdLeft &lt; left + <span class="hljs-number">90</span>) &#123;death();&#125;&#125;<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">300</span>) &#123;<span class="hljs-built_in">console</span>.log(birdLeft, left + <span class="hljs-number">90</span>);&#125;<span class="hljs-keyword">if</span> (birdLeft &gt; left + <span class="hljs-number">90</span> &amp;&amp;birdLeft &lt; left + <span class="hljs-number">101</span>) &#123;addScroe();&#125;&#125;&#125;</code></pre><p>得分的判断也在这个函数中，当小鸟飞过管道的某一位置，就调用addScroe()这个方法</p><p>为了保证分数和死亡只有一个，所以我将他们设置为全局变量window.die和window.playScroe，如果撞到地板和管道，就调用death()函数，同时将die设置为true：</p><pre><code class="hljs js"><span class="hljs-comment">//死亡状态</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">death</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">window</span>.die = <span class="hljs-literal">true</span>;$(<span class="hljs-string">".gameEnd span"</span>).text(<span class="hljs-string">"您的得分:"</span> + <span class="hljs-built_in">window</span>.playScroe);$(<span class="hljs-string">".gameEnd"</span>).fadeToggle(<span class="hljs-number">200</span>);&#125;</code></pre><p><strong>注：声明变量时不加window也是全局变量，但是加上的话更明显，一眼就可以知道它是全局变量。</strong></p><p>最后是重新开始函数，将管道背景鸟的位置复位：</p><pre><code class="hljs js"><span class="hljs-comment">//重新开始</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Recovery</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">window</span>.die = <span class="hljs-literal">false</span>;<span class="hljs-built_in">window</span>.playScroe = <span class="hljs-number">0</span>;$(<span class="hljs-string">"#scroe"</span>).text(<span class="hljs-built_in">window</span>.playScroe);<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-keyword">var</span> wid = <span class="hljs-number">400</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = wid + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"top"</span>, top);tube.eq(i).css(<span class="hljs-string">"left"</span>, left);wid += <span class="hljs-number">300</span>;&#125; <span class="hljs-comment">//背景1</span><span class="hljs-keyword">var</span> bgImg1 = $(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"0px"</span>);<span class="hljs-comment">//背景2</span><span class="hljs-keyword">var</span> bgImg2 = $(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"1500px"</span>);<span class="hljs-comment">//草</span><span class="hljs-keyword">var</span> Green = $(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"0px"</span>);<span class="hljs-keyword">var</span> Green2 = $(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"1500px"</span>);Green2 = Green2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>).css(&#123;left: <span class="hljs-string">"200px"</span>,top: <span class="hljs-string">"400px"</span>&#125;);&#125;</code></pre><p>整个小游戏大致的思路就是这样了，如果有什么疑问或者有什么错误的地方欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jQuery</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
