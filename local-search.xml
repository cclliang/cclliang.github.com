<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>个人博客评论系统：Valine</title>
    <link href="/2020/06/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%9AValine/"/>
    <url>/2020/06/24/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%EF%BC%9AValine/</url>
    
    <content type="html"><![CDATA[<p>之前我也写过一篇个人博客的评论系统：Gitalk。</p><p><a href="https://zhuanlan.zhihu.com/p/141078552" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/141078552</a></p><p>但是这个评论系统有一个不太好的地方，它需要使用GitHub账号才能够进行评论，这就涉及到很多人不想暴露自己的隐私或者没有GitHub账号就无法进行评论。</p><p>所以当我在重新搭建我的个人博客时，找了一款新的评论系统：Valine。</p><p><a href="https://valine.js.org/" target="_blank" rel="noopener">https://valine.js.org/</a></p><p>它可以实现不用进行登录就可以使用留言功能。</p><p><img src="/image/v2-9f9e697dd96073a019396aac5f531096_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>首先需要一个LeanCloud账号：</p><p><a href="https://leancloud.cn/dashboard/login.html#/signup" target="_blank" rel="noopener">https://leancloud.cn/dashboard/login.html#/signup</a></p><p>注册时需要进行实名认证。</p><p><img src="/image/v2-f66fe2f66f86046bf32f382c78517fef_720w.png" srcset="/img/loading.gif" alt="img"></p><p>应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了：</p><p><img src="/image/v2-806cbb9bc64a5463238e541e711a7764_720w.png" srcset="/img/loading.gif" alt="img"></p><p>接下来直接参考</p><p><a href="https://valine.js.org/quickstart.htmlvaline.js.org" target="_blank" rel="noopener">https://valine.js.org/quickstart.htmlvaline.js.org</a></p><p>进行配置就可以了。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>由于各种实名认证，最后我放弃将它集成在我的博客上面，有兴趣的朋友可以直接按照官方文档进行集成，还是非常简单方便的。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue服务器渲染优秀项目：Nuxt.js</title>
    <link href="/2020/06/22/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%EF%BC%9ANuxt.js/"/>
    <url>/2020/06/22/Vue%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE%EF%BC%9ANuxt.js/</url>
    
    <content type="html"><![CDATA[<h1 id="1-服务器渲染"><a href="#1-服务器渲染" class="headerlink" title="1. 服务器渲染"></a>1. 服务器渲染</h1><h2 id="1-1-什么是服务器渲染"><a href="#1-1-什么是服务器渲染" class="headerlink" title="1. 1 什么是服务器渲染"></a>1. 1 什么是服务器渲染</h2><p><a href="[https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F](https://ssr.vuejs.org/zh/#什么是服务器端渲染-ssr-？)">Vue.js 服务器端渲染指南 </a></p><p>Vue官网已经对服务器渲染讲解的很详细了，可以直接参考上面的文档。不过就是因为讲解的太过于全面，所以有时候可能看的一头雾水。</p><h2 id="1-2-为什么需要服务器渲染"><a href="#1-2-为什么需要服务器渲染" class="headerlink" title="1.2 为什么需要服务器渲染"></a>1.2 为什么需要服务器渲染</h2><p><strong>更好的 SEO，搜索引擎的爬虫抓取工具可以直接查看完全渲染的页面。</strong></p><p>这段话是什么意思呢，大家可以打开自己的Vue项目，右键查看源代码：</p><p><img src="/image/v2-28299477732b658e149ce2d986203754_720w.png" srcset="/img/loading.gif" alt="img"></p><p>可以看到，不管你的Vue项目有多庞大，作为入口的<code>index.html</code>一般就长成上面这个样子，页面中的<code>DOM</code>元素是由<code>JavaScript</code>进行生成，无法在<code>index.html</code>中直接查看到。</p><p>就是因为无法在<code>index.html</code>中直接查看到完全渲染的页面，尤其是在页面上的内容使用<code>ajax</code>动态获取渲染时，<strong>搜索引擎的爬虫就很难爬取得到你页面上的内容，不利于搜索引擎对你的页面进行排名 。</strong></p><p>如果你并不是指望着通过网站带来的广告费赚钱，那么完全不需要使用服务器渲染，当你想通过网站的流量获得广告费时，服务器渲染就显得特别重要，因为完全渲染的页面才有利于搜索引擎爬虫的爬取。不信你可以看看现在的主流网站，全是服务器渲染。</p><p><strong>更快的内容到达时间 (time-to-content)</strong></p><p>对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验。</p><p>没有人能够忍受打开一个网站需要长达10多秒的响应时间，服务器渲染也解决了这个痛点。</p><h1 id="2-Nuxt-js"><a href="#2-Nuxt-js" class="headerlink" title="2. Nuxt.js"></a>2. Nuxt.js</h1><p>如果你想要从头搭建服务端渲染，那么需要耗费大量的精力去进行研究，而<code>Nuxt.js</code>的出现，让一切都变得很简单。</p><p><a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">https://zh.nuxtjs.org/</a></p><h1 id="3-创建项目"><a href="#3-创建项目" class="headerlink" title="3. 创建项目"></a>3. 创建项目</h1><p>Nuxt.js团队创建了脚手架工具<a href="https://github.com/nuxt/create-nuxt-app" target="_blank" rel="noopener">create-nuxt-app</a>。</p><pre><code class="hljs powershell">npx create<span class="hljs-literal">-nuxt</span><span class="hljs-literal">-app</span> &lt;项目名&gt;yarn create nuxt<span class="hljs-literal">-app</span> &lt;项目名&gt;运行npm run dev</code></pre><h1 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4. 目录结构"></a>4. 目录结构</h1><p><code>assets</code> 用于组织未编译的静态资源如 LESS、SASS 或 JavaScript。</p><p><code>components</code> 用于组织应用的 Vue.js 组件。</p><p><code>layouts</code> 用于组织应用的布局组件。</p><p><code>middleware</code> 用于存放应用的中间件。</p><p><code>pages</code> 页面目录，用于组织应用的路由及视图。</p><p><code>plugins</code> 插件目录。</p><p><code>static</code> 存放应用的静态文件，此类文件不会被 Nuxt.js 调用 Webpack 进行构建编译处理。</p><p><code>store</code> 用于组织应用的 Vuex 状态树 文件。</p><p><code>nuxt.config.js</code>文件用于组织Nuxt.js 应用的个性化配置，以便覆盖默认配置。</p><p><code>package.json</code>文件用于描述应用的依赖关系和对外暴露的脚本接口。</p><h1 id="5-创建页面"><a href="#5-创建页面" class="headerlink" title="5. 创建页面"></a>5. 创建页面</h1><p>到了这一步开始，几乎就和正常的使用Vue创建项目差不多，将页面放在pages中，<code>Nuxt.js</code>会自动找到<code>index.vue</code>作为入口文件。</p><p>如果是之前创建的项目，直接将项目按照目录文件逐渐移动过来。</p><h1 id="6-asyncData-fetch"><a href="#6-asyncData-fetch" class="headerlink" title="6. asyncData fetch"></a>6. asyncData fetch</h1><p><a href="https://zh.nuxtjs.org/guide/async-data/" target="_blank" rel="noopener">https://zh.nuxtjs.org/guide/async-data/</a></p><p>上面的问题解决后，还存在一个问题，就是通过<code>ajax</code>取得的数据然后进行渲染的<code>DOM</code>元素并没有出现在<code>html</code>文件上， 解决这个问题就需要使用到<code>asyncData</code>，<code>fetch</code>。</p><p><strong>注：需要写在第一个入口文件中。</strong></p><p>在这两个方法中都无法调用<code>this</code>获取<strong>组件实例，</strong>因为它们是在<strong>组件初始化之前</strong>被调用。</p><ul><li><code>asyncData</code> 可以在设置组件的数据之前能异步获取或处理数据。</li><li><code>fetch</code> 用于在渲染页面前填充应用的状态树（store）数据， 与<code>asyncData</code>方法类似，不同的是它不会设置组件的数据。</li></ul><h1 id="7-部署上线"><a href="#7-部署上线" class="headerlink" title="7. 部署上线"></a>7. 部署上线</h1><h2 id="7-1-服务端渲染应用部署（常用）"><a href="#7-1-服务端渲染应用部署（常用）" class="headerlink" title="7.1 服务端渲染应用部署（常用）"></a>7.1 服务端渲染应用部署（常用）</h2><p>因为我的服务上装了宝塔面板，强烈推荐宝塔面板！很多东西都是一键安装，非常方便。</p><p><a href="https://bt.cn/" target="_blank" rel="noopener">https://bt.cn/</a></p><p><strong>第一步</strong></p><p>打包应用<code>npm run build</code> 。</p><p><strong>第二步</strong></p><p>在宝塔面板中的<code>网站</code>-<code>添加网站</code>，如果是要部署到服务器，那么相信大家都对服务器有一定了解。</p><p>添加网站后在<code>根目录</code>可以看到一个文件夹地址，将项目中的<code>.nuxt</code>，<code>static</code>，<code>nuxt.config.js</code>，<code>package.json</code>拷贝到该文件夹中。</p><p><strong>第三步</strong></p><p>服务器中安装<code>pm2</code> 直接在宝塔面板的<code>软件商店</code>里面搜索后安装。安装完成后进入到刚才拷贝项目的文件夹中，运行<code>npm install</code>。</p><p><strong>第四步</strong></p><p>等待<code>npm</code>运行完成后，运行项目：</p><pre><code class="hljs powershell">pm2 start npm -<span class="hljs-literal">-name</span> <span class="hljs-string">"nuxt-name"</span> -- run start</code></pre><p><code>nuxt-name</code>为<code>package.json</code>中的项目名称。</p><p><strong>第五步</strong></p><p>如果上面的步骤都没有问题的话，就开启反向代理，在宝塔面板中<code>网站</code>-<code>设置</code>-<code>反向代理</code>，<code>目标url</code>中填写<code>http://localhost:3000</code>，<code>发送域名</code>中就填写你自己的域名。 到这里，项目就部署完毕了。</p><h2 id="7-2-静态应用部署"><a href="#7-2-静态应用部署" class="headerlink" title="7.2 静态应用部署"></a>7.2 静态应用部署</h2><p>Nuxt.js 可依据路由配置将应用静态化，使得我们可以将应用部署至任何一个静态站点主机服务商。</p><p>可利用下面的命令生成应用的静态目录和文件：</p><pre><code class="hljs text">npm run generate</code></pre><p>这个命令会创建一个 <code>dist</code> 文件夹，所有静态化后的资源文件均在其中。</p><p>注意：<code>nuxt generate</code>在 build/generate 时间内仍然需要SSR引擎，<strong>而且如果首页是动态获取数据的话，那千万别用这种方式打包，因为如果数据发生了改变，你就必须要重新进行打包。</strong></p><h2 id="7-3-单页面应用程序部署-SPA"><a href="#7-3-单页面应用程序部署-SPA" class="headerlink" title="7.3 单页面应用程序部署 (SPA)"></a>7.3 单页面应用程序部署 (SPA)</h2><p>使用时启用SPA模式<code>mode: &#39;spa&#39;</code>或<code>--spa</code>。</p><ul><li>将<code>nuxt.config.js</code>中的<code>mode</code>更改为<code>spa</code>。</li><li>运行 <code>npm run build</code>.</li><li>自动生成<code>dist/</code>文件夹，部署到您的服务器，如<code>Surge</code>，<code>GitHub Pages</code>或<code>nginx</code>。</li></ul><p>注意：这种方式打包出来的文件就和<code>Vue</code>直接打包出来的文件没有什么区别，最主要的用途就是将项目部署到<code>GitHub Pages</code>。</p><h1 id="8-错误"><a href="#8-错误" class="headerlink" title="8. 错误"></a>8. 错误</h1><h2 id="8-1-Interface-39-NuxtApp-39-incorrectly-extends-interface-39-Vue-39"><a href="#8-1-Interface-39-NuxtApp-39-incorrectly-extends-interface-39-Vue-39" class="headerlink" title="8.1 Interface &#39;NuxtApp&#39; incorrectly extends interface &#39;Vue&#39;"></a>8.1 <code>Interface &#39;NuxtApp&#39; incorrectly extends interface &#39;Vue&#39;</code></h2><p><a href="https://github.com/nuxt/typescript/issues/49" target="_blank" rel="noopener">https://github.com/nuxt/typescript/issues/49</a></p><p>可能是由于<code>element-ui</code>的<code>$loading</code>和<code>nuxt.js</code> 中的<code>$loading</code>冲突导致。</p><p>解决方法：</p><p>在<code>tsconfig.json</code>添加：</p><pre><code class="hljs json">"skipLibCheck":true,</code></pre><h2 id="8-2-window-is-not-defined"><a href="#8-2-window-is-not-defined" class="headerlink" title="8.2 window is not defined"></a>8.2 <code>window is not defined</code></h2><p>一些只兼容客户端的脚本被打包进了服务端的执行脚本中去。 对于只适合在客户端运行的脚本，需要通过使用<code>process.client</code>变量来判断导入。比如我要引入<code>smooth-scroll</code>这个页面平滑滚动插件，就需要写在<code>if</code>条件判断中，不然就会报错。</p><pre><code class="hljs js">created () &#123;  <span class="hljs-keyword">if</span> (process.client) &#123;    <span class="hljs-keyword">const</span> SmoothScroll = <span class="hljs-built_in">require</span>(<span class="hljs-string">'smooth-scroll'</span>)    <span class="hljs-keyword">const</span> scroll = <span class="hljs-keyword">new</span> SmoothScroll(<span class="hljs-string">'a[href*="#"]'</span>)  &#125;&#125;</code></pre><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>使用<code>Nuxt.js</code>最主要的原因就是为了<code>SEO</code>给网站带来更高的流量，提高网页的打开速度，如果不靠着网站盈利，我个人觉得完全没有必要使用服务器渲染，因为服务器渲染给服务器带来更大的压力，增加服务器的成本。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务端渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web前端：Viewer.js图片查看器</title>
    <link href="/2020/06/15/web%E5%89%8D%E7%AB%AF%EF%BC%9AViewer.js%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/"/>
    <url>/2020/06/15/web%E5%89%8D%E7%AB%AF%EF%BC%9AViewer.js%E5%9B%BE%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>做界面时可能会需要图片查看的功能，就比如QQ空间查看照片的功能。</p><p>虽然这个功能自己实现也不是太难，但是直接引入第三方库有个最大的好处是第三方库一般都经过很多个版本的更新迭代，不管是性能还是体验上一般都优于自己动手写（大佬除外）。</p><p><a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="noopener">Viewer.js</a>几乎是开源出来的图片查看器中功能最全的库。 </p><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><h2 id="1-1-npm"><a href="#1-1-npm" class="headerlink" title="1.1 npm"></a>1.1 npm</h2><pre><code class="hljs shell">npm install viewerjs</code></pre><h2 id="1-2-browser"><a href="#1-2-browser" class="headerlink" title="1.2 browser"></a>1.2 browser</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span>  <span class="hljs-attr">href</span>=<span class="hljs-string">"/path/to/viewer.css"</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"/path/to/viewer.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><pre><code class="hljs react">&lt;div&gt;  &lt;ul id&#x3D;&quot;images&quot;&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-1.jpg&quot; alt&#x3D;&quot;Picture 1&quot;&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-2.jpg&quot; alt&#x3D;&quot;Picture 2&quot;&gt;&lt;&#x2F;li&gt;    &lt;li&gt;&lt;img src&#x3D;&quot;picture-3.jpg&quot; alt&#x3D;&quot;Picture 3&quot;&gt;&lt;&#x2F;li&gt;  &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;import Viewer from &#39;viewerjs&#39;;import &#39;viewerjs&#x2F;dist&#x2F;viewer.css&#39;;const viewer &#x3D; new Viewer(document.getElementById(&#39;images&#39;), &#123;  &#x2F;&#x2F; 配置选项&#125;);</code></pre><h2 id="2-1-inline模式"><a href="#2-1-inline模式" class="headerlink" title="2.1 inline模式"></a>2.1 inline模式</h2><p>官方给出的实例中有一个属性inline: true,这个属性指的是<strong>在当前的容器中进行图片展示。</strong>推荐根据情况进行开启。</p><p><img src="/image/v2-40a418dc45c96d9d51910555c8dc7c3e_720w.png" srcset="/img/loading.gif" alt="img"></p><p><code>inline: true</code></p><p><img src="/image/v2-dc6e7ac0818674df6b673a0bda91a0fa_720w.png" srcset="/img/loading.gif" alt="img"></p><p><code>inline: false</code>时，在全屏范围内进行显示。 </p><h2 id="2-2-缩略图和原图"><a href="#2-2-缩略图和原图" class="headerlink" title="2.2 缩略图和原图"></a>2.2 缩略图和原图</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"(image,index) in imageInfo"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"index"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">el-card</span> <span class="hljs-attr">:body-style</span>=<span class="hljs-string">"&#123;padding:0&#125;"</span> <span class="hljs-attr">shadow</span>=<span class="hljs-string">"hover"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:data-original</span>=<span class="hljs-string">"image.original"</span></span><span class="hljs-tag">         <span class="hljs-attr">:src</span>=<span class="hljs-string">"image.thumbnail"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin-left: 5px;cursor: zoom-in"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-card</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>上面的代码是我在<code>Vue</code>中使用<code>Viewer.js</code>，其中<code>img</code>标签中的<code>src</code>是缩放图的地址，而<code>data-original</code>中是原图的地址。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> viewer = <span class="hljs-keyword">new</span> Viewer(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'images'</span>), &#123;  url: <span class="hljs-string">'data-original'</span>,&#125;);</code></pre><p>在声明时将<code>data-original</code>赋值给<code>url</code>这样点击查看时就会根据原图的地址进行加载原图。 </p><h1 id="3-兼容性"><a href="#3-兼容性" class="headerlink" title="3. 兼容性"></a>3. 兼容性</h1><ul><li>Chrome (最新)</li><li>Firefox (最新)</li><li>Safari (最新)</li><li>Opera (最新)</li><li>Edge (最新)</li><li>Internet Explorer 9+</li></ul><h1 id="4-键盘支持"><a href="#4-键盘支持" class="headerlink" title="4. 键盘支持"></a>4. 键盘支持</h1><ul><li>Esc：退出全屏、关闭查看器、退出模式、停止播放。</li><li>Space：停止播放。</li><li>←：查看上一张图像。</li><li>→：查看下一张图像。</li><li>↑：放大图像。</li><li>↓：缩小图像。</li><li>Ctrl + 0：缩小到初始大小。</li><li>Ctrl + 1：放大至自然大小。</li></ul><h1 id="5-配置参数"><a href="#5-配置参数" class="headerlink" title="5. 配置参数"></a>5. 配置参数</h1><p>配置参数就不详细讲解了，需要用到什么再去找寻就好了，也可以参考下面这篇文章：</p><p><a href="https://segmentfault.com/a/1190000016584946" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016584946</a></p><h1 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h1><p><img src="/image/v2-92538727955d76a616a4d07cde8bb176_720w.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h1><p>Viewer.js非常非常的简单易用，简直不需要过多的配置就能集成一个拥有非常多功能的图片查看器，最关键的是该图片查看器还支持移动端，如果是自己想要写出一个这样的图片查看器，还是需要花费大量功夫。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Viewer.js</tag>
      
      <tag>图片查看器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发：打字机效果插件Typed.js</title>
    <link href="/2020/06/15/web%E5%BC%80%E5%8F%91%EF%BC%9A%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6Typed.js/"/>
    <url>/2020/06/15/web%E5%BC%80%E5%8F%91%EF%BC%9A%E6%89%93%E5%AD%97%E6%9C%BA%E6%95%88%E6%9E%9C%E6%8F%92%E4%BB%B6Typed.js/</url>
    
    <content type="html"><![CDATA[<p>打字机效果是非常酷的文字显示效果，视觉表现极佳，而通过<code>Typed.js</code>可以很简单的在web开发中实现打字机效果。</p><h1 id="1-官网"><a href="#1-官网" class="headerlink" title="1. 官网"></a>1. 官网</h1><p><a href="https://mattboldt.com/demos/typed-js/" target="_blank" rel="noopener">JavaScript Animated Typing with Typed.jsmattboldt</a></p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><pre><code class="hljs powershell"><span class="hljs-comment"># With NPM</span>npm install typed.js<span class="hljs-comment"># With Yarn</span>yarn add typed.js<span class="hljs-comment"># With Bower</span>bower install typed.js</code></pre><h2 id="2-1-CDN"><a href="#2-1-CDN" class="headerlink" title="2.1 CDN"></a>2.1 CDN</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdn.jsdelivr.net/npm/typed.js@2.0.11"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><h2 id="3-1-HTML部分"><a href="#3-1-HTML部分" class="headerlink" title="3.1 HTML部分"></a>3.1 HTML部分</h2><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"typed"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"white-space: pre-wrap;line-height: 30px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre><p><strong>经过测试文字放在<code>span</code>标签里面，输入的光标才会正常显示。</strong></p><h2 id="3-2-JavaScript部分"><a href="#3-2-JavaScript部分" class="headerlink" title="3.2 JavaScript部分"></a>3.2 JavaScript部分</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> options = &#123;  strings: [    <span class="hljs-string">'First test.'</span>,    <span class="hljs-string">'Second test, \nit will pause for three seconds. ^3000'</span>,    <span class="hljs-string">"Second test, \nthe last sentence will go back to 'Second test, ', \noh no, this is the third test. ^1000"</span>,    <span class="hljs-string">"It's going to start repeating."</span>,  ],  typeSpeed: <span class="hljs-number">50</span>, <span class="hljs-comment">// 打印速度</span>  startDelay: <span class="hljs-number">300</span>, <span class="hljs-comment">// 开始之前的延迟300毫秒</span>  loop: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否循环</span>&#125;;<span class="hljs-keyword">const</span> typed = <span class="hljs-keyword">new</span> Typed(<span class="hljs-string">'#typed'</span>, options);</code></pre><h2 id="3-3-更多参数"><a href="#3-3-更多参数" class="headerlink" title="3.3 更多参数"></a>3.3 更多参数</h2><p>该插件可以配置很多参数，具体的参数可以参考官方文档，或者参考下面的文章：</p><p><a href="https://blog.csdn.net/weixin_41000111/article/details/78725784" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41000111/article/details/78725784</a></p><h1 id="4-vue中的使用"><a href="#4-vue中的使用" class="headerlink" title="4. vue中的使用"></a>4. vue中的使用</h1><p>该插件对<code>vue</code>做了一次封装：</p><p><a href="hhttps://github.com/Orlandster/vue-typed-js">vue-typed-jsgithub</a></p><h2 id="4-1-安装"><a href="#4-1-安装" class="headerlink" title="4.1 安装"></a>4.1 安装</h2><pre><code class="hljs powershell">npm install -<span class="hljs-literal">-save</span> vue<span class="hljs-literal">-typed</span><span class="hljs-literal">-js</span></code></pre><h2 id="4-2-使用"><a href="#4-2-使用" class="headerlink" title="4.2 使用"></a>4.2 使用</h2><p>非常简单，按照文档一步一步集成就可以了。</p><p><strong>注意：<code>vue-typed-js</code>没有声明文件，所以在<code>TypeScript</code>中使用会报错，而<code>Typed.js</code>是有声明文件的，可以直接在TypeScript中使用。</strong></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h1><p>总而言之使用<code>Typed.js</code>实现打字机效果非常的简单，简单到不需要用太多语言去进行描述。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动画</tag>
      
      <tag>Web 开发</tag>
      
      <tag>打字机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML中的瀑布流masonry在Vue中应用</title>
    <link href="/2020/06/12/HTML%E4%B8%AD%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81masonry%E5%9C%A8Vue%E4%B8%AD%E5%BA%94%E7%94%A8/"/>
    <url>/2020/06/12/HTML%E4%B8%AD%E7%9A%84%E7%80%91%E5%B8%83%E6%B5%81masonry%E5%9C%A8Vue%E4%B8%AD%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。</p></blockquote><p><img src="/image/v2-8d270acaf37a1f3a1a5a31a2152d55b8_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以说作为图片的一种展示风格，是非常的好看了，那么在HTML中怎么进行实现呢？</p><h1 id="纯CSS实现"><a href="#纯CSS实现" class="headerlink" title="纯CSS实现"></a>纯CSS实现</h1><p><a href="https://www.bilibili.com/video/BV1xa4y147JP?t=164" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1xa4y147JP?t=164</a></p><p>好吧，我就是看了这个视频后，才知道了原来这种排版叫做<strong>瀑布流</strong>，如果想要实现简单的瀑布流，根据这个视频中提供的思路，直接用CSS加上几行代码就能轻松实现瀑布流。所以这里就不再赘述，直接下一项。</p><h1 id="masonry"><a href="#masonry" class="headerlink" title="masonry"></a>masonry</h1><p>既然有现成的，为什么还要自己写呢，现在主要讲一讲如何在Vue中使用masonry。</p><p><strong>引入</strong></p><p>引入的方式有两种，一种通过CDN引入</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- or --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>一种是通过包管理的方式引入，即我们平时用的Vue,react框架，一般都是通过这种方式进行引入。</p><pre><code class="hljs ps1con">npm: npm install masonry-layout --saveBower: bower install masonry-layout --save</code></pre><p><strong>使用</strong></p><p>先将HTML结构创建出来：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>注：</p><ul><li>.grid即是所有图片的容器</li><li>.grid-item是单张图片的容器</li></ul><p>创建后，就开始准备引入js</p><p>1、通过jQuery引入</p><pre><code class="hljs js">$(<span class="hljs-string">'.grid'</span>).masonry(&#123;  <span class="hljs-comment">// options...</span>  itemSelector: <span class="hljs-string">'.grid-item'</span>,  columnWidth: <span class="hljs-number">200</span>&#125;);</code></pre><p>2、<strong>普通方式引入（Vue就是这样引入）</strong></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> Masonry <span class="hljs-keyword">from</span> <span class="hljs-string">"masonry-layout"</span>; <span class="hljs-comment">// Vue项目的引入方式</span>updated() &#123;  <span class="hljs-keyword">var</span> grid = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".grid"</span>);  <span class="hljs-keyword">var</span> msnry = <span class="hljs-keyword">new</span> Masonry(grid, &#123;    <span class="hljs-comment">// options...</span>    itemSelector: <span class="hljs-string">".grid-item"</span>,    columnWidth: <span class="hljs-number">300</span>,  &#125;);&#125;</code></pre><p>经过多次测试，发现放在<strong>updated</strong>中是最保险的，最开始我将初始化放在了<strong>mounted</strong>这个生命周期里面，虽然静态的HTML没有出现问题，但是你如果想要使用v-for的方式进行渲染，那么初始化就不会起作用。</p><p>3、HTML通过data方式引入</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid"</span> <span class="hljs-attr">data-masonry</span>=<span class="hljs-string">'&#123; "itemSelector": ".grid-item", "columnWidth": 200 &#125;'</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"grid-item"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  ...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h1 id="最后效果"><a href="#最后效果" class="headerlink" title="最后效果"></a>最后效果</h1><p><img src="/image/v2-324d03d4675ddb378a4658fc0e3fe10b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-d6c0ee583c7b4d24d3ef1c9ae3329010_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>响应式</p><p><strong>可以看出来masonry通过少量的配置就可以达到惊人的效果。</strong></p><p>至于更多的配置内容，可以参考下面这篇文章</p><p><a href="https://blog.csdn.net/a419419/article/details/83858984" target="_blank" rel="noopener">https://blog.csdn.net/a419419/article/details/83858984</a></p><p>有条件的话，也可以直接到masonry官网进行查看</p><p><a href="https://masonry.desandro.com/" target="_blank" rel="noopener">masonry</a></p><hr><h1 id="6-12更新"><a href="#6-12更新" class="headerlink" title="6.12更新"></a>6.12更新</h1><p>最近做项目时想要用瀑布流，但是发现一个BUG，当图片数据已经被获取，但是图片未加载完时，可能会出现图片重叠的现象，这种现象经过测试往往出现在刷新浏览器的时候。</p><p><img src="/image/v2-7d1215a22efd4c2cf5ac5b8c2532a2ef_b.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>引入第三方库</p><p><a href="https://github.com/desandro/imagesloaded" target="_blank" rel="noopener">imagesloadedgithub.com</a></p><p>这个库会判断元素中的图片是否已经加载完成，并且在加载完成后调用回调函数。</p><p>所以改一下上面的代码：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> imagesloaded <span class="hljs-keyword">from</span> <span class="hljs-string">'imagesloaded'</span>; <span class="hljs-comment">// 引入imagesloaded库</span>updated() &#123;  <span class="hljs-keyword">let</span> grid = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'.grid'</span>);  <span class="hljs-keyword">let</span> msnry = <span class="hljs-keyword">new</span> Masonry(grid, &#123;    <span class="hljs-comment">// options...</span>    itemSelector: <span class="hljs-string">'.grid-item'</span>,    columnWidth: <span class="hljs-number">300</span>,  &#125;);  imagesloaded(<span class="hljs-string">'.grid-item'</span>, () =&gt; &#123;    msnry.layout(); <span class="hljs-comment">// 图片加载完成后重新绘制。</span>  &#125;);&#125;</code></pre><p><img src="/image/v2-eee714c047801bc6f9eba8ef9bc84ff2_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以看到当图片加载完成后会进行重新排版</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://segmentfault.com/a/1190000013675077" target="_blank" rel="noopener">https://segmentfault.com/a/1190000013675077</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IOS系统越狱后的自用插件分享</title>
    <link href="/2020/06/11/IOS%E7%B3%BB%E7%BB%9F%E8%B6%8A%E7%8B%B1%E5%90%8E%E7%9A%84%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    <url>/2020/06/11/IOS%E7%B3%BB%E7%BB%9F%E8%B6%8A%E7%8B%B1%E5%90%8E%E7%9A%84%E8%87%AA%E7%94%A8%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要越狱？"><a href="#为什么要越狱？" class="headerlink" title="为什么要越狱？"></a>为什么要越狱？</h1><p>众所周知，IOS系统的封闭性要远远高于安卓，虽然现在安卓的很多衍生系统都已经不支持Root了。</p><p>正因为IOS的封闭性，所以IOS比起安卓来讲要安全很多，不会因为在滑动APP界面时点到广告就开始下载软件（以前我在用安卓时，那个年代流量还只有不到1G/月时，点到贴吧上面的广告瞬间开始下载软件，花掉不少流量…这个故事告诉我们，4G的速度还是挺快的）。</p><p>总之，越狱是为了实现IOS不具备的某些功能，但是<strong>越狱同时会造成安全性降低，同时越狱后微信和支付宝不支持指纹支付！</strong></p><p><strong>注意：某些插件我并不是用的作者源而是从第三方源（比如Cydia贴吧源、多米诺骨牌源）下载，大家酌情参考。</strong></p><p><strong>我的系统环境：IOS 12.4</strong></p><h1 id="1-Aerial-Rus"><a href="#1-Aerial-Rus" class="headerlink" title="1. Aerial Rus"></a>1. Aerial Rus</h1><p>源地址：<a href="http://rejail.earial/" target="_blank" rel="noopener">http://rejail.earial/</a></p><p>切换状态栏图标的颜色，因为切换后显得特别的花哨，所以这个插件已经被我放弃使用。</p><h2 id="2-AppStore快速切换账号"><a href="#2-AppStore快速切换账号" class="headerlink" title="2. AppStore快速切换账号"></a>2. AppStore快速切换账号</h2><p>源地址：<a href="http://apt.cydiaba.cn/" target="_blank" rel="noopener">http://apt.cydiaba.cn/</a>  Cydia贴吧源</p><p><img src="/image/v2-76c2bf8c74fe3d3f881b55332eed6583_720w.png" srcset="/img/loading.gif" alt="img"></p><p>有时候会有多个苹果ID需要来回切换，这显得很麻烦，安装该插件后，就会在AppStore里的个人信息处多出一个切换账号的按钮，曾经你登陆过的账号都可以快速进行切换，省去输入账号密码的烦恼。 </p><h2 id="3-AppStore"><a href="#3-AppStore" class="headerlink" title="3. AppStore++"></a>3. AppStore++</h2><p>源地址：<a href="http://cokepokes.github.io/" target="_blank" rel="noopener">http://cokepokes.github.io/</a></p><p><img src="/image/v2-e245957d4ff1075c5ef47eda6d357ba4_720w.png" srcset="/img/loading.gif" alt="img"></p><p>可以下载APP过去的版本，实用方法是按住右边的下载或者打开按钮，就会弹出来一个对话框。可以选择升级、降级、手动安装、禁止更新。</p><h2 id="4-NiceCaller-电话助手"><a href="#4-NiceCaller-电话助手" class="headerlink" title="4. NiceCaller 电话助手"></a>4. NiceCaller 电话助手</h2><p>源地址：<a href="http://apt.htv123.com/" target="_blank" rel="noopener">http://apt.htv123.com/</a></p><p><img src="/image/v2-8a856a64392b05ab0a2cc09895b279b6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>如果你被骚扰电话所困扰，该插件是你不二的选择，说起来，我最初越狱的目的就是为了找到一款可以拦截骚扰电话的插件，结果找了很多插件都无法正常进行拦截，直到使用了该插件，该插件需要配合腾讯手机管家使用。</p><p>当对方电话被腾讯手机管家标记过后，该插件会自动拒绝他们的电话，甚至还有拒接所有陌生电话的功能。</p><h2 id="5-KillX-Pro-Rus"><a href="#5-KillX-Pro-Rus" class="headerlink" title="5. KillX Pro Rus"></a>5. KillX Pro Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><img src="/image/v2-3c1b74b750379a404e424acf523dca8c_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>一键清理后台程序，安装后在后台界面向下滑动或者点击X，可以关闭掉所有打开的程序，非常实用的一个插件。</p><h2 id="6-DLEasy-Rus"><a href="#6-DLEasy-Rus" class="headerlink" title="6. DLEasy Rus"></a>6. DLEasy Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><strong>越狱后的神器之一。</strong>可以说是必装插件。可以下载YouTube视频，Instagram的图片等等。</p><p>同时还有一个附加功能：可以直接屏蔽YouTube客户端的广告，甚至还能打开YouTube的后台播放功能。当然，经济条件允许还是请购买YouTube会员。</p><h2 id="7-Prysm-控制中心美化"><a href="#7-Prysm-控制中心美化" class="headerlink" title="7. Prysm 控制中心美化"></a>7. Prysm 控制中心美化</h2><p>源地址：<a href="http://apt.wxhbts.com/" target="_blank" rel="noopener">http://apt.wxhbts.com/</a>  多米诺骨牌源</p><p><img src="/image/v2-f2f177b3929ca43334dd2877e4231370_720w.png" srcset="/img/loading.gif" alt="img"></p><p>顾名思义，就是美化控制中心的插件，我个人是不太习惯捣鼓这些样式上的东西。</p><h2 id="8-Liberty-Lite"><a href="#8-Liberty-Lite" class="headerlink" title="8. Liberty Lite"></a>8. Liberty Lite</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p>屏蔽越狱检测，因为有些软件在越狱环境下无法使用或者某些功能无法使用，比如支付宝的指纹支付，就可以使用这个软件屏蔽支付宝的越狱检测。</p><p>注意：<strong>使用该插件可能有封号的风险，贴吧中不少人使用这个插件屏蔽微信后导致微信号被封。</strong></p><h2 id="9-Selector-Rus"><a href="#9-Selector-Rus" class="headerlink" title="9. Selector Rus"></a>9. Selector Rus</h2><p>源地址：<a href="http://rejail.ru/" target="_blank" rel="noopener">http://rejail.ru/</a></p><p><img src="/image/v2-be2dbf6ec1bdea185711837ffa92835e_720w.png" srcset="/img/loading.gif" alt="img"></p><p>选中后会弹出翻译选项。</p><h2 id="10-CCVPN"><a href="#10-CCVPN" class="headerlink" title="10. CCVPN"></a>10. CCVPN</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>  (BigBoss)</p><p><img src="/image/v2-430f36fe097ad16abd6f868e0f7b8adf_720w.png" srcset="/img/loading.gif" alt="img"></p><p>在控制中心会出现一个开启或者关闭VPN的按钮，可以方便的开启或者关闭最后一次使用的VPN。</p><h2 id="11-Flex-3"><a href="#11-Flex-3" class="headerlink" title="11. Flex 3"></a>11. Flex 3</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-9402913985b9988d7db509cc76c84d2e_720w.png" srcset="/img/loading.gif" alt="img"></p><p>IOS越狱后的神器级插件，可以做到破解软件VIP，修改游戏数据，去除APP广告等等功能，插件内就提供了很多大家编辑上传的脚本，但是需要注意的是，<strong>由于APP在不停的更新，所以这些脚本不一定有用。</strong></p><h2 id="12-FLEXible"><a href="#12-FLEXible" class="headerlink" title="12. FLEXible"></a>12. FLEXible</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-4a544a9fcc438aed7c65b5f9ff1cb720_720w.png" srcset="/img/loading.gif" alt="img"></p><p>配合Flex 3的神器之一，可以抓取界面元素，定位到控制元素的函数，从而使用Flex 3禁止该元素的启动。</p><h2 id="13-ios12状态栏（仿IOS10-For-4-7）"><a href="#13-ios12状态栏（仿IOS10-For-4-7）" class="headerlink" title="13. ios12状态栏（仿IOS10 For 4.7）"></a>13. ios12状态栏（仿IOS10 For 4.7）</h2><p>源地址：<a href="http://apt.wxhbts.com/" target="_blank" rel="noopener">http://apt.wxhbts.com/</a></p><p><img src="/image/v2-4e1305d1258ac992a3eaa1ae61b619b2_720w.png" srcset="/img/loading.gif" alt="img"></p><p>将ios12状态栏的信号图标变成小圆点，虽然通过替换系统文件也可以做到，但是该插件实现了一键替换。</p><p>注意：<strong>使用有风险！请酌情使用。</strong></p><h2 id="14-ReProvision"><a href="#14-ReProvision" class="headerlink" title="14. ReProvision"></a>14. ReProvision</h2><p>源地址：<a href="http://repo.incendo.ws/" target="_blank" rel="noopener">http://repo.incendo.ws/</a></p><p><img src="/image/v2-ab3673749ab55ccee107cc405a97ef77_720w.png" srcset="/img/loading.gif" alt="img"></p><p>自动签名程序，作者之前宣布不再维护该项目，但是在某一天大家发现0.5.2~EOL这个版本又可以开始自签了。</p><h2 id="15-RealCC"><a href="#15-RealCC" class="headerlink" title="15. RealCC"></a>15. RealCC</h2><p>源地址：<a href="http://apt.thebigboss.org/repofiles/cydia/" target="_blank" rel="noopener">http://apt.thebigboss.org/repofiles/cydia/</a>   (BigBoss)</p><p><img src="/image/v2-d3b0a4af60f8fd73a2a7a32068c3e383_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>可以直接在控制中心关闭掉WiFi和蓝牙，不再像没有越狱之前仅仅是断开WiFi和蓝牙，本质上是没有关闭。</p>]]></content>
    
    
    <categories>
      
      <category>IOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>越狱</tag>
      
      <tag>IOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发：用Vue做一个播放器</title>
    <link href="/2020/06/06/web%E5%BC%80%E5%8F%91%EF%BC%9A%E7%94%A8Vue%E5%81%9A%E4%B8%80%E4%B8%AA%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <url>/2020/06/06/web%E5%BC%80%E5%8F%91%EF%BC%9A%E7%94%A8Vue%E5%81%9A%E4%B8%80%E4%B8%AA%E6%92%AD%E6%94%BE%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>之前在B站上面看到一个视频：</p><p><a href="https://www.bilibili.com/video/BV1Yz411z7An?t=16" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Yz411z7An?t=16</a></p><p>感觉它的这个播放器挺好看的，原作者是用的PPT制作。</p><p>我的设计灵感一向很差，叫我自己设计UI一般会非常难看，于是就准备仿照他这个，用Vue通过web的形式，参照他的界面，做一款播放器玩玩。</p><p><img src="/image/v2-c2842ce2a93229a97f26d7499f07be37_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>制作一个简单的播放器，<strong>拥有播放，暂停，上一首，下一首，歌曲列表等功能。</strong>音乐数据就通过<code>axios</code>从我的后端服务器上面取得。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>既然有了目标，那么首先就需要创建一个Vue工程：</p><pre><code class="hljs powershell">vue create music_player</code></pre><p><strong>注意：Vue的工程名称不能包含大写，但是可以有下划线。</strong></p><p>因为是复刻嘛，想要做到完全一样难度还是比较大的，所以就大概相似就差不多了，我就使用Vant作为UI。</p><p><a href="https://link.zhihu.com/?target=https%3A//youzan.github.io/vant/%23/zh-CN/quickstart">Vant UI - 快速上手youzan.github.io</a></p><p>该工程一看就是一个手机版的播放器，所以我还引入了<code>rem</code>文件：</p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">doc, win</span>) </span>&#123;  <span class="hljs-keyword">const</span> docEl = doc.documentElement;  <span class="hljs-keyword">const</span> resizeEvt = <span class="hljs-string">'orientationchange'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> ? <span class="hljs-string">'orientationchange'</span> : <span class="hljs-string">'resize'</span>;  <span class="hljs-keyword">const</span> recalc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> &#123; clientWidth &#125; = docEl;    <span class="hljs-keyword">if</span> (!clientWidth) <span class="hljs-keyword">return</span>;    docEl.style.fontSize = <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-number">100</span> * (clientWidth <span class="hljs-regexp">/ 375)&#125;px`;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  &#125;;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  if (!doc.addEventListener) return;</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  win.addEventListener(resizeEvt, recalc, false);</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">  doc.addEventListener('DOMContentLoaded', recalc, false);</span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-regexp">&#125;(document, window));</span></span></span></code></pre><p>该文件是为了使页面自适应。该文件的意思是<code>100px</code>为<code>0.1rem</code>，所以我们之后使用的所有<code>px</code>都要换算成为<code>rem</code>。</p><h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h1><p><img src="/image/v2-476cdd2f4ee590750b8a137136de203f_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>因为主要是做的移动端的项目，所以需要将浏览器的调试模式设置为iPhone 6/7/8，这也是现在移动端开发最为主流的分辨率。但是后面我将模式切换到了iPhone X…因为iPhone 6模式下整个界面显得有点拥挤。</p><h1 id="搭建界面"><a href="#搭建界面" class="headerlink" title="搭建界面"></a>搭建界面</h1><p>搭建界面几乎没有什么难度，CSS样式需要一点点的慢慢调整，最后调整到合适的样式。</p><p><img src="/image/v2-85706fa734c160d17d36a38392ec6683_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-99c57b3026a297d66546b0a143d0f0fc_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>先简单的搭出一个界面，等到跑通业务逻辑后，我们再来进行微调。</p><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><p>这种播放器之间的数据传递还是需要使用Vuex如果单靠组件之间的单向传递，那可是太麻烦了。</p><p><img src="/image/v2-767a1ad70ed58c3ef3f11511bb1fe093_b.webp" srcset="/img/loading.gif" alt="img"></p><p>从这里开始我将调试模式改为了iPhone X</p><p>我放入Vuex管理的数据有：</p><pre><code class="hljs js">state: &#123;  <span class="hljs-comment">/* 歌曲列表 */</span>  musicList: [&#123;    id: <span class="hljs-number">0</span>, <span class="hljs-comment">// 歌曲id</span>    musicName: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲名字</span>    musicSinger: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌手名字</span>    musicImg: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲图片</span>    musicUrl: <span class="hljs-string">''</span>,<span class="hljs-comment">// 歌曲地址</span>  &#125;],  <span class="hljs-comment">/* 音乐是否在播放 */</span>  musicStatus: <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 当前播放的音乐</span>  musicIndex: <span class="hljs-number">0</span>,  <span class="hljs-comment">// 管理音乐</span>  music: &#123;    play: <span class="hljs-built_in">Function</span>,    pause: <span class="hljs-built_in">Function</span>,  &#125;,&#125;,</code></pre><p>可以看到，集成Vuex后这些数据进行了正常显示，并且点击右下角的播放按钮，歌曲也能进行播放。</p><p>放到Vuex进行管理有个最大的好处就是，所有数据都只存在一份，如果一旦一个地方改变了数据，那么其它引用该数据的地方都会进行改变，比如：</p><p><img src="/image/v2-5c315e6f5b43783487df4204ef81f6c4_b.webp" srcset="/img/loading.gif" alt="img"></p><p>可以看到，在第二个界面改变了数据后，第一个界面也发生了变化</p><p>剩下的就是播放动画了。</p><p><strong>音乐频率图</strong></p><p><img src="/image/v2-fe08aa541c7913240d6cb12ca76d774b_b.webp" srcset="/img/loading.gif" alt="img"></p><p>由于最开始创建项目的时候我勾选了sass，所以这个音乐频率图用sass来做是十分快捷的。</p><pre><code class="hljs css"><span class="hljs-comment">/* 声明动画 */</span><span class="hljs-keyword">@keyframes</span> move &#123;  <span class="hljs-selector-tag">from</span> &#123;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">0</span>);  &#125;  <span class="hljs-selector-tag">to</span> &#123;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">50px</span>);  &#125;&#125;<span class="hljs-comment">/* 因为上面有70个div所以这里就用sass的循环，如果是css就只有一个一个的添加 */</span><span class="hljs-keyword">@for</span> $i from <span class="hljs-number">1</span> through <span class="hljs-number">70</span> &#123;  &amp;:nth-child(#&#123;$i&#125;) &#123;    <span class="hljs-comment">/* 使用随机数声明 */</span>    animation: move linear 0.5s ((random(1000)-500)/1000+s) infinite alternate;  &#125;&#125;</code></pre><h1 id="最后微调"><a href="#最后微调" class="headerlink" title="最后微调"></a>最后微调</h1><p>最主要是将开始的字体，行距，居中显示这些内容进行优化，因为开始只是大概的搭了一个界面后就先去做业务逻辑部分了，所以页面中还是有很多需要优化的地方。</p><p><img src="/image/v2-42b6917203ed198c8f5a4eb6db50d1b5_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><strong>进度条优化</strong></p><p>根据音乐当前播放时间和总时间，计算出音乐进度，将小于这个值的进度条都附加上一个更换背景颜色的类。</p><pre><code class="hljs js">&lt;div v-<span class="hljs-keyword">for</span>=<span class="hljs-string">"(i,index) in 40"</span> :key=<span class="hljs-string">"index"</span>     :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"`hight $&#123;musicPlay?'anima':''&#125; $&#123;progress&gt;index?'progress':''&#125;`"</span>&gt;&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp"></span><span class="hljs-regexp">.progress &#123;</span><span class="hljs-regexp">  background: #123a70;</span><span class="hljs-regexp">&#125;</span></code></pre><h1 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h1><pre><code class="hljs js"><span class="hljs-keyword">this</span>.timer = setInterval(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;  <span class="hljs-keyword">this</span>.progress = <span class="hljs-built_in">Math</span>.floor((<span class="hljs-keyword">this</span>.musicTime / <span class="hljs-keyword">this</span>.music) * <span class="hljs-number">40</span>);  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.progress);&#125;, <span class="hljs-number">1000</span>);<span class="hljs-comment">// 页面销毁后销毁定时器</span>destroyed() &#123;  clearInterval(<span class="hljs-keyword">this</span>.timer);&#125;,</code></pre><p>因为播放进度是通过<code>setInterval</code>每秒钟进行计算，所以计时器一定要在页面被销毁的时候一起给销毁掉，不然计时器会越来越多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个播放器的制作不难，难点在于Vuex的使用，该项目里面可能会有很多隐藏的BUG，或者体验不佳的地方，因为只做了个大概，没有太在意细节部分，如果一个项目要上线还是要经过不断的测试优化。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>unity3d</tag>
      
      <tag>播放器</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GSAP（GreenSock）：最健全的web动画库之一</title>
    <link href="/2020/06/03/GSAP%EF%BC%88GreenSock%EF%BC%89%EF%BC%9A%E6%9C%80%E5%81%A5%E5%85%A8%E7%9A%84web%E5%8A%A8%E7%94%BB%E5%BA%93%E4%B9%8B%E4%B8%80/"/>
    <url>/2020/06/03/GSAP%EF%BC%88GreenSock%EF%BC%89%EF%BC%9A%E6%9C%80%E5%81%A5%E5%85%A8%E7%9A%84web%E5%8A%A8%E7%94%BB%E5%BA%93%E4%B9%8B%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="官方的介绍"><a href="#官方的介绍" class="headerlink" title="官方的介绍"></a>官方的介绍</h1><blockquote><p>GreenSock动画平台（GSAP）可以对JavaScript可以操作的所有内容进行动画处理（CSS属性，SVG，React，画布，通用对象等），同时解决了不同浏览器上存在的兼容性问题，而且速度极快（比jQuery 快20倍）。大约有1000万个站点和许多主要品牌都使用 GSAP。</p></blockquote><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://link.zhihu.com/?target=https%3A//greensock.com/">https://greensock.com/greensock.com</a></p><p>动画其实是每秒多次改变元素属性值，元素看起来就仿佛在动一样，比如淡入淡出，旋转，移动等。而GSAP捕捉一个起始值和一个结束值，然后每秒在它们之间插值60次。</p><p>如果从技术上面来讲，GSAP其实应该被称为“GreenSock属性操纵器”（GSPM）。</p><h1 id="可以添加动画的元素"><a href="#可以添加动画的元素" class="headerlink" title="可以添加动画的元素"></a>可以添加动画的元素</h1><p>GSAP非常的灵活，几乎可以处理所有页面上可以通过JS进行改变的元素，例如：</p><ul><li>CSS：2D和3D变换，颜色，<code>width</code>，<code>opacity</code>，<code>border-radius</code>，<code>margin</code>，和几乎所有CSS值。</li><li>SVG属性：<code>viewBox</code>，<code>width</code>，<code>height</code>，<code>fill</code>，<code>stroke</code>，<code>cx</code>，<code>r</code>，<code>opacity</code>，等插件，像MorphSVG和DrawSVG可用于高级特效。</li><li>任何数值，例如，呈现为的对象<code>&lt;canvas&gt;</code>。对3D场景中的相机位置进行动画处理或过滤值。GSAP通常与Three.js和Pixi.js一起使用。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载直接引入"><a href="#下载直接引入" class="headerlink" title="下载直接引入"></a>下载直接引入</h2><p><a href="https://link.zhihu.com/?target=https%3A//greensock.com/files/file/20-gsap-3-public-files/%3Fdo%3Ddownload%26csrfKey%3D15944fce35b951ce3142b11661536cdd">greensock Version 3.3.0greensock.com</a></p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>官网上提供的CDN非常的多，可以按照自己的需要进行引入。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/gsap.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/CSSRulePlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/Draggable.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/EaselPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/MotionPathPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/PixiPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/TextPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/ScrollToPlugin.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/gsap/3.3.0/ScrollTrigger.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>NPM</p><pre><code class="hljs shell">npm install gsapyarn add gsap</code></pre><h1 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h1><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h2><p><code>gsap.to(targets,vars)</code>：从开始的位置到结束的位置。</p><ul><li><code>targets</code> - 你需要添加动画的对象，可以是<code>object</code>,<code>array</code>和选择器<code>&quot;.myClass&quot;</code>。</li><li><code>vars</code> - 一个对象，里面包含你想要改变的属性，延时，已经回调函数等。</li></ul><p><a href="https://greensock.com/docs/v3/GSAP/Tween/vars" target="_blank" rel="noopener">vars所有的参数</a></p><p><code>gsap.from(targets,vars)</code>：与上面的<code>gsap.to</code>相反，这个是从结束的位置到开始的位置。</p><p><code>Easing</code>：运动状态。属于<code>vars</code>中的一个属性。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.from(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">5</span>,    x: <span class="hljs-number">500</span>,    ease:<span class="hljs-string">"elastic.in(1,1)"</span> <span class="hljs-comment">// 运动状态</span>&#125;);Draggable.create(<span class="hljs-string">"#app"</span>);</code></pre><p><a href="https://greensock.com/docs/v3/Eases" target="_blank" rel="noopener">https://greensock.com/docs/v3/Eases</a></p><p>官网上面对于ease属性给出了很多值，如果有需要的话可以参考官网的属性。</p><p><img src="/image/v2-6adaec0fbbd60764e60aa2d389a1a829_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>只需要点一点，就直观的体验</p><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><ul><li><strong>onComplete</strong>：动画完成时调用。</li><li><strong>onStart</strong>：动画开始时调用</li><li><strong>onUpdate</strong>：每次动画更新时调用（在动画处于活动状态时每帧调用）。</li><li><strong>onRepeat</strong>：每次动画重复时调用一次。</li><li><strong>onReverseComplete</strong>：动画反转后再次到达其起点时调用。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.from(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">5</span>,    x: <span class="hljs-number">500</span>,    ease:<span class="hljs-string">"elastic.in(1,1)"</span>,    onComplete:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 动画播放完成时调用</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"111"</span>);    &#125;&#125;);</code></pre><p>回调参数</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tween = gsap.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    x: <span class="hljs-number">100</span>,    onComplete: tweenComplete,    onCompleteParams: [<span class="hljs-string">"done!"</span>]&#125;);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tweenComplete</span>(<span class="hljs-params">message</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(message);&#125;</code></pre><p>使用上面这种方式调用回调函数时，<strong>如果需要传递参数，必须以数组方式传递，即使只有一个参数。</strong></p><h1 id="控制动画"><a href="#控制动画" class="headerlink" title="控制动画"></a>控制动画</h1><ul><li><code>tween.pause();</code> 暂停</li><li><code>tween.resume();</code>恢复</li><li><code>tween.reverse();</code>反向播放</li><li><code>tween.seek(0.5);</code> 跳到0.5s</li><li><code>tween.progress(0.25);</code> 跳到4分之1处</li><li><code>tween.timeScale(0.5);</code> 速度减慢</li><li><code>tween.timeScale(2);</code>速度翻倍</li><li><code>tween.kill();</code> 删除动画</li></ul><h1 id="Timeline"><a href="#Timeline" class="headerlink" title="Timeline"></a>Timeline</h1><ul><li>从整体上控制一组动画。</li><li>在不使用很多<code>delay</code>的情况下构建一个动画序列。（如果对前一个动画进行时间调整后一个动画的触发时间也会改变，从而大大简化了实验和维护工作）。</li><li>对动画进行模块化。</li><li>可以进行非常复杂的动画编排。</li><li>要基于一组动画触发回调（例如“在完成所有这些动画之后，调用<code>myFunction()</code>”）。</li></ul><p>生命时间线变量<code>var t1 = gsap.timeline();</code></p><p>然后将需要依次触发的动画添加入时间线里即可，例如：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> tl = gsap.timeline();tl.add(gsap.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    delay: <span class="hljs-number">1</span>,    x: <span class="hljs-number">500</span>,&#125;));tl.to(<span class="hljs-string">"#app"</span>, &#123;    duration: <span class="hljs-number">1</span>,    y: <span class="hljs-number">500</span>,&#125;);</code></pre><p><img src="/image/v2-c2ee2519115a9bceb5623f5b3674fad4_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>时间轴的特殊属性：</p><ul><li><code>repeat</code>：动画重复的次数。</li><li><code>repeatDelay</code>：两次重复之间的间隔时间（以秒为单位）。</li><li><code>yoyo</code>：如果为<code>true</code>，则每次重复播放都会前后交替进行。</li><li><code>delay</code>：时间轴开始之前的延迟（以秒为单位）。</li><li><code>onComplete</code>：时间线播放完毕后调用的函数。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">var</span> tl = gsap.timeline(&#123;  repeat: <span class="hljs-number">1</span>,   yoyo: <span class="hljs-literal">true</span>,   onRepeat: onRepeatHandler,  onComplete: onCompleteHandler&#125;);</code></pre><p><strong>Getter / Setter 方法</strong></p><ul><li><code>time()</code> 播放头的本地位置（当前时间，以秒为单位），不包括任何重复或repeatDelays。</li><li><code>progress()</code> 它是介于0和1之间的值，指示播放头的位置，其中0处在开始位置，0.5处在中途完成，1处在结束位置。</li><li><code>duration()</code> 动画的持续时间（以秒为单位），不包括任何重复或repeatDelays。</li><li><code>delay()</code> 动画的初始延迟（动画开始之前的时间长度，以秒为单位）。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>GSAP的功能可远远不止上面这些，它几乎可以做到你想要的任何动画，包括DOM的拖动，滚动触发，运动路径插件等等，唯一的缺点就是它包含可以实现的动画实在是太多了，需要花费一定的时间进行学习，不像<code>Animate.css</code>和<code>Anime.js</code>这些动画库一样简单易用，不过如果你的网页需要大量动画，<code>GSAP</code>不失为一个很好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>HTML5</tag>
      
      <tag>动画</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发：利用background制作拉窗帘效果</title>
    <link href="/2020/06/02/web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%88%A9%E7%94%A8background%E5%88%B6%E4%BD%9C%E6%8B%89%E7%AA%97%E5%B8%98%E6%95%88%E6%9E%9C/"/>
    <url>/2020/06/02/web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%88%A9%E7%94%A8background%E5%88%B6%E4%BD%9C%E6%8B%89%E7%AA%97%E5%B8%98%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<p>往往利用CSS可以做出一些意想不到的效果，比如说下面的这个示例：</p><p><img src="/image/v2-1c842c67816442adf6c8ba34c6b7411a_b.webp" srcset="/img/loading.gif" alt="img"></p><p>为了演示随手做的，官网并不是这样</p><p>滚动鼠标滚轮，就有一种背景图被覆盖的错觉，之所以说是错觉，并不是背景图真的被覆盖了，其实背景图所在的盒子是跟着下面的图片一起在滚动，只是图片和窗口之间相对没有移动造成的错觉。</p><p>可能听起来比较复杂，但是实际上只需要一个属性就能做出这种效果，那就是<code>background-attachment: fixed;</code></p><p>还是同一个案例，我们将背景图片去掉，看看效果就明白了。</p><p><img src="/image/v2-0b2fa904729127861768553783f16c26_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="background-attachment"><a href="#background-attachment" class="headerlink" title="background-attachment"></a>background-attachment</h1><p>CSS 属性决定背景图像的位置是在视口内固定，或者随着包含它的区块滚动。</p><ul><li><code>fixed</code>此关键属性值表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。</li><li><code>local</code>此关键属性值表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。</li><li><code>scroll</code>此关键属性值表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。</li></ul><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-attachment</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web 开发</tag>
      
      <tag>HTML+CSS</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>web开发：全屏滚动插件fullpage.js</title>
    <link href="/2020/06/01/web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullpage.js/"/>
    <url>/2020/06/01/web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E6%8F%92%E4%BB%B6fullpage.js/</url>
    
    <content type="html"><![CDATA[<p>随着前端的飞速发展，现在制作界面时出现了非常多的好看的样式，比如说全屏滚动效果，能够带来很舒服的视觉体验。先来看一下什么是全屏滚动：</p><p><img src="/image/v2-432af4e9a4a61d6a7d615dca0b11e98c_b.webp" srcset="/img/loading.gif" alt="img"></p><p>这是<code>fullpage.js</code>的官网，只需要滑动一下滚轮，就能实现翻页的效果。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><a href="https://github.com/alvarotrigo/fullPage.js/tree/master/lang/chinese#fullpagejs" target="_blank" rel="noopener">fullPage.js中文文档github</a></p><p>如何安装其实文档上面已经说得很清楚了，即：</p><pre><code class="hljs powershell">// 使用 bowerbower install fullpage.js// 使用 npmnpm install fullpage.js</code></pre><p>包含文件：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"fullpage.css"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 以下行是可选的。 只有在使用选项 css3:false ，并且您希望使用其他缓动效果，而非 linear 、 swing 或 easeInOutCubic 时才有必要。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"vendors/easings.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-comment">&lt;!-- 以下行仅在使用选项 scrollOverflow:true 的情况下是必需的 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"vendors/scrolloverflow.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"fullpage.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>因为现在的单页面应用几乎都是使用的webpack打包工具，所以直接看一下webpack怎么引入，如果有使用其它工具，可以直接到下面的网址进行查看如何引入。</p><p><a href="https://github.com/alvarotrigo/fullPage.js/wiki/Use-module-loaders-for-fullPage.js" target="_blank" rel="noopener">https://github.com/alvarotrigo/fullPage.js/wiki/Use-module-loaders-for-fullPage.js</a></p><pre><code class="hljs js"><span class="hljs-comment">// Optional. When using fullPage extensions</span><span class="hljs-comment">//import scrollHorizontally from './fullpage.scrollHorizontally.min';</span><span class="hljs-comment">// Optional. When using scrollOverflow:true</span><span class="hljs-comment">//import IScroll from 'fullpage.js/vendors/scrolloverflow';</span><span class="hljs-comment">// Importing fullpage.js</span><span class="hljs-keyword">import</span> fullpage <span class="hljs-keyword">from</span> <span class="hljs-string">'fullpage.js'</span>;<span class="hljs-comment">// When using fullPage extensions replace the previous import</span><span class="hljs-comment">// of fullpage.js for this file</span><span class="hljs-comment">//import fullpage from 'fullpage.js/dist/fullpage.extensions.min';</span><span class="hljs-comment">// Initializing it</span><span class="hljs-keyword">var</span> fullPageInstance = <span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#myFullpage'</span>, &#123;    navigation: <span class="hljs-literal">true</span>,    sectionsColor:[<span class="hljs-string">'#ff5f45'</span>, <span class="hljs-string">'#0798ec'</span>, <span class="hljs-string">'#fc6c7c'</span>, <span class="hljs-string">'grey'</span>]&#125;);</code></pre><h1 id="应用于React"><a href="#应用于React" class="headerlink" title="应用于React"></a>应用于React</h1><p>根据上面的方法，我们很容易就可以在React中进行使用<code>fullpage.js</code>，只需要创建：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myFullpage"</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"section"</span>&gt;</span>Some section<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>componentDidMount() &#123;  let fullPageInstance = new fullpage('#myFullpage', &#123;    navigation: true,    sectionsColor:['#ff5f45', '#0798ec', '#fc6c7c', 'grey']  &#125;);&#125;</code></pre><p><img src="https://pic1.zhimg.com/v2-a5cb4934a0e9c2bc6ea72850bf96f494_b.webp" srcset="/img/loading.gif" alt="img"></p><p>可以看到通过上面的集成后，初步效果已经出来了，剩下的就是填充自己的内容，并且根据需要进行配置。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> myFullpage = <span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;<span class="hljs-comment">//导航</span>menu: <span class="hljs-string">'#menu'</span>,lockAnchors: <span class="hljs-literal">false</span>,anchors:[<span class="hljs-string">'firstPage'</span>, <span class="hljs-string">'secondPage'</span>],navigation: <span class="hljs-literal">false</span>,navigationPosition: <span class="hljs-string">'right'</span>,navigationTooltips: [<span class="hljs-string">'firstSlide'</span>, <span class="hljs-string">'secondSlide'</span>],showActiveTooltip: <span class="hljs-literal">false</span>,slidesNavigation: <span class="hljs-literal">false</span>,slidesNavPosition: <span class="hljs-string">'bottom'</span>,<span class="hljs-comment">//滚动</span>css3: <span class="hljs-literal">true</span>,scrollingSpeed: <span class="hljs-number">700</span>,autoScrolling: <span class="hljs-literal">true</span>,fitToSection: <span class="hljs-literal">true</span>,fitToSectionDelay: <span class="hljs-number">1000</span>,scrollBar: <span class="hljs-literal">false</span>,easing: <span class="hljs-string">'easeInOutCubic'</span>,easingcss3: <span class="hljs-string">'ease'</span>,loopBottom: <span class="hljs-literal">false</span>,loopTop: <span class="hljs-literal">false</span>,loopHorizontal: <span class="hljs-literal">true</span>,continuousVertical: <span class="hljs-literal">false</span>,continuousHorizontal: <span class="hljs-literal">false</span>,scrollHorizontally: <span class="hljs-literal">false</span>,interlockedSlides: <span class="hljs-literal">false</span>,dragAndMove: <span class="hljs-literal">false</span>,offsetSections: <span class="hljs-literal">false</span>,resetSliders: <span class="hljs-literal">false</span>,fadingEffect: <span class="hljs-literal">false</span>,normalScrollElements: <span class="hljs-string">'#element1, .element2'</span>,scrollOverflow: <span class="hljs-literal">false</span>,scrollOverflowReset: <span class="hljs-literal">false</span>,scrollOverflowOptions: <span class="hljs-literal">null</span>,touchSensitivity: <span class="hljs-number">15</span>,bigSectionsDestination: <span class="hljs-literal">null</span>,<span class="hljs-comment">//可访问</span>keyboardScrolling: <span class="hljs-literal">true</span>,animateAnchor: <span class="hljs-literal">true</span>,recordHistory: <span class="hljs-literal">true</span>,<span class="hljs-comment">//布局</span>controlArrows: <span class="hljs-literal">true</span>,verticalCentered: <span class="hljs-literal">true</span>,sectionsColor : [<span class="hljs-string">'#ccc'</span>, <span class="hljs-string">'#fff'</span>],paddingTop: <span class="hljs-string">'3em'</span>,paddingBottom: <span class="hljs-string">'10px'</span>,fixedElements: <span class="hljs-string">'#header, .footer'</span>,responsiveWidth: <span class="hljs-number">0</span>,responsiveHeight: <span class="hljs-number">0</span>,responsiveSlides: <span class="hljs-literal">false</span>,parallax: <span class="hljs-literal">false</span>,parallaxOptions: &#123;<span class="hljs-attr">type</span>: <span class="hljs-string">'reveal'</span>, <span class="hljs-attr">percentage</span>: <span class="hljs-number">62</span>, <span class="hljs-attr">property</span>: <span class="hljs-string">'translate'</span>&#125;,cards: <span class="hljs-literal">false</span>,cardsOptions: &#123;<span class="hljs-attr">perspective</span>: <span class="hljs-number">100</span>, <span class="hljs-attr">fadeContent</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">fadeBackground</span>: <span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">//自定义选择器</span>sectionSelector: <span class="hljs-string">'.section'</span>,slideSelector: <span class="hljs-string">'.slide'</span>,lazyLoading: <span class="hljs-literal">true</span>,<span class="hljs-comment">//事件</span>onLeave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">origin, destination, direction</span>)</span>&#123;&#125;,afterLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">origin, destination, direction</span>)</span>&#123;&#125;,afterRender: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,afterResize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">width, height</span>)</span>&#123;&#125;,afterReBuild: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,afterResponsive: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">isResponsive</span>)</span>&#123;&#125;,afterSlideLoad: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">section, origin, destination, direction</span>)</span>&#123;&#125;,onSlideLeave: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">section, origin, destination, direction</span>)</span>&#123;&#125;&#125;);</code></pre><p><strong>如果你想将一个页面设置为默认页，只需要给它添加<code>active</code>类，例如<code>&lt;div class=&quot;section active&quot;&gt;Some section&lt;/div&gt;</code>。</strong></p><h1 id="导航小圆点"><a href="#导航小圆点" class="headerlink" title="导航小圆点"></a>导航小圆点</h1><p><img src="https://pic3.zhimg.com/v2-f5d2b9a8deb690dc4c796bdb2182484a_b.webp" srcset="/img/loading.gif" alt="img"></p><p>这种导航小圆点是非常实用的一个功能，引入也很简单，</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-string">'fullpage.js/dist/fullpage.min.css'</span>; <span class="hljs-comment">//引入CSS样式，如果不引入是无法显示小圆点。</span><span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;  navigation:<span class="hljs-literal">true</span>, <span class="hljs-comment">// 开启小圆点</span>&#125;);</code></pre><h1 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h1><p>通常我们都需要一些锚点，点击锚点直接进行切换页面：</p><p>根据官方文档，如果要使用锚点功能只需要在HTML标签中使用属性<code>data-anchor</code>，例：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"section"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide1"</span>&gt;</span> slide 1 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide2"</span>&gt;</span> slide 2 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide3"</span>&gt;</span> slide 3 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"slide"</span> <span class="hljs-attr">data-anchor</span>=<span class="hljs-string">"slide4"</span>&gt;</span> slide 4 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>或者也可以直接在声明时进行初始化：</p><pre><code class="hljs js"><span class="hljs-keyword">new</span> fullpage(<span class="hljs-string">'#fullpage'</span>, &#123;anchors:[<span class="hljs-string">'firstPage'</span>, <span class="hljs-string">'secondPage'</span>, <span class="hljs-string">'thirdPage'</span>]&#125;);</code></pre><p>但是我发现了一个新问题：在<code>react-router</code>的<code>HashRouter</code>中会把<code>#</code>当做是hash来处理。也就是说<strong>锚点在<code>HashRouter</code>中无法使用。</strong><code>HashRouter</code>即地址栏中包含<code>#</code>的模式，例如：<code>https://www.xxx.cn/#/</code>这种地址，既然这种地址这么丑，为什么还要使用呢？</p><p>因为项目部署到服务器后，如果没有后端进行转发或者重定向，不使用<code>HashRouter</code>模式就可能存在你<strong>刷新一下页面会出现页面未找到的情况，但是我没有找到太好的解决办法。</strong>目前仅想到了使用<code>fullpage_api.moveTo();</code>方法来进行控制，但是远远没有锚点方便。</p><h1 id="react-fullpage"><a href="#react-fullpage" class="headerlink" title="react-fullpage"></a>react-fullpage</h1><p>都写到这里了，我才发现原来这个插件有React版本的，不仅有React版本，甚至还有Vue和Angular，不过应该仅仅是在该插件的基础上做了封装。</p><p><a href="https://github.com/alvarotrigo/react-fullpage" target="_blank" rel="noopener">react-fullpagegithub</a></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><pre><code class="hljs powershell">npm install @fullpage/react<span class="hljs-literal">-fullpage</span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用方法大体相同，如果将上面的例子改为<code>react-fullpage</code>写法即为：</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123;Component&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;<span class="hljs-keyword">import</span> ReactFullpage <span class="hljs-keyword">from</span> <span class="hljs-string">'@fullpage/react-fullpage'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;  render() &#123;    <span class="hljs-keyword">return</span> (      &lt;ReactFullpage        <span class="hljs-comment">//上面的参数设置都写在这里，不用再写在构造函数里面</span>        navigation=&#123;<span class="hljs-literal">true</span>&#125;        sectionsColor=&#123;[<span class="hljs-string">'#ff5f45'</span>, <span class="hljs-string">'#0798ec'</span>, <span class="hljs-string">'#fc6c7c'</span>, <span class="hljs-string">'grey'</span>]&#125;        render=&#123;(&#123;state, fullpageApi&#125;) =&gt; &#123;          <span class="hljs-keyword">return</span> (            &lt;ReactFullpage.Wrapper&gt;              &lt;div className=<span class="hljs-string">"section"</span>&gt;Some section&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">              &lt;div className="section"&gt;Some section&lt;/</span>div&gt;              &lt;div className=<span class="hljs-string">"section"</span>&gt;Some section&lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">              &lt;div className="section"&gt;Some section&lt;/</span>div&gt;            &lt;<span class="hljs-regexp">/ReactFullpage.Wrapper&gt;</span><span class="hljs-regexp">          );</span><span class="hljs-regexp">        &#125;&#125;</span><span class="hljs-regexp">      /</span>&gt;    );  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Test;</code></pre><h1 id="视频推荐"><a href="#视频推荐" class="headerlink" title="视频推荐"></a>视频推荐</h1><p><a href="https://www.bilibili.com/video/BV1Xx411d7rc" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Xx411d7rc</a></p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML5</tag>
      
      <tag>网页设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强大的油猴Tampermonkey：简单的脚本制作</title>
    <link href="/2020/05/28/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%B2%B9%E7%8C%B4Tampermonkey%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/"/>
    <url>/2020/05/28/%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%B2%B9%E7%8C%B4Tampermonkey%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E8%84%9A%E6%9C%AC%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="油猴是什么？"><a href="#油猴是什么？" class="headerlink" title="油猴是什么？"></a>油猴是什么？</h1><p>可以让你在网页上使用脚本，同时它拥有非常多的其他用户开放出来提供下载的脚本，如果你会JavaScript，你甚至可以自行编写脚本实现你想要实现的事情。</p><h1 id="油猴和Chrome扩展应用"><a href="#油猴和Chrome扩展应用" class="headerlink" title="油猴和Chrome扩展应用"></a>油猴和Chrome扩展应用</h1><p>Chrome扩展应用本质上是<code>HTML+CSS+JavaScript</code>而油猴脚本仅仅是一个<code>JavaScript</code>文件，而且谷歌对于扩展应用的审核比较严格，甚至还需要缴纳审核费用。而油猴脚本其实是简化的Chrome插件，它没有上面的那些限制。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>如果是能科学上网，就直接进入到Chrome应用商店安装。</p><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>如何下载第三方脚本在这里就不提了，这里只说一下如何创建一个新的油猴脚本文件。</p><p><img src="/image/v2-4ae5c4cc1df050759e13bfbd48764dcd_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>点击后可以看到下面的代码：</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         New Userscript  //脚本名字</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/ //脚本命名空间</span><span class="hljs-comment">// @version      0.1 //版本</span><span class="hljs-comment">// @description  try to take over the world! //描诉</span><span class="hljs-comment">// @author       You //作者名字</span><span class="hljs-comment">// @match        https://www.tampermonkey.net/index.php?ext=dhdg //应用在哪个网站上</span><span class="hljs-comment">// @grant        none //添加油猴的API</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    'use strict'</span>; <span class="hljs-comment">// 严格模式</span>    <span class="hljs-comment">// 从这里开始写代码</span>&#125;)();</code></pre><p>我们先来编写一个脚本练练手，脚本的目标是当访问bilibili主页时，会弹出”Hello World!”</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         Hello World!</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">    'use strict'</span>;    alert(<span class="hljs-string">"Hello World!"</span>);&#125;)();</code></pre><p><img src="/image/v2-77fdbe51956f0aa735764caebb2055d7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>经过上面的简单的测试后，下面来看一下如何用油猴脚本将B站打开的网页图片放在一个方框中进行显示，然后点击可以直接进行预览。</p><p><img src="/image/v2-134f4d56dc979fcc5d4dadb7775f4f38_b.webp" srcset="/img/loading.gif" alt="img"></p><p>最终效果</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>引入jQuery</li><li>引入Bootstrap</li><li>引入Vue</li></ul><p>需要准备以上的3样东西，jQuery是用来操作DOM，Vue是用来创建页面，而Bootstrap是用来丰富样式。这里这3个库的使用方法就省略了，如果有兴趣可以看一下相关的文章。</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         B站图片爬取</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/*</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// @resource     customCSS https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/vue</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">  "use strict"</span>;  $(<span class="hljs-string">"head"</span>).append($(<span class="hljs-string">`&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css"&gt;`</span>));&#125;)();</code></pre><p>引入了这三个库后就可以为所欲为了。</p><h1 id="外部引入脚本"><a href="#外部引入脚本" class="headerlink" title="外部引入脚本"></a>外部引入脚本</h1><p>由于油猴编辑器太难用，如果在外部编辑器编辑好了再复制到油猴脚本里面，这个过程就比较繁琐，所以我们可以<strong>让油猴插件引用外部文件。</strong></p><p>在扩展里面找到油猴插件点击<code>详细信息-允许访问文件网址</code></p><p><img src="/image/v2-e79a68dae8f50f075a296eb75dc423dc_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-0228dbdc2cad802583147263f0d0891f_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>剩下的在脚本中编写：</p><pre><code class="hljs js"><span class="hljs-comment">// @require      file://E:\study\tampermonkey\test.js(脚本的地址)</span></code></pre><p>到这一步就万事俱备，只差代码了！由于代码的编写过程与本篇幅无关，所以直接贴上最后的代码。</p><pre><code class="hljs js"><span class="hljs-comment">// ==UserScript==</span><span class="hljs-comment">// @name         B站图片爬取</span><span class="hljs-comment">// @namespace    http://tampermonkey.net/</span><span class="hljs-comment">// @version      0.1</span><span class="hljs-comment">// @description  try to take over the world!</span><span class="hljs-comment">// @author       You</span><span class="hljs-comment">// @match        https://www.bilibili.com/*</span><span class="hljs-comment">// @grant        none</span><span class="hljs-comment">// @resource     customCSS https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.slim.min.js</span><span class="hljs-comment">// @require      https://cdn.jsdelivr.net/npm/vue</span><span class="hljs-comment">// ==/UserScript==</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-meta">  "use strict"</span>;  $(<span class="hljs-string">"head"</span>).append($(<span class="hljs-string">`&lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css"&gt;`</span>));  <span class="hljs-keyword">var</span> divApp = $(    <span class="hljs-string">`</span><span class="hljs-string">&lt;div style="position:fixed; z-index:1000;top: 80vh;left: 5vw" id="myPlan"&gt;</span><span class="hljs-string">  &lt;div v-if="showMassage" style="position: fixed;z-index: -1;width: 100vw;height: 100vh;top: 0;right:0;background-color:rgba(0,0,0,0.5);"&gt;&lt;/div&gt;</span><span class="hljs-string">  &lt;button class="btn btn-primary" @click="showM"&gt;提取图片&lt;/button&gt;</span><span class="hljs-string">  &lt;div v-if="showMassage"</span><span class="hljs-string">       class="container"</span><span class="hljs-string">       style="position:fixed;background-color:rgba(0,0,0,0.5);;display: flex;flex-wrap: wrap;overflow: auto;width: 600px;height: 500px;top: 50%;left: 50%;transform: translate(-50%, -50%);"&gt;</span><span class="hljs-string">       &lt;div  v-for="(image,index) in images"  :key="index"&gt;</span><span class="hljs-string"></span><span class="hljs-string">       &lt;a :href="image.src" target="frame1"&gt;&lt;img :src="image.src" class="rounded float-left" style="min-width: 100px;margin: 10px;height: 80px" alt=""&gt;&lt;/a&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/li&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/div&gt;</span><span class="hljs-string">&lt;/div&gt;`</span>  );  $(<span class="hljs-string">"#app"</span>).append(divApp);  <span class="hljs-comment">/*Vue操作*/</span>  <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;    el: <span class="hljs-string">"#myPlan"</span>,    data: &#123;      showMassage: <span class="hljs-literal">false</span>,      images: []    &#125;, <span class="hljs-attr">methods</span>: &#123;      showM() &#123;        <span class="hljs-keyword">this</span>.showMassage = !<span class="hljs-keyword">this</span>.showMassage;        <span class="hljs-keyword">this</span>.images = $(<span class="hljs-string">"img"</span>);      &#125;    &#125;  &#125;);&#125;)();</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Bootstrap其实不引入也可以，没有怎么用到，Tampermonkey如果会用的话，还是非常好用的，甚至还可以当做爬虫使用，油猴对于前端来说使用起来几乎没有任何门槛，但是对于没有编程经验的人如果想要自行编写脚本，那还是具有一定的难度。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>油猴脚本</tag>
      
      <tag>浏览器插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js的替代品—Deno初体验</title>
    <link href="/2020/05/27/Node.js%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94Deno%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2020/05/27/Node.js%E7%9A%84%E6%9B%BF%E4%BB%A3%E5%93%81%E2%80%94Deno%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="Deno是什么"><a href="#Deno是什么" class="headerlink" title="Deno是什么"></a>Deno是什么</h1><p>它内置了 V8 引擎，用来解释 JavaScript。同时，也内置了 tsc 引擎，解释 TypeScript。它使用 Rust 语言开发，由于 Rust 原生支持 WebAssembly，所以它也能直接运行 WebAssembly，说简单点就是Node.js的一个替代品。</p><p><a href="https://deno.land/" target="_blank" rel="noopener">Deno — A secure runtime for JavaScript and TypeScript.deno.land</a></p><h1 id="为什么会出现Deno"><a href="#为什么会出现Deno" class="headerlink" title="为什么会出现Deno"></a>为什么会出现Deno</h1><ol><li><code>Node.js</code>自己的模块格式<code>CommonJS</code>与<code>ES</code>模块不兼容。</li><li><code>node_modules</code>和的<code>package.json</code>在项目越来越大后变得难以管理。</li><li><code>Node.js</code>并不完善的功能，导致外部工具层出不穷。</li></ol><p>由于上面这些原因，Ryan Dahl决定放弃Node.js，从头写一个替代品，彻底解决这些问题。</p><p>deno这个名字就是来自Node的字母重新组合（Node = no + de）表示”拆除 Node.js”（de = destroy, no = Node.js）。</p><h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><ul><li>使用TypeScript或者JavaScript</li><li>支持ES模块</li><li>安全控制（权限管理）</li><li>全局await</li><li>去中心化Packages</li><li>内置测试</li><li>标准库</li><li>浏览器兼容的API</li><li>Modern Js</li><li>执行Wasm二进制文件</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>开发工具选择：VScode</p><p><img src="/image/v2-6178dcee1166f01b959813c45bb4f7dd_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>官网提供了很多种安装方法，这里只说一下我是怎么安装的。</p><p>使用WIN（即Ctrl右边的键）+R组合键打开运行窗口，输入powershell，回车即可。</p><p>然后在新弹出的窗口中输入下面的命令。</p><pre><code class="hljs powershell">iwr https://deno.land/x/install/install.ps1 <span class="hljs-literal">-useb</span> | iex</code></pre><p><img src="/image/v2-bd054d423981c16c17ba7d68e5e45214_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果看到这个界面，就说明已经安装成功。</p><h1 id="去中心化packages"><a href="#去中心化packages" class="headerlink" title="去中心化packages"></a>去中心化packages</h1><p>用过<code>Node.js</code>后都知道，如果随着项目的增长，<code>package.json</code>文件会变得越来越臃肿，而且运行<code>npm install</code>时还会有几率出现未知的错误。</p><p>Deno为了解决这个痛点，同时还支持了ES模块，所以可以直接通过<code>import XXX from (URL地址)</code>的形式来导入包。</p><h1 id="标准库模块"><a href="#标准库模块" class="headerlink" title="标准库模块"></a>标准库模块</h1><p>Deno官方提供的模块可以直接在官网上面进行查看。</p><p><a href="https://deno.land/std" target="_blank" rel="noopener">https://deno.land/std</a></p><h1 id="安全控制"><a href="#安全控制" class="headerlink" title="安全控制"></a>安全控制</h1><p><strong>在读取脚本的时候必须使用参数，显式打开权限，不然会报错</strong>，这一点跟Node.js完全不同，可能才入手Deno时会很不习惯。如：<code>deno run --allow-read index.ts</code></p><pre><code class="hljs text">--allow-read：打开读权限，可以指定可读的目录，比如--allow-read&#x3D;&#x2F;temp。--allow-write：打开写权限。--allow-net&#x3D;google.com：允许网络通信，可以指定可请求的域，比如--allow-net&#x3D;google.com。--allow-env：允许读取环境变量。</code></pre><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>不管你愿不愿意，TypeScript的广泛应用的确是未来前端语言的趋势，现在Vue3.0也使用了TypeScript，而且如果你拥有一种后端语言的基础，上手TypeScript是非常简单的，所以还不赶紧学一波TypeScript。</p><h1 id="全局await"><a href="#全局await" class="headerlink" title="全局await"></a>全局await</h1><p>await不用再捆绑在async函数中，可以直接在全局进行使用。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> encoder = <span class="hljs-keyword">new</span> TextEncoder();<span class="hljs-keyword">const</span> greetText = encoder.encode(<span class="hljs-string">"Hello World"</span>);<span class="hljs-keyword">await</span> Deno.writeFile(<span class="hljs-string">"Hello.txt"</span>, greetText);</code></pre><p>上面的代码完成了一个文件写入的操作，可以看到，就算不在async函数中，同样可以使用await。</p><h1 id="创建简单服务器"><a href="#创建简单服务器" class="headerlink" title="创建简单服务器"></a>创建简单服务器</h1><p>根据官方的提示，我们用Deno来创建一个简单的服务器。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; serve &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"https://deno.land/std/http/server.ts"</span>;<span class="hljs-keyword">const</span> s = serve(&#123; <span class="hljs-attr">port</span>: <span class="hljs-number">8000</span> &#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"http://localhost:8000/"</span>);<span class="hljs-keyword">for</span> <span class="hljs-keyword">await</span> (<span class="hljs-keyword">const</span> req <span class="hljs-keyword">of</span> s) &#123;  req.respond(&#123; <span class="hljs-attr">body</span>: <span class="hljs-string">"Hello World\n"</span> &#125;);&#125;</code></pre><p>运行</p><pre><code class="hljs powershell">deno run -<span class="hljs-literal">-allow</span><span class="hljs-literal">-net</span> index.ts</code></pre><p>记得一定要加上<code>--allow-net</code>权限，不然会直接报错。</p><p>运行成功后通过浏览器打开<code>localhost:8000</code> 可以看到<code>Hello World</code>说明我们的服务器已经打开成功。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Deno从体验上来说非常不错，自身就支持<code>TypeScript</code>解析，而且解决了<code>package</code>这个痛点，但是现在作用于生产环境还是太早，因为它的社区还相对不成熟，肯定比不过经过了多年沉淀的<code>Node.js</code>，也许多年后会替代<code>Node.js</code>，但肯定不是现在。</p><h1 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h1><p><a href="https://www.ruanyifeng.com/blog/2020/01/deno-intro.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2020/01/deno-intro.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记：C++入门</title>
    <link href="/2020/05/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%E5%85%A5%E9%97%A8/"/>
    <url>/2020/05/27/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9AC++%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="1-IDE"><a href="#1-IDE" class="headerlink" title="1. IDE"></a><strong>1. IDE</strong></h1><h2 id="1-1-Visual-Studio"><a href="#1-1-Visual-Studio" class="headerlink" title="1.1 Visual Studio"></a><strong>1.1 Visual Studio</strong></h2><p><img src="/image/v2-265ce98a09b8b29727a4c13fc8ddada8_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="1-2-CLion"><a href="#1-2-CLion" class="headerlink" title="1.2 CLion"></a><strong>1.2 CLion</strong></h2><p>我最后还是选择了 <strong>CLion</strong> 因为之前一直用的JetBrains公司开发的IDE工具，换成Visual Studio突然还不习惯，虽然Visual Studio是我接触的第一款IDE，但是用它来编写C++代码提示居然默认不选中，编写C#的时候都可以，网上搜索发现Visual Studio编写C++代码就是这么设计的！（黑人问号？）</p><p>当然IDE这种东西还是自己顺手就好，如果你喜欢，你完全可以用记事本来写程序。</p><h3 id="1-2-1-CLion-运行环境"><a href="#1-2-1-CLion-运行环境" class="headerlink" title="1.2.1 CLion 运行环境"></a><strong>1.2.1 CLion 运行环境</strong></h3><p>因为我安装了Visual Studio所以可以直接导入Visual Studio的运行环境。</p><h3 id="1-2-2-中文乱码"><a href="#1-2-2-中文乱码" class="headerlink" title="1.2.2 中文乱码"></a><strong>1.2.2 中文乱码</strong></h3><p><img src="/image/v2-d81e1dd047d2de11c6472a4d1bb73032_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>图中的设置部分换成<code>UTF-8</code>，然后右下角控制台格式切换为<code>GBK</code></p><p><img src="/image/v2-5ef6f95e5ee2cc295c8fed2b35cfe396_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2. 入门"></a><strong>2. 入门</strong></h1><h2 id="2-1-Hello-World"><a href="#2-1-Hello-World" class="headerlink" title="2.1 Hello, World!"></a><strong>2.1 Hello, World!</strong></h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello, World!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-2-控制台打印"><a href="#2-2-控制台打印" class="headerlink" title="2.2 控制台打印"></a><strong>2.2 控制台打印</strong></h2><p>需要引入<code>using namespace std;</code>，然后通过<code>cout &lt;&lt; XXX &lt;&lt; endl;</code>打印，不得不说学过高级语言后觉得这实在很难用。</p><p>虽然可以用C语言的<code>printf()</code>但是你如果要打印一个变量需要给出类型，比如：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, a);<span class="hljs-comment">// 必须指定类型，不然会报错</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="2-3-清除控制台"><a href="#2-3-清除控制台" class="headerlink" title="2.3 清除控制台"></a><strong>2.3 清除控制台</strong></h2><pre><code class="hljs abnf">system(<span class="hljs-string">"cls"</span>)<span class="hljs-comment">;</span></code></pre><h2 id="2-4-保留关键字"><a href="#2-4-保留关键字" class="headerlink" title="2.4 保留关键字"></a><strong>2.4 保留关键字</strong></h2><p>C++中预先保留的单词，<strong>在定义变量或者常量时候，不要用关键字</strong></p><p><img src="/image/v2-24cc250da7e38eb4e1399bd71d8e7d57_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a><strong>3. 数据类型</strong></h1><h2 id="3-1-整形"><a href="#3-1-整形" class="headerlink" title="3.1 整形"></a><strong>3.1 整形</strong></h2><p><img src="/image/v2-aef5c9ea7a02946a2d07f4d86769f74d_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a><strong>3.2 浮点型</strong></h2><p>用于表示小数</p><p>浮点型变量分为两种：</p><ol><li>单精度float</li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><p><img src="/image/v2-542adae633ed058045b4c73885156ae4_720w.png" srcset="/img/loading.gif" alt="img"></p><p><strong>一般情况下<code>float</code>就足够了，如果不够用再定义<code>double</code>。</strong></p><h2 id="3-3-字符"><a href="#3-3-字符" class="headerlink" title="3.3 字符"></a><strong>3.3 字符</strong></h2><p><strong>语法：</strong><code>char ch = &#39;a&#39;;</code></p><ul><li>C和C++中字符型变量只占用<code>1个字节</code>。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元。</li></ul><h2 id="3-4-字符串"><a href="#3-4-字符串" class="headerlink" title="3.4 字符串"></a><strong>3.4 字符串</strong></h2><p><strong>C风格字符串</strong>： <code>char 变量名[] = &quot;字符串值&quot;</code></p><p><strong>C++风格字符串</strong>： <code>string 变量名 = &quot;字符串值&quot;</code> 需要加入头文件<code>#include&lt;string&gt;</code></p><h2 id="3-5-布尔类型-bool"><a href="#3-5-布尔类型-bool" class="headerlink" title="3.5 布尔类型 bool"></a><strong>3.5 布尔类型 bool</strong></h2><ul><li>true — 真（本质是1）</li><li>false — 假（本质是0）</li><li><strong>bool类型占1个字节大小</strong></li></ul><h2 id="3-6-转义字符"><a href="#3-6-转义字符" class="headerlink" title="3.6 转义字符"></a><strong>3.6 转义字符</strong></h2><p><img src="/image/v2-e34ba010b952bd041443d31ffe36d0e7_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a><strong>4. 运算符</strong></h1><h2 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a><strong>4.1 算术运算符</strong></h2><p><img src="/image/v2-ac1efde1442f83c97ea9e6745fbd39eb_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2 赋值运算符"></a><strong>4.2 赋值运算符</strong></h2><p><img src="/image/v2-b4b0e321fd55b5826c379c584528497a_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a><strong>4.3 比较运算符</strong></h2><p><img src="/image/v2-312d5675c66472b892bc77f7a454b5d6_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h2 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a><strong>4.4 逻辑运算符</strong></h2><p><img src="/image/v2-86186573378281763a342b4f13d8876b_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="5-流程控制"><a href="#5-流程控制" class="headerlink" title="5. 流程控制"></a><strong>5. 流程控制</strong></h1><h2 id="5-1-if语句（常用）"><a href="#5-1-if语句（常用）" class="headerlink" title="5.1 if语句（常用）"></a><strong>5.1 if语句（常用）</strong></h2><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">if</span><span class="hljs-params">(条件)</span></span>&#123; 条件满足执行的语句 &#125;</code></pre><p><img src="/image/v2-65f99327170787901b8b4f2639d9bb3b_720w.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//选择结构-单行if语句</span>    <span class="hljs-comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span>    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入一个分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"您输入的分数为： "</span> &lt;&lt; score &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//if语句</span>    <span class="hljs-comment">//注意事项，在if判断语句后面，不要加分号</span>    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学！！！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>多行格式if语句</strong>：<code>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</code></p><p><img src="/image/v2-098fbb7e36ce51d49281509de4769ff4_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>多条件的if语句</strong>：<code>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}... else{ 都不满足执行的语句}</code></p><p><img src="/image/v2-551948e98def630e5e86c56df0f51d6d_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了二本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了三本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上本科"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> score = <span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"请输入考试分数："</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span> &gt;&gt; score;    <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">600</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了一本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">700</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了北大"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">650</span>) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了清华"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了人大"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">500</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了二本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (score &gt; <span class="hljs-number">400</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我考上了三本大学"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"我未考上本科"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-2-三目运算符"><a href="#5-2-三目运算符" class="headerlink" title="5.2 三目运算符"></a><strong>5.2 三目运算符</strong></h2><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;    c = a &gt; b ? a : b;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//C++中三目运算符返回的是变量,可以继续赋值</span>    (a &gt; b ? a : b) = <span class="hljs-number">100</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-3-switch语句"><a href="#5-3-switch语句" class="headerlink" title="5.3 switch语句"></a><strong>5.3 switch语句</strong></h2><pre><code class="hljs cpp"><span class="hljs-keyword">switch</span>(表达式)&#123;            <span class="hljs-keyword">case</span> 结果<span class="hljs-number">1</span>：执行语句;<span class="hljs-keyword">break</span>;    <span class="hljs-keyword">case</span> 结果<span class="hljs-number">2</span>：执行语句;<span class="hljs-keyword">break</span>;    ...    <span class="hljs-keyword">default</span>:执行语句;<span class="hljs-keyword">break</span>;&#125;</code></pre><h2 id="5-4-循环结构"><a href="#5-4-循环结构" class="headerlink" title="5.4 循环结构"></a><strong>5.4 循环结构</strong></h2><h3 id="5-4-1-while循环语句（常用）"><a href="#5-4-1-while循环语句（常用）" class="headerlink" title="5.4.1 while循环语句（常用）"></a><strong>5.4.1 while循环语句（常用）</strong></h3><p><strong>语法：</strong><code>while(循环条件){ 循环语句 }</code></p><p><img src="/image/v2-12272cc189f8a1a6aac721cb5b4ca42f_720w.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"num = "</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;        num++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="5-4-2-do…while循环语句"><a href="#5-4-2-do…while循环语句" class="headerlink" title="5.4.2 do…while循环语句"></a><strong>5.4.2 do…while循环语句</strong></h3><p><strong>语法：</strong> <code>do{ 循环语句 } while(循环条件);</code></p><p><strong>注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> num = <span class="hljs-number">0</span>;    <span class="hljs-keyword">do</span> &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="hljs-built_in">endl</span>;        num++;    &#125; <span class="hljs-keyword">while</span> (num &lt; <span class="hljs-number">10</span>);    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="5-4-3-for循环语句（常用）"><a href="#5-4-3-for循环语句（常用）" class="headerlink" title="5.4.3 for循环语句（常用）"></a><strong>5.4.3 for循环语句（常用）</strong></h3><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</code></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="5-5-跳转语句"><a href="#5-5-跳转语句" class="headerlink" title="5.5 跳转语句"></a><strong>5.5 跳转语句</strong></h2><h3 id="5-5-1-break语句"><a href="#5-5-1-break语句" class="headerlink" title="5.5.1 break语句"></a><strong>5.5.1 break语句</strong></h3><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><h3 id="5-5-2-continue语句"><a href="#5-5-2-continue语句" class="headerlink" title="5.5.2 continue语句"></a><strong>5.5.2 continue语句</strong></h3><p><strong>作用：</strong>在<strong>循环语句</strong>中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><h3 id="5-5-3-goto语句（慎用）"><a href="#5-5-3-goto语句（慎用）" class="headerlink" title="5.5.3 goto语句（慎用）"></a><strong>5.5.3 goto语句（慎用）</strong></h3><p><strong>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</strong></p><h1 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a><strong>6. 数组</strong></h1><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><h2 id="6-1-一维数组"><a href="#6-1-一维数组" class="headerlink" title="6.1 一维数组"></a><strong>6.1 一维数组</strong></h2><ol><li><code>数据类型 数组名[ 数组长度 ];</code></li><li><code>数据类型 数组名[ 数组长度 ] = { 值1，值2 ...};</code></li><li><code>数据类型 数组名[ ] = { 值1，值2 ...};</code></li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//定义方式1</span>    <span class="hljs-comment">//数据类型 数组名[元素个数];</span>    <span class="hljs-keyword">int</span> score[<span class="hljs-number">10</span>];    <span class="hljs-comment">//利用下标赋值</span>    score[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>;    score[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span>;    score[<span class="hljs-number">2</span>] = <span class="hljs-number">85</span>;    <span class="hljs-comment">//利用下标输出</span>    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; score[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//第二种定义方式</span>    <span class="hljs-comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span>    <span class="hljs-comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span>    <span class="hljs-keyword">int</span> score2[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-comment">//逐个输出</span>    <span class="hljs-comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span>    <span class="hljs-comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span>    <span class="hljs-comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; score2[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//定义方式3</span>    <span class="hljs-comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span>    <span class="hljs-keyword">int</span> score3[] = &#123;<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">80</span>, <span class="hljs-number">70</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">40</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-built_in">cout</span> &lt;&lt; score3[i] &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="6-2-二维数组"><a href="#6-2-二维数组" class="headerlink" title="6.2 二维数组"></a><strong>6.2 二维数组</strong></h2><p>二维数组定义的四种方式：</p><ol><li><code>数据类型 数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = { {数据1，数据2 } ，{数据3，数据4 } };</code></li><li><code>数据类型 数组名[ 行数 ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li><li><code>数据类型 数组名[ ][ 列数 ] = { 数据1，数据2，数据3，数据4};</code></li></ol><blockquote><p>建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性</p></blockquote><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//方式1  </span>    <span class="hljs-comment">//数组类型 数组名 [行数][列数]</span>    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>];    arr[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;    arr[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;    arr[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">3</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;    arr[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;            <span class="hljs-built_in">cout</span> &lt;&lt; arr[i][j] &lt;&lt; <span class="hljs-string">" "</span>;        &#125;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-comment">//方式2 </span>    <span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span>    <span class="hljs-keyword">int</span> arr2[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] =            &#123;                    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,                    &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;            &#125;;    <span class="hljs-comment">//方式3</span>    <span class="hljs-comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span>    <span class="hljs-keyword">int</span> arr3[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;    <span class="hljs-comment">//方式4 </span>    <span class="hljs-comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span>    <span class="hljs-keyword">int</span> arr4[][<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="7-函数（重要）"><a href="#7-函数（重要）" class="headerlink" title="7. 函数（重要）"></a><strong>7. 函数（重要）</strong></h1><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h2 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1 定义"></a><strong>7.1 定义</strong></h2><pre><code class="hljs cpp">返回值类型 函数名 （参数列表）&#123;       函数体语句       <span class="hljs-keyword">return</span>表达式&#125;</code></pre><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><h2 id="7-2-值传递"><a href="#7-2-值传递" class="headerlink" title="7.2 值传递"></a><strong>7.2 值传递</strong></h2><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，如果形参发生，并不会影响实参</li></ul><h2 id="7-3-函数的声明"><a href="#7-3-函数的声明" class="headerlink" title="7.3 函数的声明"></a><strong>7.3 函数的声明</strong></h2><p><strong>作用：</strong> 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><h2 id="7-4-分文件编写"><a href="#7-4-分文件编写" class="headerlink" title="7.4 分文件编写"></a><strong>7.4 分文件编写</strong></h2><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol><li>创建后缀名为.h的头文件</li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><pre><code class="hljs cpp"><span class="hljs-comment">//swap.h文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">//实现两个数字交换的函数声明</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-comment">//swap.cpp文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"swap.h"</span></span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"b = "</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//main函数文件</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"swap.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">200</span>;    swap(a, b);    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="8-指针-重要"><a href="#8-指针-重要" class="headerlink" title="8. 指针(重要)"></a><strong>8. 指针(重要)</strong></h1><p><strong>几乎所有的编程语言都存在着指针，但是C++中的指针真是我学过的语言中最复杂的。其它语言最多只了解一下值类型和引用类型需要理解指针，但是C++却需要操作指针。</strong></p><h2 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1 概念"></a><strong>8.1 概念</strong></h2><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><p><strong>指针变量定义</strong>语法： <code>数据类型 * 变量名；</code></p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><h2 id="8-2-指针所占内存"><a href="#8-2-指针所占内存" class="headerlink" title="8.2 指针所占内存"></a><strong>8.2 指针所占内存</strong></h2><p>所有指针类型在32位操作系统下是4个字节</p><h2 id="8-3-空指针和野指针"><a href="#8-3-空指针和野指针" class="headerlink" title="8.3 空指针和野指针"></a><strong>8.3 空指针和野指针</strong></h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0的空间</span>    <span class="hljs-keyword">int</span> * p = <span class="hljs-literal">NULL</span>;    <span class="hljs-comment">//访问空指针报错 </span>    <span class="hljs-comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span>    <span class="hljs-keyword">int</span> * p = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x1100</span>;    <span class="hljs-comment">//访问野指针报错 </span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>空指针和野指针都不是我们申请的空间，因此不要访问。</strong></p><h2 id="8-4-const修饰指针"><a href="#8-4-const修饰指针" class="headerlink" title="8.4 const修饰指针"></a><strong>8.4 const修饰指针</strong></h2><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><h1 id="9-结构体"><a href="#9-结构体" class="headerlink" title="9. 结构体"></a><strong>9. 结构体</strong></h1><p>结构体属于用户<strong>自定义的数据类型</strong>，允许用户存储不同的数据类型</p><p><strong>语法：</strong><code>struct 结构体名 { 结构体成员列表 }；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值…}</li><li>定义结构体时顺便创建变量</li></ul><h2 id="9-1-指针"><a href="#9-1-指针" class="headerlink" title="9.1 指针"></a><strong>9.1 指针</strong></h2><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li></ul><h1 id="10-参考资料"><a href="#10-参考资料" class="headerlink" title="10. 参考资料"></a><strong>10. 参考资料</strong></h1><p>视频：<a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1et411b73Z</a></p><p>笔记：<a href="https://github.com/AnkerLeng/Cpp-0-1-Resource" target="_blank" rel="noopener">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>集成开发环境</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用JavaScript爬取豆瓣电影TOP250</title>
    <link href="/2020/05/21/%E7%94%A8JavaScript%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/"/>
    <url>/2020/05/21/%E7%94%A8JavaScript%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1TOP250/</url>
    
    <content type="html"><![CDATA[<p>突然之间看到了一个网站，源代码是用JavaScript实现爬虫相关的功能，瞬间打开新世界的大门。稍加研究，准备用JavaScript制作爬虫练练手，<strong>爬取豆瓣榜单TOP250</strong>。</p><p>这里就不得不提一下，豆瓣榜单TOP250真是初学爬虫非常好的练手项目之一，非常简单，而且也不会有反爬措施，一爬一个准，如果爬不动，只能说是姿势不对，翻翻百度涨涨知识，回头再战。</p><p>随着现代网络技术的飞速发展，网络上有非常多的有用的数据，如果单单靠人工去收集这些数据，效率低下不说，而且工作重复性非常高，这时爬虫就是不二的选择。</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a></p><p>由于运行环境是Node，所以需要先进行安装。</p><ul><li>axiso</li><li>cheerio</li><li>xlsx(sheetjs)</li></ul><h1 id="爬取的网址"><a href="#爬取的网址" class="headerlink" title="爬取的网址"></a>爬取的网址</h1><p><a href="https://movie.douban.com/top250" target="_blank" rel="noopener">https://movie.douban.com/top250</a></p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先需要创建一个Nodejs项目，打开<code>cmd</code>使用命令<code>npm init</code>进行初始化，初始化完毕后需要导入上面的3个库。</p><pre><code class="hljs text">npm install axios cheerio xlsx --save</code></pre><p><code>cheerio</code>相当于一个精简的jQuery，几乎实现了所有的jQuery的API，同时对DOM的操作更加快速与强大。</p><p><a href="https://github.com/cheeriojs/cheerio" target="_blank" rel="noopener">https://github.com/cheeriojs/cheerio</a></p><p><code>axios</code>是一个基于Promise的HTTP 库，可以用在浏览器和node.js中。也可以使用更好上手的<code>request</code> 。</p><p><a href="https://github.com/axios/axios" target="_blank" rel="noopener">https://github.com/axios/axios</a></p><p>代码很简单</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;  axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());    &#125;);  &#125;);&#125;</code></pre><p>调用<code>axios.get</code>方法会返回一个Promise，所以我们可以直接通过<code>.then</code>获取返回的数据。</p><p>这里主要说一下选择器的思路。</p><p><img src="/image/v2-fa21a625e9957785561a151efd3557cf_b.webp" srcset="/img/loading.gif" alt="img"></p><p>直接通过浏览器的检索功能，找到含有文字内容的容器。</p><p>可以看到这个容器有一个类<code>info</code> ，我们可以单单选择这个类，然后输出一下试试</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);axios.get(<span class="hljs-string">`https://movie.douban.com/top250`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);  <span class="hljs-built_in">console</span>.log($(<span class="hljs-string">".info"</span>).text());&#125;);</code></pre><p><img src="/image/v2-ba2d648a66775e0dc44d1982132ed59e_720w.jpg" srcset="/img/loading.gif" alt="img">输出结果太长，仅仅贴了一部分</p><p>往下翻了翻确定就是需要爬取的内容，然后完善代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);axios.get(<span class="hljs-string">`https://movie.douban.com/top250`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;  <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);  $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());  &#125;);&#125;);</code></pre><p>到这里，第一页的内容已经全部提取出来了，那么后面的内容怎么办呢，这时我们进到这个网站翻到第二页看看。</p><p>可以看到第二页的地址是：<code>https://movie.douban.com/top250?start=25&amp;filter=</code></p><p>第三页的地址是： <code>https://movie.douban.com/top250?start=50&amp;filter=</code></p><p>那么测试一下第一页的地址<code>https://movie.douban.com/top250?start=0&amp;filter=</code> ，测试结果发现能够正常打开首页。</p><p>这里就可以得出结论，后一页的地址仅仅改变前一页地址中的<code>start=</code> 后面的数字，并且比前一页多25。</p><p>那么到这里就可以写出完整代码：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;  axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>).then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"标题:"</span> + $(f).find(<span class="hljs-string">".title"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"评分:"</span> + $(f).find(<span class="hljs-string">".rating_num"</span>).text());      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"简介:"</span> + $(f).find(<span class="hljs-string">".inq"</span>).text());    &#125;);  &#125;);&#125;</code></pre><p>运行上面的代码，就可以将豆瓣TOP250的标题，评分，以及简介爬下来，但是现在问题来了，这种爬虫爬下来的数据既无法保存，也不方便查看，那么爬下来的意义又在哪里？如果能够将它保存为Excel，并且通过Excel打开就好了。</p><h1 id="保存为Excel"><a href="#保存为Excel" class="headerlink" title="保存为Excel"></a>保存为Excel</h1><p>上面的代码仅仅是爬取了数据，但是并没有将它导出为Excel，这个时候一个强大的库<code>sheetjs</code>就上场了。</p><p><code>sheetjs</code>能够将获取的数据通过Excel的形式导出。</p><p><a href="https://link.zhihu.com/?target=https%3A//github.com/SheetJS/sheetjs">https://github.com/SheetJS/sheetjsgithub.com</a></p><p>但是<code>sheetjs</code>只能处理二维数组，所以我们需要将上面爬虫爬到的数据保存为二维数组的形式，再将它用<code>sheetjs</code>存储起来。</p><p>我们直接将上面的代码修改一下：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cheerio = <span class="hljs-built_in">require</span>(<span class="hljs-string">"cheerio"</span>);<span class="hljs-keyword">const</span> axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">"axios"</span>);<span class="hljs-keyword">const</span> xlsx = <span class="hljs-built_in">require</span>(<span class="hljs-string">"xlsx"</span>);<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">let</span> arr = [];  arr[<span class="hljs-number">0</span>] = [<span class="hljs-string">"标题"</span>, <span class="hljs-string">"评分"</span>, <span class="hljs-string">"评论"</span>]; <span class="hljs-comment">// 表格的第一行</span>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">250</span>; i += <span class="hljs-number">25</span>) &#123;    <span class="hljs-keyword">let</span> response = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">`https://movie.douban.com/top250?start=<span class="hljs-subst">$&#123;i&#125;</span>&amp;filter=`</span>);    <span class="hljs-keyword">let</span> $ = cheerio.load(response.data);    $(<span class="hljs-string">".info"</span>).each(<span class="hljs-function">(<span class="hljs-params">index, f</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 从第二行开始写入</span>      arr[index + i + <span class="hljs-number">1</span>] = [];      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = $(f).find(<span class="hljs-string">".title"</span>).text();      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = $(f).find(<span class="hljs-string">".rating_num"</span>).text();      arr[index + i + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = $(f).find(<span class="hljs-string">".inq"</span>).text();    &#125;);  &#125;  <span class="hljs-keyword">let</span> filename = <span class="hljs-string">"top250.xlsx"</span>; <span class="hljs-comment">// 导出表格名称</span>  <span class="hljs-keyword">let</span> ws_name = <span class="hljs-string">"Sheet1"</span>; <span class="hljs-comment">// Excel第一个sheet的名称</span>  <span class="hljs-keyword">let</span> wb = xlsx.utils.book_new(), ws = xlsx.utils.aoa_to_sheet(arr);  xlsx.utils.book_append_sheet(wb, ws, ws_name);  <span class="hljs-comment">// 将数据添加到工作薄</span>  xlsx.writeFile(wb, filename); <span class="hljs-comment">// 导出Excel</span>&#125;main();<span class="hljs-comment">// 运行函数</span></code></pre><p>这里直接引入了<code>async</code>，<code>await</code>，简单的讲就是因为axiso获取页面内容为异步获取，如果使用Promise的<code>.then</code>的方式调用也是可以的，但是不如直接使用async，await简洁明了。</p><p>运行上面的代码后会在当前文件夹下面生成一个<code>top250.xlsx</code>文件，打开就可以看到我们爬取的数据。</p><p><img src="/image/v2-3b3cea67002ce1c3b7f79356133e2cec_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h1 id="在网页上面展示"><a href="#在网页上面展示" class="headerlink" title="在网页上面展示"></a>在网页上面展示</h1><p>经过测试，爬虫代码直接在浏览器上面跑会出现跨域问题，没有太好的方法解决，不过可以用<code>Nodejs</code>搭建后端，爬虫在后端爬取数据后返回前端。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实我对于爬虫来说也是一个小白，如果说用Python爬取数据和JavaScript爬取数据有什么特别大的区别，我觉得在爬取数据量不是特别大的情况下，想用哪个用哪个，如果是需要大量爬取数据，还是推荐Python。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网页抓取</tag>
      
      <tag>网页爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不用写代码就可以制作游戏的引擎：虚幻4</title>
    <link href="/2020/05/19/%E4%B8%8D%E7%94%A8%E5%86%99%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%9A%E8%99%9A%E5%B9%BB4/"/>
    <url>/2020/05/19/%E4%B8%8D%E7%94%A8%E5%86%99%E4%BB%A3%E7%A0%81%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%88%B6%E4%BD%9C%E6%B8%B8%E6%88%8F%E7%9A%84%E5%BC%95%E6%93%8E%EF%BC%9A%E8%99%9A%E5%B9%BB4/</url>
    
    <content type="html"><![CDATA[<p>最近两年虚幻4引擎名声大振，由于之前使用过Unity3D和Cocos Creator这两个游戏引擎。鉴于看到网上很多人说虚幻4是非常适合不会编程的人制作游戏的一款引擎，于是就准备尝试一番。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://www.unrealengine.com/zh-CN/?sessionInvalidated=true" target="_blank" rel="noopener">https://www.unrealengine.com/zh-CN/?sessionInvalidated=true</a></p><p>需要到虚幻4官网上面下载<code>Epic Games Launcher</code>，然后再通过这个启动器安装虚幻4引擎，安装的过程还是很顺利的，唯一不顺利的是虚幻4引擎也太大了吧，光下载包都快达到12G，而硬盘需要预留的空间接近40G。</p><h1 id="配置要求"><a href="#配置要求" class="headerlink" title="配置要求"></a>配置要求</h1><p>虚幻4非常吃配置，如果玩绝地求生都不太流畅的电脑，还是不要轻易尝试虚幻4引擎，这可能也是虚幻4这么多年，在国内一直被Unity和Cocos压一头的原因之一吧。</p><h1 id="商店"><a href="#商店" class="headerlink" title="商店"></a>商店</h1><p><img src="/image/v2-cbe1573fb42382c50134cbb01556e986_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>虚幻4提供了一个商店功能，这一点对比于Unity简直好了太多了，Unity独自一人想要制作游戏时基本很难找到整套资源。</p><p>看了一下Epic上面的资源，免费的资源还是比较少的，收费的资源占大多数，如果是一个人制作游戏玩玩的话免费的资源就够了，如果是想要做商用，可能就需要花钱进行购买资源，或者有自己的美术团队。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p><img src="/image/v2-a441e743a0deaaaebbbb57b06df94321_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>在创建工程时，UE4会提供众多模板，几乎包含了现在的主流游戏类别，如果没有你心仪的模板，可以直接创建空白模板。</p><p><img src="/image/v2-1862aa257a14ab66107b2d9e115159bb_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>对于新人来说，肯定是选择创建<strong>蓝图</strong>项目，<strong>初学者内容包</strong>也建议选上，当你的项目创建之后，会给你很多基础的材质纹理和特效。</p><h1 id="导入库"><a href="#导入库" class="headerlink" title="导入库"></a>导入库</h1><p>从商店里面购买的资源都放在了库里面。需要主动点击添加到工程，<strong>由于当前4.25版本才更新不久，所以很多免费的资源只适配到4.24，这里推荐还是下载4.24版本的UE4。</strong></p><p><img src="/image/v2-7ed7dfef3f6c0ee8400ea5c612b0907b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>添加文件后，在内容管理处找到他们的场景文件，双击后经过漫长的导入，第一次应用时可能等了快10分钟吧。</p><p><img src="/image/v2-df828d200b8be1d2beab3b8c9d66f8b4_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>导入场景完成后，点击上面的运行，就可以进入游戏界面。由于之间创建的是第一人称游戏的模板，所以自带了射击功能。</p><p><img src="/image/v2-75eaa95318b30129878e597991041856_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h1><p>一般一个游戏的开发除了模型和音乐资源以及UI外，最重要的就是交互，如果没有交互，那就单单是一个静态场景，在Unity3D中需要自己编写<code>C#</code>脚本进行实现对于角色的控制，而在UE4中，它提供了一个蓝图系统，可以让制作游戏的新人学习成本大幅度下降，你可以将重心放在游戏内容和关卡设计上，而不用再去考虑怎么通过代码实现某项功能。</p><p>蓝图里几乎涵盖了游戏中所有可能用到的交互的事件，比如控制角色行走，造成伤害事件，这些如果是放在其它引擎中要自己写代码实现。</p><p>唯一的缺点就是…蓝图提供的API实在是太多了，如果真的要完全靠蓝图来做游戏，那需要比较熟悉这些API，并且根据蓝图制作出的游戏，性能上肯定比不过用C++脚本写出来的游戏。</p><p><img src="/image/v2-d64760a9a40d852cb570ed1fb4f7f5ba_b.webp" srcset="/img/loading.gif" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/image/v2-2ffaa4ecaf9ced492c5467701a3095d2_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>整个体验下来，就我自己感觉而言，相对于Unity3D引擎，优缺点挺明显的。</p><p>优点：</p><ul><li>自带商场里模型众多，独立制作游戏时不用担心翻遍全网而找不到心仪的资源。</li><li>蓝图系统非常强大，可以实现不编写代码，依靠蓝图就能做出一个完整的游戏。</li><li>官方学习文档十分丰富。</li></ul><p>缺点：</p><ul><li>非常消耗硬盘空间，安装时需要预留快40G的磁盘空间。</li><li>对于电脑配置要求较高，如果配置不好，可能在测试游戏时会非常卡顿。</li><li>自带商场里免费资源还是比较少的，大部分收费资源都不便宜。</li><li>国内使用UE4较少，如果遇到问题可能光百度还无法解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚幻引擎</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个简单易用的制作博客的框架：Hexo</title>
    <link href="/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/"/>
    <url>/2020/05/19/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8%E7%9A%84%E5%88%B6%E4%BD%9C%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%9AHexo/</url>
    
    <content type="html"><![CDATA[<p>学习一项技术的最好方法就是写博客，博客不光可以分享你学到的知识，而且如果你的学习中有什么错误或者纰漏，偶尔也会被路过的大神指出。</p><p>使用Vue或者React搭建一个静态博客是非常简单的事情，但是如果想要搭建一个像知乎这种具有动态更新，还带有评论系统，并且界面还具有自适应，这些就显得不是那么容易。毕竟一个人的精力有限，如果需要面面俱到就需要花上很长的时间。</p><p>很多公司意识到了这些事情，所以推出了非常多的快速搭建博客的框架，大致看了一下，非常多的人都推荐使用Hexo，所以我也想尝试一下使用Hexo搭建博客，是不是真的那么方便。</p><h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><ul><li><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a> (Node.js 版本需不低于 8.10，建议使用 Node.js 10.0 及以上版本)</li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>这两个软件是运行环境，必须要进行安装。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>装好了上面两个运行环境后，直接按住键盘上的<code>Ctrl右边的键</code>+<code>r</code> ，在打开的运行窗口中输入<code>cmd</code>，再在新弹出的窗口中输入<code>npm install -g hexo-cli</code>等待安装完成即可。</p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>到你需要创建项目的文件夹中，打开<code>cmd</code></p><p><img src="/image/v2-b0fca0c8dc063705e70cda5b6aa1e26d_b.jpg" srcset="/img/loading.gif" alt="img"></p><p>在弹出的窗口中输入<code>hexo init 你需要创建的博客名</code>。</p><h1 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h1><p>创建完成后，进入到你创建的文件夹，会看到下面的目录样式。</p><pre><code class="hljs text">.├── _config.yml 网站的配置信息，您可以在此配置大部分的参数。├── package.json 应用程序的信息，如果需要更改需要对node有一定了解├── scaffolds 文章存放的文件夹。├── source 资源文件夹|   ├── _drafts|   └── _posts└── themes 主题文件夹。</code></pre><p>这时还需要再像上面一样打开<code>cmd</code> 输入<code>npm install</code> 回车运行，安装依赖包。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>刚才提到的<code>_config.yml</code>文件中，可以配置大部分的信息，比如网站的标题，描述，关键字。如果有需要的话，可以直接参考官方给出的配置文档。</p><p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置hexo</a></p><p>如果按照上面的步骤，顺利走到了这里，那么继续按照上面的方法打开<code>cmd</code></p><p>输入<code>hexo server</code>，会看到如下图所示</p><p><img src="/image/v2-d7193f1d9bb78df6065e869b2d03f6b6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>将框起来的那部分在浏览器地址栏上进行输入。</p><p><img src="/image/v2-8d39b1b6dd060c0c038e99154a7ff28c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果看到这个界面，恭喜，你的博客框架已经大体搭建完成</p><h1 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h1><p>官方自带的主题不是很符合胃口，我认为使用Hexo搭建博客如果还需要自行敲代码不如直接使用Vue或者React搭建了，所以可以直接使用人家开源出的主题。</p><p><a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>下载完成后直接放在<code>themes</code>文件夹中</p><p><img src="/image/v2-a0b4cfe339bea903b23195102534a226_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>要进行应用需要修改项目根目录中的<code>_config.yml</code>文件中的<code>theme</code>属性，修改为刚才下载的主题文件夹名。</p><p>例如：<code>theme: hexo-theme-fluid</code></p><p>再通过<code>hexo serve</code>运行项目，就可以查看到效果。</p><p><img src="/image/v2-847e34e46aee11dc944de56d5a07a235_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>如果需要对主题进行修改，可以直接进入主题文件夹中找到 <code>_config.yml</code> 文件，修改里面的参数。</p><h1 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h1><p>在项目文件中打开<code>cmd</code>输入命令<code>hexo generate</code> 会看见多出来一个<code>public</code>文件夹，将里面的内容直接发布到自己的服务器上面即可。如果没有自己的服务器，也可以使用GitHub Pages，但是GitHub Pages由于特殊原因，在国内访问速度会比较慢。</p><p>至于GitHub Pages是什么，以及怎么用，可以看这篇~</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Using_Github_pages" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/Using_Github_pages</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h1><p>如果你仅仅只需要使用主题搭建自己的博客，不需要做太多的个性化修改，那么使用Hexo确实是一个非常好的选择，几乎不需要太多的编程知识就可以搭建出一个还不错的博客界面，但是如果你想搭建高度自定义的博客界面，那还是不太推荐使用Hexo框架，主要是EJS这玩意…现在几乎已经不用了。</p><hr><h1 id="6月24日-再更新"><a href="#6月24日-再更新" class="headerlink" title="6月24日 再更新"></a>6月24日 再更新</h1><p>我自己尝试做网站的时候遇到了客户端渲染和服务器渲染的问题，简单的说Vue和React搭建出的单页面应用都为客户端渲染，不利于SEO，而Hexo就完全打包成了一个静态页面…有利于SEO，至于使用Vue的服务器渲染可以看这篇：</p><p><a href="https://zhuanlan.zhihu.com/p/149981401" target="_blank" rel="noopener">Vue服务器渲染优秀项目</a></p><p>总的来说，如果你想将博客布置到GitHub Pages那么Hexo优于使用Vue搭建的页面，因为它更加利于SEO。</p>]]></content>
    
    
    <categories>
      
      <category>blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>公众号自定义样式，令人惊叹的文章编辑器</title>
    <link href="/2020/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2020/05/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A0%B7%E5%BC%8F%EF%BC%8C%E4%BB%A4%E4%BA%BA%E6%83%8A%E5%8F%B9%E7%9A%84%E6%96%87%E7%AB%A0%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>最近在弄自己的公众号，虽然关注的人就只有我自己…都是眼泪啊！</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a><strong>案例</strong></h1><p>众所周知，一些比较大的公众号推送的文章都是花里胡哨的。尤其是一些介绍自己产品的公众号，比如说分割线样式：</p><p><img src="/image/v2-7996702b242cba19da35ef902f957c98_720w.png" srcset="/img/loading.gif" alt="img"></p><p>再比如说这种背景和边框：</p><p><img src="/image/v2-2ad064822e44e65f74d2a35d610c93db_720w.png" srcset="/img/loading.gif" alt="img"></p><p>再比如：</p><p><img src="/image/v2-5bcf323d6ebcd5bb26b1f2e9f80461e0_720w.png" srcset="/img/loading.gif" alt="img"></p><p>这种一眼看上去就有很强的视觉冲击的文字，而我自己的文章呢？</p><p><img src="/image/v2-48b8452c1274b5502bdae90df7c9a177_720w.png" srcset="/img/loading.gif" alt="img"></p><p>我的天，黑白的性冷风，突然感觉low爆了，不过我的文章主要是想以内容为主，如果太过于花哨反而会影响阅读体验。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a><strong>实践</strong></h1><p>为了实现上面的那些分割线效果，我还专门去搜索了下这些样式是怎么制作的，结果搜出来的结果都是讲的如何<strong>用编辑器制作样式！然而我想知道的是编辑器具体是怎么制作样式的。</strong></p><p>没有办法搜索不到就只有自己动手研究了，首先用我们强大的Chrome浏览器，来到公众号文章编辑界面，随便从其他的地方复制一个样式：</p><p><img src="/image/v2-7ec49146c4134663c96fd9d87b4ddd01_720w.png" srcset="/img/loading.gif" alt="img"></p><p>就用它开刀好了，按F12打开开发者模式，选中这玩意。</p><p><img src="/image/v2-067e8083ba2e2ec27512c7d6769b9816_720w.png" srcset="/img/loading.gif" alt="img"></p><p>发现开发者工具上面有个<code>section</code>标签，等会，你难道不是一个普通的文字编辑器？</p><p><img src="/image/v2-b0efb1b79920a5f6cfddf318f9324969_720w.png" srcset="/img/loading.gif" alt="img"></p><p>还真不是，它居然是用<code>iframe</code>从外面引入的。</p><p>那么接下来尝试复制一下上面的那个<code>section</code>标签试试</p><p><img src="/image/v2-b9b48deb59c3e7e578e48b568e924554_720w.png" srcset="/img/loading.gif" alt="img"></p><p><img src="/image/v2-ed3e2a322f405140c7c152f4fa47f4a6_720w.png" srcset="/img/loading.gif" alt="img"></p><p>变成两个了！谜题解开了，样式的制作就是通过section标签，然后加上<strong>行内样式</strong>，就能制作出这种效果，那么知道原理后，我们自己动手实现上面的那个样式：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://mmbiz.qpic.cn/sz_mmbiz_png/YMeJJzp9Dn2IxGfxCmDyY0OLaLbWkAUk37JCybKOFoPx52vfAia1RocLNOX31c0icJgGbUOica990Hox44QI9pSCA/?wx_fmt=png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background-color: red;height: 40px;line-height: 40px;padding-left: 10px;"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"margin: 0;"</span>&gt;</span>这里是一些文字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span></code></pre><p>再往浏览器上面一抛</p><p><img src="/image/v2-69085662ffb4e23561b7fea6316497d2_720w.png" srcset="/img/loading.gif" alt="img"></p><p>选中标签右键点击<code>Edit as HTML</code>就可以直接对网页上的标签进行编辑了。</p><p><img src="/image/v2-1ec352622828e38d089ecf3d3add117b_720w.png" srcset="/img/loading.gif" alt="img"></p><p>好了，可以看出样式正确的显示出来了，然后尝试保存后再进去看一下，没问题，样式还在，根据这种方法，就可以实现样式的自定义了。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a><strong>写在最后</strong></h1><p>什么？你看到这里然后你说从那个性冷淡风下面开始你就不知道我在讲什么了？你问我iframe，section是啥，还有后面那段代码为什么能改变样式？</p><p>这些属于前端开发的内容了，一两句也说不清楚，如果有兴趣可以去学习一下前端开发相关的知识。</p><p>研究了这么多，还是推荐直接使用市面上现有的编辑器，毕竟自己制作样式，还是挺麻烦的，而且辛苦制作出的样式，还不一定有别人的好看。</p><ul><li>135编辑器</li><li>新媒体管家</li></ul>]]></content>
    
    
    <categories>
      
      <category>微信公众号</category>
      
    </categories>
    
    
    <tags>
      
      <tag>样式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript：充满玄学的this指向，真的有点难</title>
    <link href="/2020/05/07/JavaScript%EF%BC%9A%E5%85%85%E6%BB%A1%E7%8E%84%E5%AD%A6%E7%9A%84this%E6%8C%87%E5%90%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%9C%89%E7%82%B9%E9%9A%BE/"/>
    <url>/2020/05/07/JavaScript%EF%BC%9A%E5%85%85%E6%BB%A1%E7%8E%84%E5%AD%A6%E7%9A%84this%E6%8C%87%E5%90%91%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%9C%89%E7%82%B9%E9%9A%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript中的this可能是当年设计的时候存在着设计缺陷，在ES6中能使用<code>()=&gt;</code>这个高端的箭头函数就尽量使用箭头函数，箭头函数在其他语言中还有个高大上的名字<code>Lambda</code>表达式。</p><p><strong>PS：</strong><code>nodejs</code>环境中没有<code>window</code>对象</p><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>对于this的指向，我的理解就是记住一句话，<strong>如果没有使用apply和call还有箭头函数的情况下，this指向最后一次调用它的对象，如果最后一次调用它的是函数，则在严格模式指向<code>undefined</code>非严格模式下指向全局变量<code>window</code></strong>。</p><p>下面的例子全部为非严格模式</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span></code></pre><p>上面的例子应该很清晰，因为最后一次调用<code>b</code>方法的是<code>obj</code>这个对象，而对象<code>obj</code>里面a的值为2，所以这个例子会输出2。</p><p>那么我们加大一下难度看下面的例子</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-keyword">var</span> t = obj.b;<span class="hljs-built_in">console</span>.log(t());<span class="hljs-built_in">console</span>.log(obj.b());<span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-built_in">console</span>.log(t === obj.b);</code></pre><p>这个时候我们新加入一个变量<code>t</code>，将<code>b</code>方法赋值给<code>t</code>，大家思考一下这个时候函数<code>t</code>会输出什么。</p><p>神奇的事情发生了</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(t()); <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(t === obj.b); <span class="hljs-comment">//true</span></code></pre><p>函数<code>t</code>输出的结果是1。</p><p>因为这次调用方法的是函数<code>t</code>而他的对象为<code>window</code>，因为对象<code>window</code>上的<code>a</code>值为1，故<code>t</code>的最后输出结果为1。</p><p>下面这个例子也同样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;    <span class="hljs-built_in">console</span>.log(fun());  &#125;&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>因为调用<code>fun</code>方法的是方法<code>b</code>，这时最后一次调用<code>fun</code>的不为对象，则this指向全局变量<code>window</code></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul><li>箭头函数会捕获其所在上下文的 <code>this</code> 值，作为自己的 <code>this</code> 值</li><li>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 <code>undefined</code>。</li></ul><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>在<code>ES5</code>语法中使用this有时候会很难以预测this的指向，从而产生bug，这个问题到了现在框架时代大量通过类进行封装时变得尤为明显。如果学习过react，就会发现将父组件的函数传递给子组件使用时，this指向总是个头疼的问题。</p><p>虽然使用call,apply,bind可以解决这部分痛点，但是需要额外的代码，不仅增大了工作量，而且增加了维护成本。</p><h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//1</span></code></pre><p>因为b是通过箭头函数进行声明，则它的this就指向了<code>obj</code>的this，而<code>obj</code>的this就是全局变量<code>window</code></p><h2 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><p>因为箭头函数会找上下文的this，所以这里找到的上文就是方法<code>b</code>的this，即为对象<code>obj</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>箭头函数是没有this的，这个时候方法<code>fun</code>就逐层寻找this，最终找到的是对象<code>obj</code>的this</p><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h1><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><ol><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p></li><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p></li><li><p>bind除了返回是函数以外，它的参数和call一样。</p></li></ol><h2 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>this是不能改变的，所以对箭头函数使用call,apply,bind是没有效果的</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun.call(a));  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;<span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">3</span>,&#125;;obj.b.call(obj1); <span class="hljs-comment">//3</span></code></pre><p>箭头函数的this虽然不能被改变，但是可以改变它上下文的this。</p><h1 id="一大堆题"><a href="#一大堆题" class="headerlink" title="一大堆题"></a>一大堆题</h1><p>既然上面都讲了那么多，那么我们来看一下下面的题：</p><p>不知道是哪个大神想的题目，反正就是不让人好过。┓( ´∀` )┏</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person = &#123;  age: <span class="hljs-number">20</span>,  getAge() &#123;    <span class="hljs-keyword">var</span> age = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; <span class="hljs-comment">//20</span>  &#125;&#125;;<span class="hljs-built_in">console</span>.log(age, age * <span class="hljs-number">2</span>); <span class="hljs-comment">//10 20</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-keyword">var</span> b = person.getAge;<span class="hljs-built_in">console</span>.log(b()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge.bind(person))()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((person.getAge, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((person.getAge = person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call(person)); <span class="hljs-comment">//20</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">40</span>;  <span class="hljs-built_in">console</span>.log(person.getAge());&#125;getAge2(); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//node环境和浏览器环境不一样，因为浏览器环境中有window对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">50</span>;  <span class="hljs-keyword">this</span>.getAge4 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//50</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge3().getAge4());<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge4</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">60</span>;  <span class="hljs-keyword">this</span>.getAge5 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//60</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge4().getAge5()); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-keyword">var</span> age2 = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person2 = &#123;  age2: <span class="hljs-number">20</span>,  getAge2: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> age2 = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age2;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(person2.getAge2.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person2.getAge2.call(person2)); <span class="hljs-comment">//10</span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看了很多篇文章，对那些文章进行了总结，我也不能说我百分百懂了this，如果有错误的地方，欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>this指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Taro开发微信养花小程序</title>
    <link href="/2020/05/07/%E4%BD%BF%E7%94%A8Taro%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%BB%E8%8A%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <url>/2020/05/07/%E4%BD%BF%E7%94%A8Taro%E5%BC%80%E5%8F%91%E5%BE%AE%E4%BF%A1%E5%85%BB%E8%8A%B1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Taro简介"><a href="#Taro简介" class="headerlink" title="Taro简介"></a>Taro简介</h1><p>Taro是一套遵循 React 语法规范的<strong>多端开发</strong>解决方案。</p><p>使用Taro，只需要书写一套代码，再通过 Taro 的编译工具，将源代码分别编译出可以在不同端（微信 / 京东 / 百度 / 支付宝 / 字节跳动 小程序、快应用、H5、React-Native 等）运行的代码。</p><p>注意：<strong>如果不需要进行多端开发并且需要对小程序深度定制，建议还是直接使用原生开发。</strong></p><h1 id="安装Taro"><a href="#安装Taro" class="headerlink" title="安装Taro"></a>安装Taro</h1><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install -g @tarojs/cli</code></pre><h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><pre><code class="hljs ebnf"><span class="hljs-attribute">taro init myApp</span></code></pre><p>模板拉取完毕后会给你一些选项，根据自身喜好选择就行了，我这里使用TypeScript。</p><p><img src="/image/v2-6f735d69e4c55ab67eb0ab09edc0f877_b.png" srcset="/img/loading.gif" alt="img"></p><p>其中因为node-sass的原因，运行npm install时可能会报错。这个时候就将npm换成淘宝镜像应该就可以解决。</p><pre><code class="hljs arduino">npm <span class="hljs-built_in">config</span> <span class="hljs-built_in">set</span> registry https:<span class="hljs-comment">//registry.npm.taobao.org</span></code></pre><h1 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h1><p>经过漫长的等待后，你还需要准备微信开发者工具，因为必须要通过开发者工具进行预览。</p><p>打开工程目录下的package.json，可以看到下面的命令就是构建不同平台的小程序。使用方法是在前面加上npm run或者yarn比如预览微信小程序就是npm run dev:weapp </p><pre><code class="hljs 1c"><span class="hljs-string">"scripts"</span>: &#123;  <span class="hljs-string">"build:weapp"</span>: <span class="hljs-string">"taro build --type weapp"</span>,  <span class="hljs-string">"build:swan"</span>: <span class="hljs-string">"taro build --type swan"</span>,  <span class="hljs-string">"build:alipay"</span>: <span class="hljs-string">"taro build --type alipay"</span>,  <span class="hljs-string">"build:tt"</span>: <span class="hljs-string">"taro build --type tt"</span>,  <span class="hljs-string">"build:h5"</span>: <span class="hljs-string">"taro build --type h5"</span>,  <span class="hljs-string">"build:rn"</span>: <span class="hljs-string">"taro build --type rn"</span>,  <span class="hljs-string">"build:qq"</span>: <span class="hljs-string">"taro build --type qq"</span>,  <span class="hljs-string">"build:quickapp"</span>: <span class="hljs-string">"taro build --type quickapp"</span>,  <span class="hljs-string">"dev:weapp"</span>: <span class="hljs-string">"npm run build:weapp -- --watch"</span>,  <span class="hljs-string">"dev:swan"</span>: <span class="hljs-string">"npm run build:swan -- --watch"</span>,  <span class="hljs-string">"dev:alipay"</span>: <span class="hljs-string">"npm run build:alipay -- --watch"</span>,  <span class="hljs-string">"dev:tt"</span>: <span class="hljs-string">"npm run build:tt -- --watch"</span>,  <span class="hljs-string">"dev:h5"</span>: <span class="hljs-string">"npm run build:h5 -- --watch"</span>,  <span class="hljs-string">"dev:rn"</span>: <span class="hljs-string">"npm run build:rn -- --watch"</span>,  <span class="hljs-string">"dev:qq"</span>: <span class="hljs-string">"npm run build:qq -- --watch"</span>,  <span class="hljs-string">"dev:quickapp"</span>: <span class="hljs-string">"npm run build:quickapp -- --watch"</span>&#125;,</code></pre><p>编译完成后会出现一个dist文件夹，我们将工程文件夹导入到微信开发者工具中。 如果导入成功就会看到下面的界面：</p><p><img src="/image/v2-9f95a15fefdb30dc3a45d66d2953d83e_b.png" srcset="/img/loading.gif" alt="img"></p><p>我们再次引入Taro-ui。这个是UI组件库，有些组件如果自己去写的话不仅非常消耗时间，而且可能会有BUG，所以这个时候就需要选用UI组件库。</p><p><a href="https://github.com/NervJS/taro-uigithub.com" target="_blank" rel="noopener">https://github.com/NervJS/taro-uigithub.com</a></p><p>引入</p><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> taro-ui</code></pre><h1 id="正式开发"><a href="#正式开发" class="headerlink" title="正式开发"></a>正式开发</h1><p>由于想要开发的代码逻辑还是比较多的，所以这里就不一步一步的讲解代码。</p><p><img src="/image/v2-9dad95b98abfa221827866e965591e11_b.png" srcset="/img/loading.gif" alt="img"></p><h1 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h1><p>先简单的搭出这样一个界面，其中植物有3种状态，一种是<strong>需要浇水</strong>，一种是<strong>正在成长</strong>，最后一种是<strong>已经枯萎</strong>。同时还设计了一个添加植物的按钮，通过这个按钮，能够新增植物。并且植物的数据是从数据库中进行读取，以保证下次打开小程序后这些数据仍然存在。</p><p><img src="/image/v2-502cdcdd83bfd5c6091b600f3e246d99_b.gif" srcset="/img/loading.gif" alt="img"></p><p>搭建中的界面</p><h1 id="植物管理"><a href="#植物管理" class="headerlink" title="植物管理"></a>植物管理</h1><p>由于我这里使用了TypeScript我就直接创建了一个植物类。</p><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> Flower &#123;  flowerName: <span class="hljs-built_in">string</span>  <span class="hljs-comment">// 植物名字</span>  overTime: <span class="hljs-built_in">number</span>    <span class="hljs-comment">// 浇水间隔</span>  imgUrl: <span class="hljs-built_in">string</span>      <span class="hljs-comment">// 植物图片地址</span>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">flowerName: <span class="hljs-built_in">string</span>, overTime: <span class="hljs-built_in">number</span>, imgUrl: <span class="hljs-built_in">string</span></span>) &#123;    <span class="hljs-keyword">this</span>.flowerName = flowerName    <span class="hljs-keyword">this</span>.overTime = overTime    <span class="hljs-keyword">this</span>.imgUrl = imgUrl  &#125;&#125;</code></pre><p>然后实例化这个类，并且存到数组中供页面调用。</p><pre><code class="hljs routeros">import Flower <span class="hljs-keyword">from</span> <span class="hljs-string">'./Flower'</span>const flowers: Flower[] = []flowers.push(new Flower(<span class="hljs-string">'栀子花'</span>, 3600, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'丁香花'</span>, 1200, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'茉莉花'</span>, 2400, <span class="hljs-string">'图片地址'</span>))flowers.push(new Flower(<span class="hljs-string">'仙人掌'</span>, 3600, <span class="hljs-string">'图片地址'</span>))<span class="hljs-builtin-name">export</span><span class="hljs-built_in"> default </span>flowers</code></pre><h1 id="后端和数据库"><a href="#后端和数据库" class="headerlink" title="后端和数据库"></a>后端和数据库</h1><p>由于我本人对后端内容不是太熟悉，所以大体搭建了一个数据库，意思一下。</p><p>这里我选用的Spring boot搭建后端，mySql作为数据库。如果是前端搭建数据库，还是推荐更适合前端的Nodejs和MongoDB。</p><p>首先我们需要一个数据表：已经添加的植物表。那么它应该就具有：名称，添加时间，上次浇水时间，浇水间隔时间这些属性。</p><h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>Taro对小程序的网络请求API进行了Promise封装，具体可以参考官方文档：</p><p><a href="https://nervjs.github.io/taro/docs/apis/network/request/request/nervjs.github.io" target="_blank" rel="noopener">https://nervjs.github.io/taro/docs/apis/network/request/request/nervjs.github.io</a></p><p>这里我们再次将Taro提供的api进行封装，封装的原因是因为如果我们想要引入其他的网络请求库，就不用再去页面中用到的地方一个一个的更改api，直接修改封装文件中的api就可以了。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> Taro <span class="hljs-keyword">from</span> <span class="hljs-string">"@tarojs/taro"</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ajax</span>(<span class="hljs-params">url = <span class="hljs-string">""</span>, params = &#123;&#125;, type = <span class="hljs-string">"GET"</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> promise;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (type.toUpperCase() === <span class="hljs-string">"GET"</span>) &#123;      <span class="hljs-keyword">let</span> paramsStr = <span class="hljs-string">""</span>;      <span class="hljs-built_in">Object</span>.keys(params).forEach(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;        paramsStr += key + <span class="hljs-string">"="</span> + params[key] + <span class="hljs-string">"&amp;"</span>;      &#125;);      <span class="hljs-keyword">if</span> (paramsStr) &#123;        paramsStr = paramsStr.substr(<span class="hljs-number">0</span>, paramsStr.lastIndexOf(<span class="hljs-string">"&amp;"</span>));      &#125;      url += <span class="hljs-string">"?"</span> + paramsStr;      <span class="hljs-comment">//发起GET请求</span>      promise = Taro.request(&#123;        url: url,        header: &#123;<span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>&#125;,      &#125;);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type.toUpperCase() === <span class="hljs-string">"POST"</span>) &#123;      promise = Taro.request(&#123;        method: <span class="hljs-string">"POST"</span>,        url: url,        data: params,        header: &#123;<span class="hljs-string">"content-type"</span>: <span class="hljs-string">"application/json"</span>&#125;      &#125;);    &#125;    promise.then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;      resolve(response.data);    &#125;).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;      reject(error);    &#125;);  &#125;);&#125;</code></pre><p>到这一步，我们已经完成了数据库和后端的配置，剩下的就是需要在前端进行调用这些接口。</p><h1 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h1><p>虽然组件之间的参数传递并不复杂，但是我这里为了方便，还是使用redux和redux-thunk。</p><p>使用 Redux | Taro 文档nervjs.github.io</p><p><a href="https://github.com/reduxjs/redux-thunkgithub.com" target="_blank" rel="noopener">https://github.com/reduxjs/redux-thunkgithub.com</a></p><p>由于我对redux-thunk不是很熟，所以又去翻找了一下资料，在redux和后端数据这里花费了不少时间。</p><p><img src="/image/v2-fc800fd70f2bfc6b700e6b4b09aa0d31_b.gif" srcset="/img/loading.gif" alt="img"></p><p>从上面的图可以看到，这里已经可以添加花了，但是由于每次点击添加不仅要向后端发送请求将点击的花添加到数据库，并且还需要将花的列表进行重新请求。</p><p>剩下的就是实现浇花功能了，该功能的实现必须也要后端配合实现，实现过程就是当你<strong>点击浇水的时候，将数据库中对应的花的上一次浇水时间改成当前时间。</strong>这个的实现几乎全是由后端实现，跟前端没啥关系，最多只是调用一下接口将点击浇水的花的ID传送过去。</p><p>最后增加删除枯萎的花的功能，也是需要后端提供接口。</p><p><img src="/image/v2-de5dfd4f7d2d85936c7094d65e37ec6c_b.gif" srcset="/img/loading.gif" alt="img"></p><p>到这里基本上小程序就已经开发完成了，但是不知道是因为我的后端传输数据很慢还是其它的原因，可以看到点击删除后会卡一会。</p><p>之后我调整了一下代码格式，因为Taro创建工程的时候会自动集成ESLint代码检测，再次尝试添加删除植物，发现这次没有上面那么卡顿了，所以也不知道之前是哪儿出现了问题。</p><p><img src="/image/v2-dd399d409804cc37c9b76e53c745a946_b.gif" srcset="/img/loading.gif" alt="img"></p><p>可以看到，还是比较流畅</p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="/image/v2-b679caf5c262af8a528ebeac5a38d42f_720w.gif" srcset="/img/loading.gif" alt="img"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>整个项目的难点在于redux之间的数据传递，还有时间的换算，除此之外也没有什么难点了，虽然看似简单的一个小程序，但是可以很好的理解redux。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Taro</tag>
      
      <tag>小程序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>老生常谈的this</title>
    <link href="/2020/05/07/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84this/"/>
    <url>/2020/05/07/%E8%80%81%E7%94%9F%E5%B8%B8%E8%B0%88%E7%9A%84this/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>JavaScript中的this可能是当年设计的时候存在着设计缺陷，在ES6中能使用<code>()=&gt;</code>这个高端的箭头函数就尽量使用箭头函数，箭头函数在其他语言中还有个高大上的名字<code>Lambda</code>表达式。</p><p><strong>PS：</strong><code>nodejs</code>环境中没有<code>window</code>对象</p><h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>对于this的指向，我的理解就是记住一句话，<strong>如果没有使用apply和call还有箭头函数的情况下，this指向最后一次调用它的对象，如果最后一次调用它的是函数，则在严格模式指向<code>undefined</code>非严格模式下指向全局变量<code>window</code></strong>。</p><p>下面的例子全部为非严格模式</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span></code></pre><p>上面的例子应该很清晰，因为最后一次调用<code>b</code>方法的是<code>obj</code>这个对象，而对象<code>obj</code>里面a的值为2，所以这个例子会输出2。</p><p>那么我们加大一下难度看下面的例子</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-keyword">var</span> t = obj.b;<span class="hljs-built_in">console</span>.log(t());<span class="hljs-built_in">console</span>.log(obj.b());<span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-built_in">console</span>.log(t === obj.b);</code></pre><p>这个时候我们新加入一个变量<code>t</code>，将<code>b</code>方法赋值给<code>t</code>，大家思考一下这个时候函数<code>t</code>会输出什么。</p><p>神奇的事情发生了</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(t()); <span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//2</span><span class="hljs-built_in">console</span>.log(t() === obj.b()); <span class="hljs-comment">//false</span><span class="hljs-built_in">console</span>.log(t === obj.b); <span class="hljs-comment">//true</span></code></pre><p>函数<code>t</code>输出的结果是1。</p><p>因为这次调用方法的是函数<code>t</code>而他的对象为<code>window</code>，因为对象<code>window</code>上的<code>a</code>值为1，故<code>t</code>的最后输出结果为1。</p><p>下面这个例子也同样</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;    <span class="hljs-built_in">console</span>.log(fun());  &#125;&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>因为调用<code>fun</code>方法的是方法<code>b</code>，这时最后一次调用<code>fun</code>的不为对象，则this指向全局变量<code>window</code></p><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><ul><li>箭头函数会捕获其所在上下文的 <code>this</code> 值，作为自己的 <code>this</code> 值</li><li>箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 <code>undefined</code>。</li></ul><h2 id="解决的痛点"><a href="#解决的痛点" class="headerlink" title="解决的痛点"></a>解决的痛点</h2><p>在<code>ES5</code>语法中使用this有时候会很难以预测this的指向，从而产生bug，这个问题到了现在框架时代大量通过类进行封装时变得尤为明显。如果学习过react，就会发现将父组件的函数传递给子组件使用时，this指向总是个头疼的问题。</p><p>虽然使用call,apply,bind可以解决这部分痛点，但是需要额外的代码，不仅增大了工作量，而且增加了维护成本。</p><h2 id="简单题目"><a href="#简单题目" class="headerlink" title="简单题目"></a>简单题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(obj.b()); <span class="hljs-comment">//1</span></code></pre><p>因为b是通过箭头函数进行声明，则它的this就指向了<code>obj</code>的this，而<code>obj</code>的this就是全局变量<code>window</code></p><h2 id="中等题目"><a href="#中等题目" class="headerlink" title="中等题目"></a>中等题目</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><p>因为箭头函数会找上下文的this，所以这里找到的上文就是方法<code>b</code>的this，即为对象<code>obj</code></p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;obj.b(); <span class="hljs-comment">//1</span></code></pre><p>箭头函数是没有this的，这个时候方法<code>fun</code>就逐层寻找this，最终找到的是对象<code>obj</code>的this</p><h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call,apply,bind"></a>call,apply,bind</h1><blockquote><p>apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数</p><p>bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。</p></blockquote><ol><li><p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.apply(A, arguments);即A对象应用B对象的方法。</p></li><li><p>call：调用一个对象的一个方法，用另一个对象替换当前对象。例如：B.call(A, args1,args2);即A对象调用B对象的方法。</p></li><li><p>bind除了返回是函数以外，它的参数和call一样。</p></li></ol><h2 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>this是不能改变的，所以对箭头函数使用call,apply,bind是没有效果的</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun.call(a));  &#125;,&#125;;obj.b(); <span class="hljs-comment">//2</span></code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> obj = &#123;  a: <span class="hljs-number">2</span>,  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">var</span> fun = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.a;    &#125;;    <span class="hljs-built_in">console</span>.log(fun());  &#125;,&#125;;<span class="hljs-keyword">var</span> obj1 = &#123;  a: <span class="hljs-number">3</span>,&#125;;obj.b.call(obj1); <span class="hljs-comment">//3</span></code></pre><p>箭头函数的this虽然不能被改变，但是可以改变它上下文的this。</p><h1 id="一大堆题"><a href="#一大堆题" class="headerlink" title="一大堆题"></a>一大堆题</h1><p>既然上面都讲了那么多，那么我们来看一下下面的题：</p><p>不知道是哪个大神想的题目，反正就是不让人好过。┓( ´∀` )┏</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> age = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person = &#123;  age: <span class="hljs-number">20</span>,  getAge() &#123;    <span class="hljs-keyword">var</span> age = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age; <span class="hljs-comment">//20</span>  &#125;&#125;;<span class="hljs-built_in">console</span>.log(age, age * <span class="hljs-number">2</span>); <span class="hljs-comment">//10 20</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-keyword">var</span> b = person.getAge;<span class="hljs-built_in">console</span>.log(b()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((<span class="hljs-number">1</span>, person.getAge.bind(person))()); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log((person.getAge, person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log((person.getAge = person.getAge)()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person.getAge.call(person)); <span class="hljs-comment">//20</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge2</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">40</span>;  <span class="hljs-built_in">console</span>.log(person.getAge());&#125;getAge2(); <span class="hljs-comment">//20</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//node环境和浏览器环境不一样，因为浏览器环境中有window对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge3</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">50</span>;  <span class="hljs-keyword">this</span>.getAge4 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//50</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge3().getAge4());<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge4</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">this</span>.age = <span class="hljs-number">60</span>;  <span class="hljs-keyword">this</span>.getAge5 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(person.getAge.call(<span class="hljs-keyword">this</span>)); <span class="hljs-comment">//60</span>  &#125;;&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> getAge4().getAge5()); <span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">//10</span><span class="hljs-keyword">var</span> age2 = <span class="hljs-number">10</span>;<span class="hljs-keyword">var</span> person2 = &#123;  age2: <span class="hljs-number">20</span>,  getAge2: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">var</span> age2 = <span class="hljs-number">30</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age2;  &#125;&#125;;<span class="hljs-built_in">console</span>.log(person2.getAge2.call()); <span class="hljs-comment">//10</span><span class="hljs-built_in">console</span>.log(person2.getAge2.call(person2)); <span class="hljs-comment">//10</span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>看了很多篇文章，对那些文章进行了总结，我也不能说我百分百懂了this，如果有错误的地方，欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>this指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>unity3D复刻保卫萝卜</title>
    <link href="/2020/05/04/unity3D%E5%A4%8D%E5%88%BB%E4%BF%9D%E5%8D%AB%E8%90%9D%E5%8D%9C/"/>
    <url>/2020/05/04/unity3D%E5%A4%8D%E5%88%BB%E4%BF%9D%E5%8D%AB%E8%90%9D%E5%8D%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>上次那个快乐鸟-html版似乎反响还不错，看来大家对游戏制作还蛮感兴趣的…那么这次我要搬出我前年用unity3D复刻的保卫萝卜。</p><p>因为年份太过于久远了，所以具体代码就不进行分析了，主要是我忘了（狗头），研究前端后就再也没有碰过unity3D。</p></blockquote><p>视频在这里：</p><p><a href="https://www.bilibili.com/video/BV1HW411d7DMwww.bilibili.com" target="_blank" rel="noopener">unity3D复刻保卫萝卜</a></p><p>当时参照了siki学院的思路，然后自己独立进行一些加工将它完成了，如果有兴趣的朋友可以直接在siki学院上面搜索一下…</p><p>大概说一下自己当时独立加工的点的实现方式：</p><p><img src="/image/v2-678267ad3758d59e1021cd1fd19056b3_720w.png" srcset="/img/loading.gif" alt="img"></p><h1 id="地图编辑器"><a href="#地图编辑器" class="headerlink" title="地图编辑器"></a>地图编辑器</h1><p>将屏幕分为 8*12 个格子，判断鼠标点击时最近的格子，通过视频上面也可以看出即使是没有点在格子的正中部分，依然可以将那一格进行点亮。当地图编辑完毕时点击保存，就将该地图信息，记录在CSV中，通过CSV进行导入。</p><p>CSV有个最大的好处就是可以通过Excel打开，如果是用json存取数据，就没有CSV展现的数据那么清晰。</p><h1 id="核心算法"><a href="#核心算法" class="headerlink" title="核心算法"></a>核心算法</h1><p>通过计算出每个格子中心点的坐标，让怪物沿着已经设定好的路径点通过 Translat 进行移动，如果当怪物离某个路径点的距离小于某值，则让它朝着下一个点进行移动，如果已经达到终点，则将怪物的渲染关闭。搜寻怪物逻辑即将所有怪物放在一个数组中，先遍历这个数组，然后判断怪物是否在塔的攻击范围中，如果在塔的攻击范围中，则将炮塔的目标设置为当前怪物。</p><h1 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h1><p>unity生成和销毁实例跟前端生成Dom一样，是十分消耗性能的，所以这就涉及到实例的复用。意思就是当怪物“死亡”时，其实不进行销毁，而仅仅是将怪物的渲染关闭，如果下次需要使用，则对这些事例重新进行初始化。就跟前端将<code>display</code>设置为<code>none</code>一样。</p><p>整个项目的实现难度并不难，但是里面包含的点非常多，包括UI，动画，对象池，数据的本地存取等，很适合作为初学者项目。</p>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏设计</tag>
      
      <tag>unity3d</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-element-admin npm install报错</title>
    <link href="/2020/05/04/vue-element-admin%20npm%20install%E6%8A%A5%E9%94%99/"/>
    <url>/2020/05/04/vue-element-admin%20npm%20install%E6%8A%A5%E9%94%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近看到<a href="http://panjiachen.github.io/vue-element-admin" target="_blank" rel="noopener">vue-element-admin</a>后台模板不错，于是准备研究一下，结果进去就吃了个闭门羹，npm install各种报错。</p></blockquote><h1 id="我遇到的错误"><a href="#我遇到的错误" class="headerlink" title="我遇到的错误"></a>我遇到的错误</h1><p><code>enoent undefined ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.git</code></p><p><img src="/image/v2-daea995e8644bf9c9e37fc65e754b916_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs shell">npm ERR! code ENOENTnpm ERR! syscall spawn gitnpm ERR! path gitnpm ERR! errno -4058npm ERR! enoent Error while executing:npm ERR! enoent undefined ls-remote -h -t ssh://git@github.com/sohee-lee7/Squire.gitnpm ERR! enoentnpm ERR! enoentnpm ERR! enoent spawn git ENOENTnpm ERR! enoent This is related to npm not being able to find a file.npm ERR! enoent</code></pre><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>需要安装git，并且配置环境变量<code>C:\Program Files\Git\bin</code>（具体根据自身电脑上的git安装目录确定）。</p><h1 id="官方提到的错误"><a href="#官方提到的错误" class="headerlink" title="官方提到的错误"></a>官方提到的错误</h1><p><img src="/image/v2-7964f6c2416a7cccd1fc956b971fbe52_720w.jpg" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs shell">npm ERR! code ELIFECYCLEnpm ERR! errno 1npm ERR! node-sass@4.14.0 postinstall: `node scripts/build.js`npm ERR! Exit status 1npm ERR!npm ERR! Failed at the node-sass@4.14.0 postinstall script.npm ERR! This is probably not a problem with npm. There is likely additional logging output above.npm ERR! A complete log of this run can be found in:npm ERR!     C:\Users\Administrator\AppData\Roaming\npm-cache\_logs\2020-05-04T08_05_47_402Z-debug.log</code></pre><ul><li><p>官方提出的错误，node-sass经常性报错，经尝试使用淘宝源可以成功安装</p></li><li><p>之前在自己的项目中使用node-sass的时候使用yarn也能成功进行安装</p></li></ul><p>永久更换淘宝源</p><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org</code></pre>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心血来潮：做一个网页游戏，飞机大战</title>
    <link href="/2020/05/04/%E5%BF%83%E8%A1%80%E6%9D%A5%E6%BD%AE%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%EF%BC%8C%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"/>
    <url>/2020/05/04/%E5%BF%83%E8%A1%80%E6%9D%A5%E6%BD%AE%EF%BC%9A%E5%81%9A%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E6%B8%B8%E6%88%8F%EF%BC%8C%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h1><p>体验地址：<a href="https://qflyb.github.io/airplanewar/" target="_blank" rel="noopener">https://qflyb.github.io/airplanewar/</a></p><p>飞机大战小游戏主体还是比较简单的，但是看似简单的外壳下面有着很多细节。如果要将细节做到极致，那需要花大量的功夫，我这里只是大体实现了飞机大战。</p><h2 id="体验地址"><a href="#体验地址" class="headerlink" title="体验地址"></a><strong>体验地址</strong></h2><p>整个游戏是使用cocos实现，先看一下游戏画面截图：</p><p><img src="/image/v2-925afa52377468925f88c892cccf7a54_720w.gif" srcset="/img/loading.gif" alt="img"></p><p>这篇文章不准备针对所有代码去讲解，只挑选制作过程中印象比较深的踩坑之处，代码都是用的TypeScript，TypeScript在JavaScript的基础上面加了很多限制，那么为什么还要使用TypeScript？因为TypeScript的类，更像Java，C#这种语言，用着更顺手一些。</p><h2 id="飞机的移动"><a href="#飞机的移动" class="headerlink" title="飞机的移动"></a><strong>飞机的移动</strong></h2><h2 id="玩家飞机"><a href="#玩家飞机" class="headerlink" title="玩家飞机"></a><strong>玩家飞机</strong></h2><p>玩家飞机操控根据上图也能看出来，是依据触摸屏幕的点进行判断，cocos里面提供了一个<code>cc.Node.EventType.TOUCH_MOVE</code>方法，可以在监听玩家手指在屏幕上面滑动。同时还提供了<code>getPreviousLocation</code>可以获取到上一帧手指所在的位置，而<code>getLocation</code>可以获取到当前帧手指所在的位置，然后通过两帧位置的差值，再将飞机的位置减去这个差值，就可以实现飞机的移动。</p><pre><code class="hljs cs"><span class="hljs-comment">// 控制</span><span class="hljs-keyword">this</span>.node.<span class="hljs-keyword">on</span>(  cc.Node.EventType.TOUCH_MOVE,  function (<span class="hljs-keyword">event</span>) &#123;    <span class="hljs-keyword">if</span> (GameMode.gameOver) &#123;      <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">this</span>.player.x -= <span class="hljs-keyword">event</span>.getPreviousLocation().x - <span class="hljs-keyword">event</span>.getLocation().x;    <span class="hljs-keyword">this</span>.player.y -= <span class="hljs-keyword">event</span>.getPreviousLocation().y - <span class="hljs-keyword">event</span>.getLocation().y;  &#125;,  <span class="hljs-keyword">this</span>);</code></pre><h2 id="敌方飞机"><a href="#敌方飞机" class="headerlink" title="敌方飞机"></a><strong>敌方飞机</strong></h2><p>敌方飞机的生成是使用一个随机数，让它在屏幕外面随机生成，同时不断的改变飞机的y轴值就可以实现一直向下移动。</p><pre><code class="hljs typescript">creatEnemy(enemyCount: <span class="hljs-built_in">number</span>, enemyList: <span class="hljs-built_in">Array</span>&lt;cc.Node&gt;, hp: <span class="hljs-built_in">number</span>) &#123;  <span class="hljs-keyword">let</span> enemy = enemyList[enemyCount];  <span class="hljs-keyword">let</span> enemyS: Enemy = enemy.getComponent(<span class="hljs-string">"Enemy"</span>);  enemyS.death = <span class="hljs-literal">false</span>;  enemyS.hp = hp;  enemy.setPosition(    <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">570</span> - <span class="hljs-number">285</span>), <span class="hljs-comment">// 位置随机</span>    <span class="hljs-keyword">this</span>.enemyPos.getPosition().y  );  enemy.active = <span class="hljs-literal">true</span>;&#125;</code></pre><h2 id="动画系统"><a href="#动画系统" class="headerlink" title="动画系统"></a><strong>动画系统</strong></h2><p>飞机的爆炸都是通过cocos的动画系统来实现，在飞机判断死亡时，就开始播放动画，等到动画结束，就将敌方飞机的<strong>渲染关闭</strong>。这里使用的是关闭渲染而不是进行销毁对象，因为对象的动态创建是非常消耗性能的，所以我选择在游戏加载的时候就将敌方的几十架飞机全部创建，然后要使用时对它们进行初始化。</p><pre><code class="hljs reasonml">init<span class="hljs-constructor">Enemy(<span class="hljs-params">enemyList</span>: Array&lt;<span class="hljs-params">cc</span>.Node&gt;, <span class="hljs-params">enemy</span>: <span class="hljs-params">cc</span>.Node, <span class="hljs-params">count</span>: <span class="hljs-params">number</span>)</span> &#123;  <span class="hljs-comment">//生成敌人</span>  for (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;    <span class="hljs-keyword">let</span> ene = cc.instantiate(enemy);    this.node.add<span class="hljs-constructor">Child(<span class="hljs-params">ene</span>)</span>;    ene.active = <span class="hljs-literal">false</span>;    enemyList<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = ene;  &#125;&#125;</code></pre><h2 id="击中目标"><a href="#击中目标" class="headerlink" title="击中目标"></a><strong>击中目标</strong></h2><p>cocos自带了碰撞功能，只需要在初始化时开启碰撞，并且在组件上面添加了碰撞盒子，就可以通过<code>onCollisionEnter</code>方法监听到碰撞。</p><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">manager</span> = cc.director.getCollisionManager();manager.<span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span>; // 开启碰撞</code></pre><p><img src="/image/v2-52a8b33cdc7502577843ab7fa6a6b6ab_720w.png" srcset="/img/loading.gif" alt="img"></p><h2 id="细节部分"><a href="#细节部分" class="headerlink" title="细节部分"></a><strong>细节部分</strong></h2><h2 id="重新开始"><a href="#重新开始" class="headerlink" title="重新开始"></a><strong>重新开始</strong></h2><p>使用cocos提供的方法<code>cc.director.loadScene(&quot;Game&quot;);</code>就可以重置场景，但是这里我遇到了一个坑，不管是通过该方法提供的回调函数，还是直接写在下面，重置时都无法再次拿到当前脚本上的对象。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><p>生成不同等级的敌方飞机这是一个非常需要考虑细节的地方。制作游戏的时候你需要考虑再加入一种类型的飞机，那么需要怎么加才最方便，而不是需要加一种敌方飞机，就又重新全部写一次代码。当然，因为偷懒，所以这部分我基本没有怎么考虑了。</p>]]></content>
    
    
    <categories>
      
      <category>web开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>Cocos Creator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习C++时遇到的与其它编程语言中的不同与难点</title>
    <link href="/2020/05/04/%E5%AD%A6%E4%B9%A0C++%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8E%E5%85%B6%E5%AE%83%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B8%8E%E9%9A%BE%E7%82%B9/"/>
    <url>/2020/05/04/%E5%AD%A6%E4%B9%A0C++%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8E%E5%85%B6%E5%AE%83%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%90%8C%E4%B8%8E%E9%9A%BE%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<p>C++是目前公认的比较难学的一门编程语言，因为其中的知识点过于复杂和繁琐，连谷歌设计Golang的时候，都将目标设定为：“不要像C++。”</p><p>那么既然这么难学，为什么还要学它呢，是因为它在某些领域拥有非常大的优势：</p><ol><li>游戏服务端开发</li><li>游戏开发</li><li>数字图像处理</li><li>科学计算</li><li>网络软件</li><li>分布式应用</li><li>操作系统</li><li>嵌入式系统</li><li>教育与科研</li><li>…</li></ol><p>尤其是现在<strong>虚幻引擎</strong>在世界范围内逐渐升温，<strong>Cocos2d-x</strong>也需要使用C++进行开发。所以C++的应用范围非常的广泛，其实编程语言没有什么孰好孰坏之分，只有合适与不合适的区别。</p><p><strong>本文的运行环境为32位操作系统，C++开发默认运行环境即为32位操作系统，下面文章中所提到的占用内存空间统统都指的32位运行环境。</strong></p><h1 id="1-指针（非常重要）"><a href="#1-指针（非常重要）" class="headerlink" title="1. 指针（非常重要）"></a><strong>1. 指针（非常重要）</strong></h1><p>目前学习C++时遇到的和其它编程语言最大的不同点，就是指针。指针可能单独作为一部分来看并不难，<strong>难点是后面的值传递，地址传递，引用传递，深拷贝，浅拷贝这些知识点使用到指针的时候，就感觉突然从<code>1+1=2</code>的题目上升到微积分。</strong></p><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li>内存编号是从0开始记录的，一般用十六进制数字表示</li><li>可以利用指针变量保存地址</li></ul><p><strong>指针变量定义</strong>语法： <code>数据类型 * 变量名；</code></p><ul><li><strong>普通变量存放的是数据,指针变量存放的是地址</strong></li><li><strong>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用</strong></li></ul><h2 id="1-1-指针所占内存"><a href="#1-1-指针所占内存" class="headerlink" title="1.1 指针所占内存"></a><strong>1.1 指针所占内存</strong></h2><p>在不同的系统下指针所占的内存不同，一般情况下<strong>所有指针类型在32位操作系统下是4个字节，在64位系统下使8个字节。</strong></p><h2 id="1-2-空指针和野指针"><a href="#1-2-空指针和野指针" class="headerlink" title="1.2 空指针和野指针"></a><strong>1.2 空指针和野指针</strong></h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为00000000的空间</span>    <span class="hljs-keyword">int</span> * p = <span class="hljs-literal">NULL</span>;     <span class="hljs-comment">//访问空指针报错 </span>    <span class="hljs-comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>野指针</strong>：指针变量指向非法的内存空间即指向了系统占用内存空间。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">//指针变量p指向内存地址编号为0x1100的空间</span>    <span class="hljs-keyword">int</span> * p = (<span class="hljs-keyword">int</span> *)<span class="hljs-number">0x1100</span>;    <span class="hljs-comment">//访问野指针报错 </span>    <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>空指针和野指针都不是我们申请的空间，因此不要访问。</strong></p><h2 id="1-3-const修饰指针"><a href="#1-3-const修饰指针" class="headerlink" title="1.3 const修饰指针"></a><strong>1.3 const修饰指针</strong></h2><p>const修饰指针有三种情况</p><ol><li>const修饰指针 — 常量指针</li><li>const修饰常量 — 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>;    <span class="hljs-comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p1 = &amp;a;    p1 = &amp;b; <span class="hljs-comment">//正确</span>    <span class="hljs-comment">//*p1 = 100;  报错</span>    <span class="hljs-comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span>    <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p2 = &amp;a;    <span class="hljs-comment">//p2 = &amp;b; //错误</span>    *p2 = <span class="hljs-number">100</span>; <span class="hljs-comment">//正确</span>    <span class="hljs-comment">//const既修饰指针又修饰常量</span>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *<span class="hljs-keyword">const</span> p3 = &amp;a;    <span class="hljs-comment">//p3 = &amp;b; //错误</span>    <span class="hljs-comment">//*p3 = 100; //错误</span>    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="1-4-指针和数组"><a href="#1-4-指针和数组" class="headerlink" title="1.4 指针和数组"></a><strong>1.4 指针和数组</strong></h2><p>因为数组在内存上面开辟的是一块连续的运行空间，而数组的变量也储存的数组所在内存的地址，所以我们可以通过指针来遍历数组。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;    <span class="hljs-keyword">int</span> *p = arr;  <span class="hljs-comment">//指向数组的指针</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"第一个元素： "</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-comment">//利用指针遍历数组</span>        <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;        p++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>又因为数组的变量名记录的是它的地址，那么问题又来了。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[])</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;        arr[i] = <span class="hljs-number">10</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;    change(arr);<span class="hljs-comment">//调用改变函数</span>    <span class="hljs-keyword">int</span> *p = arr;  <span class="hljs-comment">//指向数组的指针</span>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"第一个元素： "</span> &lt;&lt; arr[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"指针访问第一个元素： "</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;        <span class="hljs-comment">//利用指针遍历数组</span>        <span class="hljs-built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="hljs-built_in">endl</span>;        p++;    &#125;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果我们在函数change中改变了arr的值，那么在main函数中遍历会输出什么结果？</p><pre><code class="hljs cpp">第一个元素： <span class="hljs-number">10</span>指针访问第一个元素： <span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span><span class="hljs-number">10</span></code></pre><p>可以看到，在change函数中改变了arr中的值，main函数中的arr也发生了改变。</p><h2 id="1-5-指针和函数-非常重要"><a href="#1-5-指针和函数-非常重要" class="headerlink" title="1.5 指针和函数(非常重要)"></a><strong>1.5 指针和函数(非常重要)</strong></h2><p>这个在其它编程语言中使用时出现的情况也非常的多，虽然其它编程语言中不操作指针，但是涉及到值传递和引用传递，原理上和C++的指针一样。</p><p>在一般情况下，形参是不能修饰实参的。例如：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>&#123;    a = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"change函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    change(a);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"main函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>那么这个函数里的a和函数外的a输出分别是多少？</p><pre><code class="hljs cpp"><span class="hljs-comment">//change函数里的a值为1000</span><span class="hljs-comment">//main函数里的a值为100</span></code></pre><p>可以看到，即便在change函数里面修改了a的值，但main函数中的a值不会发生改变。</p><p>那么下面的例子change函数里的a和main函数里的a输出分别又是多少？</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a)</span> </span>&#123;    *a = <span class="hljs-number">1000</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"change函数里的*a值为"</span> &lt;&lt; *a &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">100</span>;    change(&amp;a);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"main函数里的a值为"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>可以看到上面只将主函数中的变量a的地址传入到change函数中，那么运行后主函数中a的值又是多少？</p><pre><code class="hljs cpp">change函数里的*a值为<span class="hljs-number">1000</span>main函数里的a值为<span class="hljs-number">1000</span></code></pre><p>可以看到main函数里的a值被改变了。</p><p><strong>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递。</strong></p><h2 id="1-6-指针总结"><a href="#1-6-指针总结" class="headerlink" title="1.6 指针总结"></a><strong>1.6 指针总结</strong></h2><p>无论在哪门编程语言中，指针的指向都是非常重要必须要进行理解的，建议多看看相关类型的资料，因为对于初学者而言，指针并不是那么容易理解，必须在经过大量的练习后，才能融会贯通。</p><h1 id="2-引用"><a href="#2-引用" class="headerlink" title="2. 引用"></a><strong>2. 引用</strong></h1><p>通过引用可以给变量起别名。</p><p>语法：<code>数据类型 &amp;别名 = 原名</code></p><h2 id="2-1-注意事项"><a href="#2-1-注意事项" class="headerlink" title="2.1 注意事项"></a><strong>2.1 注意事项</strong></h2><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><h2 id="2-2-引用做函数参数"><a href="#2-2-引用做函数参数" class="headerlink" title="2.2 引用做函数参数"></a><strong>2.2 引用做函数参数</strong></h2><p>上文也提到过参数有3种传递方式：</p><ol><li>值传递</li><li>地址传递</li><li>引用传递</li></ol><p><strong>作用：</strong>函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong>可以简化指针修改实参</p><pre><code class="hljs cpp"><span class="hljs-comment">//1. 值传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-comment">//2. 地址传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* a, <span class="hljs-keyword">int</span>* b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = *a;    *a = *b;    *b = temp;&#125;<span class="hljs-comment">//3. 引用传递</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; a, <span class="hljs-keyword">int</span>&amp; b)</span> </span>&#123;    <span class="hljs-keyword">int</span> temp = a;    a = b;    b = temp;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;    mySwap01(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap02(&amp;a, &amp;b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    mySwap03(a, b);    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">" b:"</span> &lt;&lt; b &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单。</strong></p><h2 id="2-3-引用做函数返回值"><a href="#2-3-引用做函数返回值" class="headerlink" title="2.3 引用做函数返回值"></a><strong>2.3 引用做函数返回值</strong></h2><p>注意：<strong>不要返回局部变量引用</strong>，因为局部变量引用会在函数结束调用后进行销毁。</p><p>用法：函数调用作为左值</p><h2 id="2-4-引用的本质"><a href="#2-4-引用的本质" class="headerlink" title="2.4 引用的本质"></a><strong>2.4 引用的本质</strong></h2><pre><code class="hljs cpp"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>&amp; ref)</span></span>&#123;    ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;        <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span>    <span class="hljs-keyword">int</span>&amp; ref = a;     ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"a:"</span> &lt;&lt; a &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ref:"</span> &lt;&lt; ref &lt;&lt; <span class="hljs-built_in">endl</span>;        func(a);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>引用的本质在c++内部实现是一个指针常量.</strong></p><h2 id="2-5-常量引用"><a href="#2-5-常量引用" class="headerlink" title="2.5 常量引用"></a><strong>2.5 常量引用</strong></h2><p><strong>作用：</strong>常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加<strong>const修饰形参</strong>，防止形参改变实参，例如：<code>const int&amp; ref = 10;</code></p><h1 id="3-函数声明"><a href="#3-函数声明" class="headerlink" title="3. 函数声明"></a><strong>3. 函数声明</strong></h1><h2 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a><strong>3.1 函数默认参数</strong></h2><p>C++中，函数的形参列表中的形参可以拥有默认值。</p><p>语法：<code>返回值类型 函数名 （参数= 默认值）{}</code></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b + c;&#125;<span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ret = "</span> &lt;&lt; func(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ret = "</span> &lt;&lt; func(<span class="hljs-number">100</span>) &lt;&lt; <span class="hljs-built_in">endl</span>;    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-2-占位参数"><a href="#3-2-占位参数" class="headerlink" title="3.2 占位参数"></a><strong>3.2 占位参数</strong></h2><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型){}</code></p><p>主要用在类的多态。</p><pre><code class="hljs cpp"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span>)</span> </span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"this is func"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span>    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-3-函数的重载"><a href="#3-3-函数的重载" class="headerlink" title="3.3 函数的重载"></a><strong>3.3 函数的重载</strong></h2><p><strong>作用：</strong>函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong> 或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><pre><code class="hljs cpp"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (int a) 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (double a)的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a ,<span class="hljs-keyword">double</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (int a ,double b) 的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a ,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func (double a ,int b)的调用！"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><span class="hljs-comment">//int func(double a, int b)</span><span class="hljs-comment">//&#123;</span><span class="hljs-comment">//  cout &lt;&lt; "func (double a ,int b)的调用！" &lt;&lt; endl;</span><span class="hljs-comment">//&#125;</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    func();    func(<span class="hljs-number">10</span>);    func(<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);    func(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);        system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="3-4-注意"><a href="#3-4-注意" class="headerlink" title="3.4 注意"></a><strong>3.4 注意</strong></h2><p>尽量不要出现二义性：</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">10</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func2(int a, int b = 10) 调用"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"func2(int a) 调用"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;&#125;</code></pre><p>上面这个函数重载就具有二义性，编译器不知道应该调用哪个函数。</p><h1 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4. 类和对象"></a><strong>4. 类和对象</strong></h1><p>面向对象的三大特性：</p><ol><li>封装</li><li>继承</li><li>多态</li></ol><h2 id="4-1-访问权限"><a href="#4-1-访问权限" class="headerlink" title="4.1 访问权限"></a><strong>4.1 访问权限</strong></h2><ol><li><code>public</code> 公共权限 类内可以访问 类外可以访问</li><li><code>protected</code> 保护权限 类内可以访问 类外不可以访问</li><li><code>private</code> 私有权限 类内可以访问 类外不可以访问</li></ol><h2 id="4-2-struct和class的区别"><a href="#4-2-struct和class的区别" class="headerlink" title="4.2 struct和class的区别"></a><strong>4.2 struct和class的区别</strong></h2><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class 默认权限为私有</li></ul><h2 id="4-3-构造函数和析构函数"><a href="#4-3-构造函数和析构函数" class="headerlink" title="4.3 构造函数和析构函数"></a><strong>4.3 构造函数和析构函数</strong></h2><p>在其它高级编程语言中，构造函数经常使用，析构函数很少会用到，因为其它高级编程语言中自带垃圾回收机制（GC），而C++中则没有自动垃圾回收机制，所以需要通过析构函数进行销毁对象、变量。</p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><h3 id="4-3-1-析构函数"><a href="#4-3-1-析构函数" class="headerlink" title="4.3.1 析构函数"></a><strong>4.3.1 析构函数</strong></h3><p><strong>析构函数语法：</strong> <code>~类名(){}</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号 ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><h3 id="4-3-2-构造函数"><a href="#4-3-2-构造函数" class="headerlink" title="4.3.2 构造函数"></a><strong>4.3.2 构造函数</strong></h3><p>在C++中自带普通构造函数和拷贝构造函数。</p><p>拷贝构造函数调用：</p><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><h3 id="4-3-3-总结"><a href="#4-3-3-总结" class="headerlink" title="4.3.3 总结"></a><strong>4.3.3 总结</strong></h3><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li>如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造</li><li>如果用户定义拷贝构造函数，c++不会再提供其它构造函数</li></ul><h2 id="4-4-深拷贝和浅拷贝（重点）"><a href="#4-4-深拷贝和浅拷贝（重点）" class="headerlink" title="4.4 深拷贝和浅拷贝（重点）"></a><strong>4.4 深拷贝和浅拷贝（重点）</strong></h2><p>如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题。</p><h2 id="4-5-初始化列表"><a href="#4-5-初始化列表" class="headerlink" title="4.5 初始化列表"></a><strong>4.5 初始化列表</strong></h2><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    <span class="hljs-comment">////传统方式初始化</span>    <span class="hljs-comment">//Person(int a, int b, int c) &#123;</span>    <span class="hljs-comment">//  m_A = a;</span>    <span class="hljs-comment">//  m_B = b;</span>    <span class="hljs-comment">//  m_C = c;</span>    <span class="hljs-comment">//&#125;</span>    <span class="hljs-comment">//初始化列表方式初始化</span>    Person(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c) :m_A(a), m_B(b), m_C(c) &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mA:"</span> &lt;&lt; m_A &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mB:"</span> &lt;&lt; m_B &lt;&lt; <span class="hljs-built_in">endl</span>;        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"mC:"</span> &lt;&lt; m_C &lt;&lt; <span class="hljs-built_in">endl</span>;    &#125;<span class="hljs-keyword">private</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">int</span> m_B;    <span class="hljs-keyword">int</span> m_C;&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;    p.PrintPerson();    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... {}</code></p><h2 id="4-6-常函数和常对象"><a href="#4-6-常函数和常对象" class="headerlink" title="4.6 常函数和常对象"></a><strong>4.6 常函数和常对象</strong></h2><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字<code>mutable</code>后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span><span class="hljs-keyword">public</span>:    Person() &#123;        m_A = <span class="hljs-number">0</span>;        m_B = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span>    <span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//const Type* const pointer;</span>        <span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span>        <span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span>        <span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span>        <span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123;        <span class="hljs-comment">//mA = 10000;</span>    &#125;<span class="hljs-keyword">public</span>:    <span class="hljs-keyword">int</span> m_A;    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span>&#125;;<span class="hljs-comment">//const修饰对象  常对象</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">const</span> Person person; <span class="hljs-comment">//常量对象  </span>    <span class="hljs-built_in">cout</span> &lt;&lt; person.m_A &lt;&lt; <span class="hljs-built_in">endl</span>;    <span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span>    person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span>    <span class="hljs-comment">//常对象访问成员函数</span>    person.MyFunc(); <span class="hljs-comment">//常对象不能调用const的函数</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    test01();    system(<span class="hljs-string">"pause"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="4-7-友元"><a href="#4-7-友元" class="headerlink" title="4.7 友元"></a><strong>4.7 友元</strong></h2><p>私有属性(Private) 也想让类外特殊的一些函数或者类进行访问，就需要用到友元（friend）</p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h2 id="4-8-运算符重载"><a href="#4-8-运算符重载" class="headerlink" title="4.8 运算符重载"></a><strong>4.8 运算符重载</strong></h2><pre><code class="hljs cpp">函数名 <span class="hljs-keyword">operator</span>运算符()</code></pre><p>例如：<code>Person operator+(const Person&amp; p)</code></p><p>几乎所有的运算符都能进行重载。</p><h2 id="4-9-多继承（慎用）"><a href="#4-9-多继承（慎用）" class="headerlink" title="4.9 多继承（慎用）"></a><strong>4.9 多继承（慎用）</strong></h2><p>其它编程语言中一般为单继承，但是在C++中允许多继承。</p><p>语法：<code>class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><h2 id="4-10-菱形继承（了解）"><a href="#4-10-菱形继承（了解）" class="headerlink" title="4.10 菱形继承（了解）"></a><strong>4.10 菱形继承（了解）</strong></h2><p>两个派生类继承同一个基类</p><p>又有某个类同时继承者两个派生类</p><p>这种继承被称为菱形继承，或者钻石继承</p><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用<strong>虚继承</strong>可以解决菱形继承问题</li></ul><h2 id="4-11-多态"><a href="#4-11-多态" class="headerlink" title="4.11 多态"></a><strong>4.11 多态</strong></h2><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数（函数前面加上virtual关键字）实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定 - 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定 - 运行阶段确定函数地址</li></ul><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h3 id="4-11-1-虚函数和抽象类（接口）-重要"><a href="#4-11-1-虚函数和抽象类（接口）-重要" class="headerlink" title="4.11.1 虚函数和抽象类（接口）(重要)"></a><strong>4.11.1 虚函数和抽象类（接口）(重要)</strong></h3><p>C++中没有接口的概念，但是可以用抽象类来实现接口。</p><p>虚函数</p><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><h3 id="4-11-2-虚析构和纯虚析构"><a href="#4-11-2-虚析构和纯虚析构" class="headerlink" title="4.11.2 虚析构和纯虚析构"></a><strong>4.11.2 虚析构和纯虚析构</strong></h3><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li><strong>都需要有具体的函数实现</strong></li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><pre><code class="hljs cpp"><span class="hljs-keyword">virtual</span> ~类名()&#123;&#125;</code></pre><p>纯虚析构语法：</p><pre><code class="hljs gcode">virtual ~类名<span class="hljs-comment">()</span> = <span class="hljs-number">0</span>;类名::~类名<span class="hljs-comment">()</span>&#123;&#125;</code></pre><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a><strong>5. 参考资料</strong></h1><p>视频：<a href="https://www.bilibili.com/video/BV1et411b73Z" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1et411b73Z</a></p><p>笔记：<a href="https://github.com/AnkerLeng/Cpp-0-1-Resource" target="_blank" rel="noopener">https://github.com/AnkerLeng/Cpp-0-1-Resource</a></p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nodejs中module.exports和exports的区别</title>
    <link href="/2019/10/22/nodejs%E4%B8%ADmodule.exports%E5%92%8Cexports%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2019/10/22/nodejs%E4%B8%ADmodule.exports%E5%92%8Cexports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>最近在学习nodejs，这篇文章就权当是一篇笔记，如果有什么地方有误，望指出。</p><p>先说说它们之间的区别：</p><ul><li>exports只能使用语法来向外暴露内部变量：如exports.xxx = xxx;</li><li>module.exports既可以通过语法，也可以直接赋值一个对象。</li></ul><p>我们要明白一点，exports和module.exports其实是一个东西，不信我们来输出一下</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>.exports === exports);<span class="hljs-comment">//输出结果为：true</span></code></pre><p>输出结果是true其实就说明它们就是一个东西，其实exports = module.exports，因为他们是引用类型的一个变量名，所以当exports再指向一个引用类型的时候，那么他们就不再全等。</p><pre><code class="hljs js">exports = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(exports === <span class="hljs-built_in">module</span>.exports);<span class="hljs-comment">//输出结果为：false</span></code></pre><p>当然，如果直接通过exports.xxx的形式赋值，那么他们依然会指向同一个地址：</p><pre><code class="hljs js">exports.array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];<span class="hljs-built_in">console</span>.log(exports === <span class="hljs-built_in">module</span>.exports);<span class="hljs-comment">//输出结果为：true</span></code></pre><p>这个时候要明白module.exports和exports的区别，就要清楚什么是值类型，什么是引用类型。我对值类型和引用类型的理解就是，看它是存储在栈上，还是存储在堆上，值类型就是存储在栈上，引用类型是存储在堆上，但是有个很特殊的情况是，引用类型的名字，是存储在栈上，然后这个名字指向了堆上的一个地址，从而可以直接使用变量名，调用堆上的数据。</p><p><img src="/image/v2-52e9a85deec48e2fe61708b20058dd48_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>这样可能有点难以理解，我们用代码来简单的认识一下值类型：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> b = a;a = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a的值是："</span> + a);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);</code></pre><p>我们将1赋值为a，然后将a赋值给b，然后我们将2赋值为a那么这个时候a和b分别是多少呢？我们将它运行一下看结果：</p><p><img src="/image/v2-3eb9fd92f22e0c9983cb495fd03118df_720w.png" srcset="/img/loading.gif" alt="img"></p><p>那么为什么a的值是2，b的值为1呢？是因为当将a赋值给b的时候，相当于是将a的值拷贝给了b也就相当于是重新生成了一个b，那么这个b与a就没有什么关系了，如下图所示：</p><p><img src="/image/v2-df0097016e4d9ea1376ed617def5fc1b_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>可以看出，这个时候再去改变变量a的值，那么b的值肯定不会发生变化。</p><p>那么引用类型呢：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<span class="hljs-keyword">let</span> b = a;a[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a的值是："</span> + a);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);</code></pre><p>那么问题来了，这个时候的b会输出什么结果，是[1,2]还是[0,2]那么我们来进行输出一下</p><p><img src="/image/v2-a0ccf94fbc537f969c46bb043ff833d3_720w.png" srcset="/img/loading.gif" alt="img"></p><p>这个时候为什么输出的结果是0,2呢？这里就涉及到引用类型了，如下图所示：</p><p><img src="/image/v2-455d624d8c5029570d6dcaa4771b4173_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从图上面看的出来，栈中只是存储了一个变量名字，而数组是存储在堆中。而当将a赋值给b的时候，并不是从堆中拷贝一个数组再让b指向这个数组，而是直接将b指向和a指向的同一个数组。简单来说，可以把变量a看做是银行账户的存折，变量b是银行账户的卡，都是同一个账户，你从存折里面取钱或者存钱，那么卡中的钱也会跟着变多或者变少。</p><p>那么我们回到主题，那么我们再来说为什么module.exports可以赋值一个对象，而exports却不可以。要明白这点，就要从nodejs的模块化说起，当nodejs执行模块中的代码时，它会将模块中的代码，用一个函数进行包裹：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">exports, require, module, __filename, __dirname</span>) </span>&#123;&#125;</code></pre><p>这里面的其他参数就在这篇文章中不仔细讲解了，不过可以发现，里面有个熟悉的参数module。这里就要说到exports的本质了，正如上面所说exports = module.exports，也就是说他们指向了堆空间的同一个东西，如果对exports进行赋值，那么exports的指向就不一样了，在另外的文件里面就无法再找到通过exports这个变量传递的东西，而module.exports是在执行模块代码中就将module传入到了函数中，所以即使module.exports的值改变也能够在其他文件中进行调用。</p><p>再写到这里的时候我产生了一个疑问，如果将module.exports的指向改变，那么通过exports.xxx传递的值在其他文件中还能进行调用嘛，于是我尝试了下面的代码：</p><pre><code class="hljs js"><span class="hljs-comment">//Test.js</span>exports.add = <span class="hljs-number">100</span>;<span class="hljs-built_in">module</span>.exports = <span class="hljs-number">1</span>;<span class="hljs-comment">//test1.js文件</span><span class="hljs-keyword">let</span> test = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./Test"</span>);<span class="hljs-keyword">let</span> p = test.add;<span class="hljs-keyword">let</span> b = test;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p的值是："</span> + p);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">"b的值是："</span> + b);<span class="hljs-comment">/*</span><span class="hljs-comment">输出结果是：</span><span class="hljs-comment">p的值是：undefined</span><span class="hljs-comment">b的值是：1</span><span class="hljs-comment">*/</span></code></pre><p>可以看出，改变了module.exports的指向后，exports.xxx的值在其他文件中也无法调用。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Html做一个快乐鸟小游戏</title>
    <link href="/2019/10/21/%E7%94%A8Html%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BF%AB%E4%B9%90%E9%B8%9F%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <url>/2019/10/21/%E7%94%A8Html%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BF%AB%E4%B9%90%E9%B8%9F%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p>入门学习前端的时候做了这么一个简单的小游戏，为了将自己所学到的知识运用起来。</p><p><img src="/image/v2-c13b0cc0371ffc4725089cd58754cce7_b.webp" srcset="/img/loading.gif" alt="img"></p><p>做这个小游戏用到了：</p><ul><li>html</li><li>css</li><li>jQuery</li></ul><p>然后这个小游戏的图片素材用到了：</p><p><img src="/image/v2-3a6aca1fff7faed32f2c40d64ca258e0_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>其实用原生的js也是可以完成的，但是为什么要用jQuery？因为我直接跳过了原生JS的学习…只有等空余的时候，好好的找本书研究一下原生的js。</p><h1 id="一、-大致流程"><a href="#一、-大致流程" class="headerlink" title="一、 大致流程"></a>一、 大致流程</h1><p>下面是这个小游戏的大致流程：</p><p><img src="/image/v2-65bd207c86e0fac108f4bc74df6f6b37_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>其中鸟和管道应该用面向对象来做，但是我原生JS只学习了最基础的部分，而且JS在ES5的时候还没有类的概念，只能使用构造函数来模拟一个类，在ES6的时候才加入了class这个关键字，但是我知道ES6的时候，已经是在完成这个小游戏之后了。</p><p>从上面的素材图片只有4张可以看得出来，html和CSS的搭建是没有太大难度的。所以本文着重讲解JS的部分。</p><p>这里值得一说的是，我CSS上面是用的子绝父相的定律，来摆放鸟和管道，其中管道的代码如下所示：</p><pre><code class="hljs js"><span class="hljs-comment">/* 上边的管道 */</span>.tubeTop &#123;  width: <span class="hljs-number">90</span>px; height: <span class="hljs-number">420</span>px; background: url(<span class="hljs-regexp">/image/</span>bird/ColumnSprite.png) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>; background-size: cover; transform: rotate(<span class="hljs-number">180</span>deg);&#125;<span class="hljs-comment">/* 下边的管道 */</span>.tubebotton &#123; width: <span class="hljs-number">90</span>px; height: <span class="hljs-number">420</span>px; background: url(<span class="hljs-regexp">/image/</span>bird/ColumnSprite.png) no-repeat <span class="hljs-number">0</span> <span class="hljs-number">0</span>; background-size: cover; margin-top: <span class="hljs-number">100</span>px;&#125;.tube &#123; position: absolute; top: <span class="hljs-number">0</span>;&#125;</code></pre><p>可以看得出来，其实上下管道用的是一张图片，只是将它旋转了180度，然后包含在一个div中，这样只要设置父盒子的位置，上下的两根管道的位置就不需要再去设置。</p><h1 id="二、-游戏逻辑"><a href="#二、-游戏逻辑" class="headerlink" title="二、 游戏逻辑"></a>二、 游戏逻辑</h1><p>模型控制：</p><p>其实整个游戏，鸟是没有动的，我是让背景向前移动，这里有一点需要注意背景我并不是拼接了很多张图，而是仅仅用了两张图，一张在可视范围内，一张在可视范围外，当前面的那张移出可视范围的时候，再用JS将它放置到后面那张背景的后面，这样反复，就可以变成一个无限背景。</p><p><img src="/image/v2-c57658b57d9d36d24b977109ad44d91c_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>当管道移除可视范围外的时候，我并没有将它进行销毁，而是用JS重新设置它的位置，因为产生和销毁一个物体的时候，是非常的耗费性能的，如果一个物件能够复用，就需要想办法进行复用。</p><p>控制管道和背景的代码，管道的位置控制都是通过css设置它们position：</p><pre><code class="hljs js"><span class="hljs-comment">//控制管道</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tubeControl</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-comment">//背景1</span><span class="hljs-keyword">var</span> bgImg1 = $(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bgImg1 = bgImg1 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, bgImg1);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(bgImg1) &lt; <span class="hljs-number">-1490</span>) &#123;bgImg1 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, bgImg1);&#125;<span class="hljs-comment">//背景2</span><span class="hljs-keyword">var</span> bgImg2 = $(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bgImg2 = bgImg2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, bgImg2);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(bgImg2) &lt; <span class="hljs-number">-1490</span>) &#123;bgImg2 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, bgImg2);&#125;<span class="hljs-comment">//草</span><span class="hljs-keyword">var</span> Green = $(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];Green = Green - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, Green);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(Green) &lt; <span class="hljs-number">-1490</span>) &#123;Green = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, Green);&#125;<span class="hljs-keyword">var</span> Green2 = $(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];Green2 = Green2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, Green2);<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(Green2) &lt; <span class="hljs-number">-1490</span>) &#123;Green2 = <span class="hljs-number">1500</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, Green2);&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">-250</span>) &#123;left = <span class="hljs-number">1550</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);tube.eq(i).css(<span class="hljs-string">"top"</span>, top);&#125; <span class="hljs-keyword">else</span> &#123;left -= <span class="hljs-number">1</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);&#125;&#125;&#125;</code></pre><p>当管道已经移出可视范围的时候，给它一个随机数重新设置它的位置：</p><pre><code class="hljs js"><span class="hljs-comment">// 随机数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRondom</span>(<span class="hljs-params">muth</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * muth);&#125;<span class="hljs-comment">//Math.random()是随机生成0~1之间的小数</span></code></pre><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">-250</span>) &#123;left = <span class="hljs-number">1550</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);tube.eq(i).css(<span class="hljs-string">"top"</span>, top);&#125; <span class="hljs-keyword">else</span> &#123;left -= <span class="hljs-number">1</span>;tube.eq(i).css(<span class="hljs-string">"left"</span>, left);&#125;&#125;</code></pre><p>控制鸟的方式我是一直让它向下走：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">birdDown</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];bird = <span class="hljs-built_in">parseInt</span>(bird) + <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;$(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>, bird);&#125;</code></pre><p>然后鸟的动画部分就是让图片来回切换就可以达到动起来的效果，但是开篇的BUG也是在这里产生的，因为这个切换图片设置了延迟，所以在鸟死亡的时候，可能这个图片还没有进行切换：</p><pre><code class="hljs js"><span class="hljs-comment">//让鸟动起来</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">birdAnima</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>);setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.die) &#123;$(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"background-position"</span>,<span class="hljs-string">"-128px 0px"</span>);<span class="hljs-keyword">return</span>;&#125;bird.css(<span class="hljs-string">"background-position"</span>, <span class="hljs-string">"-64px 0px"</span>);setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;bird.css(<span class="hljs-string">"background-position"</span>,<span class="hljs-string">"0px 0px"</span>);&#125;, <span class="hljs-number">250</span>);&#125;, <span class="hljs-number">500</span>);&#125;</code></pre><p>我在怎么判断鸟是否撞到管道然后触发死亡状态的地方卡了一会，最后我是通过鸟的盒子的上下左右的坐标因为他们都是绝对定位，而我给了整个可视窗口相对定位，所以当它们的坐标相同时，它们之间就会重叠，然后和管道的坐标进行一个判断：</p><pre><code class="hljs js"><span class="hljs-comment">//判断鸟的位置</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">gameControl</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">// 地面为bottom 100px</span><span class="hljs-keyword">var</span> birdBottom = $(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"bottom"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<span class="hljs-keyword">if</span> (<span class="hljs-built_in">parseInt</span>(birdBottom) &lt;= <span class="hljs-number">80</span>) &#123;death();&#125;<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-keyword">var</span> birdTop = <span class="hljs-built_in">parseInt</span>($(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">var</span> birdLeft = <span class="hljs-built_in">parseInt</span>($(<span class="hljs-string">".bird"</span>).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> top =<span class="hljs-built_in">parseInt</span>(tube.eq(i).css(<span class="hljs-string">"top"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]) + <span class="hljs-number">420</span>;<span class="hljs-keyword">var</span> left = <span class="hljs-built_in">parseInt</span>(tube.eq(i).css(<span class="hljs-string">"left"</span>).split(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>]);<span class="hljs-keyword">if</span> (birdTop &lt; top || birdTop + <span class="hljs-number">34</span> &gt; top + <span class="hljs-number">100</span>) &#123;<span class="hljs-keyword">if</span> (birdLeft + <span class="hljs-number">64</span> &gt; left + <span class="hljs-number">10</span> &amp;&amp;birdLeft &lt; left + <span class="hljs-number">90</span>) &#123;death();&#125;&#125;<span class="hljs-keyword">if</span> (left &lt; <span class="hljs-number">300</span>) &#123;<span class="hljs-built_in">console</span>.log(birdLeft, left + <span class="hljs-number">90</span>);&#125;<span class="hljs-keyword">if</span> (birdLeft &gt; left + <span class="hljs-number">90</span> &amp;&amp;birdLeft &lt; left + <span class="hljs-number">101</span>) &#123;addScroe();&#125;&#125;&#125;</code></pre><p>得分的判断也在这个函数中，当小鸟飞过管道的某一位置，就调用addScroe()这个方法</p><p>为了保证分数和死亡只有一个，所以我将他们设置为全局变量window.die和window.playScroe，如果撞到地板和管道，就调用death()函数，同时将die设置为true：</p><pre><code class="hljs js"><span class="hljs-comment">//死亡状态</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">death</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">window</span>.die = <span class="hljs-literal">true</span>;$(<span class="hljs-string">".gameEnd span"</span>).text(<span class="hljs-string">"您的得分:"</span> + <span class="hljs-built_in">window</span>.playScroe);$(<span class="hljs-string">".gameEnd"</span>).fadeToggle(<span class="hljs-number">200</span>);&#125;</code></pre><p><strong>注：声明变量时不加window也是全局变量，但是加上的话更明显，一眼就可以知道它是全局变量。</strong></p><p>最后是重新开始函数，将管道背景鸟的位置复位：</p><pre><code class="hljs js"><span class="hljs-comment">//重新开始</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Recovery</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">window</span>.die = <span class="hljs-literal">false</span>;<span class="hljs-built_in">window</span>.playScroe = <span class="hljs-number">0</span>;$(<span class="hljs-string">"#scroe"</span>).text(<span class="hljs-built_in">window</span>.playScroe);<span class="hljs-keyword">var</span> tube = $(<span class="hljs-string">".tube"</span>);<span class="hljs-keyword">var</span> wid = <span class="hljs-number">400</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tube.length; i++) &#123;<span class="hljs-keyword">var</span> left = wid + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> top = -myRondom(<span class="hljs-number">210</span>) + <span class="hljs-string">"px"</span>;tube.eq(i).css(<span class="hljs-string">"top"</span>, top);tube.eq(i).css(<span class="hljs-string">"left"</span>, left);wid += <span class="hljs-number">300</span>;&#125; <span class="hljs-comment">//背景1</span><span class="hljs-keyword">var</span> bgImg1 = $(<span class="hljs-string">".bgImage"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"0px"</span>);<span class="hljs-comment">//背景2</span><span class="hljs-keyword">var</span> bgImg2 = $(<span class="hljs-string">".bgImage2"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"1500px"</span>);<span class="hljs-comment">//草</span><span class="hljs-keyword">var</span> Green = $(<span class="hljs-string">".bootonGreen"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"0px"</span>);<span class="hljs-keyword">var</span> Green2 = $(<span class="hljs-string">".bootonGreen2"</span>).css(<span class="hljs-string">"left"</span>, <span class="hljs-string">"1500px"</span>);Green2 = Green2 - <span class="hljs-number">1</span> + <span class="hljs-string">"px"</span>;<span class="hljs-keyword">var</span> bird = $(<span class="hljs-string">".bird"</span>).css(&#123;left: <span class="hljs-string">"200px"</span>,top: <span class="hljs-string">"400px"</span>&#125;);&#125;</code></pre><p>整个小游戏大致的思路就是这样了，如果有什么疑问或者有什么错误的地方欢迎在评论指出~</p>]]></content>
    
    
    <categories>
      
      <category>游戏制作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>jQuery</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
